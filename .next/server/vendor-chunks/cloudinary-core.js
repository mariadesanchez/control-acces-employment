"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cloudinary-core";
exports.ids = ["vendor-chunks/cloudinary-core"];
exports.modules = {

/***/ "(rsc)/./node_modules/cloudinary-core/cloudinary-core.js":
/*!*********************************************************!*\
  !*** ./node_modules/cloudinary-core/cloudinary-core.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n   * cloudinary-core.js\n   * Cloudinary's JavaScript library - Version 2.14.0\n   * Copyright Cloudinary\n   * see https://github.com/cloudinary/cloudinary_js\n   *\n   */ (function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! lodash/assign */ \"lodash/assign\"), __webpack_require__(/*! lodash/cloneDeep */ \"lodash/cloneDeep\"), __webpack_require__(/*! lodash/compact */ \"lodash/compact\"), __webpack_require__(/*! lodash/difference */ \"lodash/difference\"), __webpack_require__(/*! lodash/functions */ \"lodash/functions\"), __webpack_require__(/*! lodash/identity */ \"lodash/identity\"), __webpack_require__(/*! lodash/includes */ \"lodash/includes\"), __webpack_require__(/*! lodash/isArray */ \"lodash/isArray\"), __webpack_require__(/*! lodash/isElement */ \"lodash/isElement\"), __webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"), __webpack_require__(/*! lodash/isPlainObject */ \"lodash/isPlainObject\"), __webpack_require__(/*! lodash/isString */ \"lodash/isString\"), __webpack_require__(/*! lodash/merge */ \"lodash/merge\"), __webpack_require__(/*! lodash/trim */ \"lodash/trim\"));\n    else {}\n})(void 0, function(__WEBPACK_EXTERNAL_MODULE_lodash_assign__, __WEBPACK_EXTERNAL_MODULE_lodash_cloneDeep__, __WEBPACK_EXTERNAL_MODULE_lodash_compact__, __WEBPACK_EXTERNAL_MODULE_lodash_difference__, __WEBPACK_EXTERNAL_MODULE_lodash_functions__, __WEBPACK_EXTERNAL_MODULE_lodash_identity__, __WEBPACK_EXTERNAL_MODULE_lodash_includes__, __WEBPACK_EXTERNAL_MODULE_lodash_isArray__, __WEBPACK_EXTERNAL_MODULE_lodash_isElement__, __WEBPACK_EXTERNAL_MODULE_lodash_isFunction__, __WEBPACK_EXTERNAL_MODULE_lodash_isPlainObject__, __WEBPACK_EXTERNAL_MODULE_lodash_isString__, __WEBPACK_EXTERNAL_MODULE_lodash_merge__, __WEBPACK_EXTERNAL_MODULE_lodash_trim__) {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_2864__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_2864__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_2864__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_2864__.c = installedModules;\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_2864__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_2864__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    enumerable: true,\n                    get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // define __esModule on exports\n        /******/ __nested_webpack_require_2864__.r = function(exports1) {\n            /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n                /******/ Object.defineProperty(exports1, Symbol.toStringTag, {\n                    value: \"Module\"\n                });\n            /******/ }\n            /******/ Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n        /******/ };\n        /******/ /******/ // create a fake namespace object\n        /******/ // mode & 1: value is a module id, require it\n        /******/ // mode & 2: merge all properties of value into the ns\n        /******/ // mode & 4: return value when already ns object\n        /******/ // mode & 8|1: behave like require\n        /******/ __nested_webpack_require_2864__.t = function(value, mode) {\n            /******/ if (mode & 1) value = __nested_webpack_require_2864__(value);\n            /******/ if (mode & 8) return value;\n            /******/ if (mode & 4 && typeof value === \"object\" && value && value.__esModule) return value;\n            /******/ var ns = Object.create(null);\n            /******/ __nested_webpack_require_2864__.r(ns);\n            /******/ Object.defineProperty(ns, \"default\", {\n                enumerable: true,\n                value: value\n            });\n            /******/ if (mode & 2 && typeof value != \"string\") for(var key in value)__nested_webpack_require_2864__.d(ns, key, (function(key) {\n                return value[key];\n            }).bind(null, key));\n            /******/ return ns;\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_2864__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_2864__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_2864__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_2864__.p = \"\";\n        /******/ /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_2864__(__nested_webpack_require_2864__.s = \"./src/namespace/cloudinary-core.js\");\n    /******/ }({\n        /***/ \"./src/namespace/cloudinary-core.js\": /***/ function(module1, __nested_webpack_exports__, __nested_webpack_require_7160__) {\n            \"use strict\";\n            // ESM COMPAT FLAG\n            __nested_webpack_require_7160__.r(__nested_webpack_exports__);\n            // EXPORTS\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"ClientHintsMetaTag\", function() {\n                return /* reexport */ clienthintsmetatag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Cloudinary\", function() {\n                return /* reexport */ cloudinary;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Condition\", function() {\n                return /* reexport */ condition;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Configuration\", function() {\n                return /* reexport */ src_configuration;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"crc32\", function() {\n                return /* reexport */ src_crc32;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Expression\", function() {\n                return /* reexport */ expression;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"FetchLayer\", function() {\n                return /* reexport */ fetchlayer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"HtmlTag\", function() {\n                return /* reexport */ htmltag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"ImageTag\", function() {\n                return /* reexport */ imagetag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Layer\", function() {\n                return /* reexport */ layer_layer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"PictureTag\", function() {\n                return /* reexport */ picturetag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"SubtitlesLayer\", function() {\n                return /* reexport */ subtitleslayer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"TextLayer\", function() {\n                return /* reexport */ textlayer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Transformation\", function() {\n                return /* reexport */ src_transformation;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"utf8_encode\", function() {\n                return /* reexport */ src_utf8_encode;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Util\", function() {\n                return /* reexport */ lodash_namespaceObject;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"VideoTag\", function() {\n                return /* reexport */ videotag;\n            });\n            // NAMESPACE OBJECT: ./src/constants.js\n            var constants_namespaceObject = {};\n            __nested_webpack_require_7160__.r(constants_namespaceObject);\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"VERSION\", function() {\n                return VERSION;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"CF_SHARED_CDN\", function() {\n                return CF_SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"OLD_AKAMAI_SHARED_CDN\", function() {\n                return OLD_AKAMAI_SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"AKAMAI_SHARED_CDN\", function() {\n                return AKAMAI_SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"SHARED_CDN\", function() {\n                return SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_TIMEOUT_MS\", function() {\n                return DEFAULT_TIMEOUT_MS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_POSTER_OPTIONS\", function() {\n                return DEFAULT_POSTER_OPTIONS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_VIDEO_SOURCE_TYPES\", function() {\n                return DEFAULT_VIDEO_SOURCE_TYPES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"SEO_TYPES\", function() {\n                return SEO_TYPES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_IMAGE_PARAMS\", function() {\n                return DEFAULT_IMAGE_PARAMS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_VIDEO_PARAMS\", function() {\n                return DEFAULT_VIDEO_PARAMS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_VIDEO_SOURCES\", function() {\n                return DEFAULT_VIDEO_SOURCES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_EXTERNAL_LIBRARIES\", function() {\n                return DEFAULT_EXTERNAL_LIBRARIES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"PLACEHOLDER_IMAGE_MODES\", function() {\n                return PLACEHOLDER_IMAGE_MODES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"ACCESSIBILITY_MODES\", function() {\n                return ACCESSIBILITY_MODES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"URL_KEYS\", function() {\n                return URL_KEYS;\n            });\n            // NAMESPACE OBJECT: ./src/util/lodash.js\n            var lodash_namespaceObject = {};\n            __nested_webpack_require_7160__.r(lodash_namespaceObject);\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getSDKAnalyticsSignature\", function() {\n                return getSDKAnalyticsSignature;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getAnalyticsOptions\", function() {\n                return getAnalyticsOptions;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"assign\", function() {\n                return assign_root_assign_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"cloneDeep\", function() {\n                return cloneDeep_root_cloneDeep_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"compact\", function() {\n                return compact_root_compact_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"difference\", function() {\n                return difference_root_difference_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"functions\", function() {\n                return functions_root_functions_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"identity\", function() {\n                return identity_root_identity_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"includes\", function() {\n                return includes_root_includes_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isArray\", function() {\n                return isArray_root_isArray_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isPlainObject\", function() {\n                return isPlainObject_root_isPlainObject_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isString\", function() {\n                return isString_root_isString_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"merge\", function() {\n                return merge_root_merge_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"contains\", function() {\n                return includes_root_includes_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isIntersectionObserverSupported\", function() {\n                return isIntersectionObserverSupported;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isNativeLazyLoadSupported\", function() {\n                return isNativeLazyLoadSupported;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"detectIntersection\", function() {\n                return detectIntersection;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"omit\", function() {\n                return omit;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"allStrings\", function() {\n                return baseutil_allStrings;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"without\", function() {\n                return without;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isNumberLike\", function() {\n                return isNumberLike;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"smartEscape\", function() {\n                return smartEscape;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"defaults\", function() {\n                return defaults;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"objectProto\", function() {\n                return objectProto;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"objToString\", function() {\n                return objToString;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isObject\", function() {\n                return isObject;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"funcTag\", function() {\n                return funcTag;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"reWords\", function() {\n                return reWords;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"camelCase\", function() {\n                return camelCase;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"snakeCase\", function() {\n                return snakeCase;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"convertKeys\", function() {\n                return convertKeys;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"withCamelCaseKeys\", function() {\n                return withCamelCaseKeys;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"withSnakeCaseKeys\", function() {\n                return withSnakeCaseKeys;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"base64Encode\", function() {\n                return base64Encode;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"base64EncodeURL\", function() {\n                return base64EncodeURL;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"extractUrlParams\", function() {\n                return extractUrlParams;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"patchFetchFormat\", function() {\n                return patchFetchFormat;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"optionConsume\", function() {\n                return optionConsume;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isEmpty\", function() {\n                return isEmpty;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isAndroid\", function() {\n                return isAndroid;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isEdge\", function() {\n                return isEdge;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isChrome\", function() {\n                return isChrome;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isSafari\", function() {\n                return isSafari;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isElement\", function() {\n                return isElement_root_isElement_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isFunction\", function() {\n                return isFunction_root_isFunction_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"trim\", function() {\n                return trim_root_trim_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getData\", function() {\n                return lodash_getData;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"setData\", function() {\n                return lodash_setData;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getAttribute\", function() {\n                return lodash_getAttribute;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"setAttribute\", function() {\n                return lodash_setAttribute;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"removeAttribute\", function() {\n                return lodash_removeAttribute;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"setAttributes\", function() {\n                return setAttributes;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"hasClass\", function() {\n                return lodash_hasClass;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"addClass\", function() {\n                return lodash_addClass;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getStyles\", function() {\n                return getStyles;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"cssExpand\", function() {\n                return cssExpand;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"domStyle\", function() {\n                return domStyle;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"curCSS\", function() {\n                return curCSS;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"cssValue\", function() {\n                return cssValue;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"augmentWidthOrHeight\", function() {\n                return augmentWidthOrHeight;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getWidthOrHeight\", function() {\n                return getWidthOrHeight;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"width\", function() {\n                return lodash_width;\n            });\n            // CONCATENATED MODULE: ./src/utf8_encode.js\n            /**\n * UTF8 encoder\n * @private\n */ var utf8_encode;\n            /* harmony default export */ var src_utf8_encode = utf8_encode = function utf8_encode(argString) {\n                var c1, enc, end, n, start, string, stringl, utftext;\n                // http://kevin.vanzonneveld.net\n                // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)\n                // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n                // +   improved by: sowberry\n                // +    tweaked by: Jack\n                // +   bugfixed by: Onno Marsman\n                // +   improved by: Yves Sucaet\n                // +   bugfixed by: Onno Marsman\n                // +   bugfixed by: Ulrich\n                // +   bugfixed by: Rafal Kukawski\n                // +   improved by: kirilloid\n                // *     example 1: utf8_encode('Kevin van Zonneveld');\n                // *     returns 1: 'Kevin van Zonneveld'\n                if (argString === null || typeof argString === \"undefined\") {\n                    return \"\";\n                }\n                string = argString + \"\";\n                // .replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n                utftext = \"\";\n                start = void 0;\n                end = void 0;\n                stringl = 0;\n                start = end = 0;\n                stringl = string.length;\n                n = 0;\n                while(n < stringl){\n                    c1 = string.charCodeAt(n);\n                    enc = null;\n                    if (c1 < 128) {\n                        end++;\n                    } else if (c1 > 127 && c1 < 2048) {\n                        enc = String.fromCharCode(c1 >> 6 | 192, c1 & 63 | 128);\n                    } else {\n                        enc = String.fromCharCode(c1 >> 12 | 224, c1 >> 6 & 63 | 128, c1 & 63 | 128);\n                    }\n                    if (enc !== null) {\n                        if (end > start) {\n                            utftext += string.slice(start, end);\n                        }\n                        utftext += enc;\n                        start = end = n + 1;\n                    }\n                    n++;\n                }\n                if (end > start) {\n                    utftext += string.slice(start, stringl);\n                }\n                return utftext;\n            };\n            // CONCATENATED MODULE: ./src/crc32.js\n            /**\n * CRC32 calculator\n * Depends on 'utf8_encode'\n * @private\n * @param {string} str - The string to calculate the CRC32 for.\n * @return {number}\n */ function crc32(str) {\n                var crc, i, iTop, table, x, y;\n                // http://kevin.vanzonneveld.net\n                // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)\n                // +   improved by: T0bsn\n                // +   improved by: http://stackoverflow.com/questions/2647935/javascript-crc32-function-and-php-crc32-not-matching\n                // -    depends on: utf8_encode\n                // *     example 1: crc32('Kevin van Zonneveld');\n                // *     returns 1: 1249991249\n                str = src_utf8_encode(str);\n                table = \"00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D\";\n                crc = 0;\n                x = 0;\n                y = 0;\n                crc = crc ^ -1;\n                i = 0;\n                iTop = str.length;\n                while(i < iTop){\n                    y = (crc ^ str.charCodeAt(i)) & 0xFF;\n                    x = \"0x\" + table.substr(y * 9, 8);\n                    crc = crc >>> 8 ^ x;\n                    i++;\n                }\n                crc = crc ^ -1;\n                //convert to unsigned 32-bit int if needed\n                if (crc < 0) {\n                    crc += 4294967296;\n                }\n                return crc;\n            }\n            /* harmony default export */ var src_crc32 = crc32;\n            // CONCATENATED MODULE: ./src/sdkAnalytics/stringPad.js\n            function stringPad(value, targetLength, padString) {\n                targetLength = targetLength >> 0; //truncate if number or convert non-number to 0;\n                padString = String(typeof padString !== \"undefined\" ? padString : \" \");\n                if (value.length > targetLength) {\n                    return String(value);\n                } else {\n                    targetLength = targetLength - value.length;\n                    if (targetLength > padString.length) {\n                        padString += repeatStringNumTimes(padString, targetLength / padString.length);\n                    }\n                    return padString.slice(0, targetLength) + String(value);\n                }\n            }\n            function repeatStringNumTimes(string, times) {\n                var repeatedString = \"\";\n                while(times > 0){\n                    repeatedString += string;\n                    times--;\n                }\n                return repeatedString;\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/base64Map.js\n            function _toConsumableArray(r) {\n                return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n            }\n            function _nonIterableSpread() {\n                throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function _unsupportedIterableToArray(r, a) {\n                if (r) {\n                    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n                    var t = ({}).toString.call(r).slice(8, -1);\n                    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n                }\n            }\n            function _iterableToArray(r) {\n                if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n            }\n            function _arrayWithoutHoles(r) {\n                if (Array.isArray(r)) return _arrayLikeToArray(r);\n            }\n            function _arrayLikeToArray(r, a) {\n                (null == a || a > r.length) && (a = r.length);\n                for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];\n                return n;\n            }\n            var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n            var base64Map_num = 0;\n            var map = {};\n            _toConsumableArray(chars).forEach(function(_char) {\n                var key = base64Map_num.toString(2);\n                key = stringPad(key, 6, \"0\");\n                map[key] = _char;\n                base64Map_num++;\n            });\n            /**\n * Map of six-bit binary codes to Base64 characters\n */ /* harmony default export */ var base64Map = map;\n            // CONCATENATED MODULE: ./src/sdkAnalytics/reverseVersion.js\n            /**\n * @description A semVer like string, x.y.z or x.y is allowed\n *              Reverses the version positions, x.y.z turns to z.y.x\n *              Pads each segment with '0' so they have length of 2\n *              Example: 1.2.3 -> 03.02.01\n * @param {string} semVer Input can be either x.y.z or x.y\n * @return {string} in the form of zz.yy.xx (\n */ function reverseVersion(semVer) {\n                if (semVer.split(\".\").length < 2) {\n                    throw new Error(\"invalid semVer, must have at least two segments\");\n                }\n                // Split by '.', reverse, create new array with padded values and concat it together\n                return semVer.split(\".\").reverse().map(function(segment) {\n                    return stringPad(segment, 2, \"0\");\n                }).join(\".\");\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/encodeVersion.js\n            /**\n * @description Encodes a semVer-like version string\n * @param {string} semVer Input can be either x.y.z or x.y\n * @return {string} A string built from 3 characters of the base64 table that encode the semVer\n */ function encodeVersion(semVer) {\n                var strResult = \"\";\n                // support x.y or x.y.z by using 'parts' as a variable\n                var parts = semVer.split(\".\").length;\n                var paddedStringLength = parts * 6; // we pad to either 12 or 18 characters\n                // reverse (but don't mirror) the version. 1.5.15 -> 15.5.1\n                // Pad to two spaces, 15.5.1 -> 15.05.01\n                var paddedReversedSemver = reverseVersion(semVer);\n                // turn 15.05.01 to a string '150501' then to a number 150501\n                var num = parseInt(paddedReversedSemver.split(\".\").join(\"\"));\n                // Represent as binary, add left padding to 12 or 18 characters.\n                // 150,501 -> 100100101111100101\n                var paddedBinary = num.toString(2);\n                paddedBinary = stringPad(paddedBinary, paddedStringLength, \"0\");\n                // Stop in case an invalid version number was provided\n                // paddedBinary must be built from sections of 6 bits\n                if (paddedBinary.length % 6 !== 0) {\n                    throw \"Version must be smaller than 43.21.26)\";\n                }\n                // turn every 6 bits into a character using the base64Map\n                paddedBinary.match(/.{1,6}/g).forEach(function(bitString) {\n                    // console.log(bitString);\n                    strResult += base64Map[bitString];\n                });\n                return strResult;\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/getSDKAnalyticsSignature.js\n            /**\n * @description Gets the SDK signature by encoding the SDK version and tech version\n * @param {{\n *    [techVersion]:string,\n *    [sdkSemver]: string,\n *    [sdkCode]: string,\n *    [feature]: string\n * }} analyticsOptions\n * @return {string} sdkAnalyticsSignature\n */ function getSDKAnalyticsSignature() {\n                var analyticsOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                try {\n                    var twoPartVersion = removePatchFromSemver(analyticsOptions.techVersion);\n                    var encodedSDKVersion = encodeVersion(analyticsOptions.sdkSemver);\n                    var encodedTechVersion = encodeVersion(twoPartVersion);\n                    var featureCode = analyticsOptions.feature;\n                    var SDKCode = analyticsOptions.sdkCode;\n                    var algoVersion = \"A\"; // The algo version is determined here, it should not be an argument\n                    return \"\".concat(algoVersion).concat(SDKCode).concat(encodedSDKVersion).concat(encodedTechVersion).concat(featureCode);\n                } catch (e) {\n                    // Either SDK or Node versions were unparsable\n                    return \"E\";\n                }\n            }\n            /**\n * @description Removes patch version from the semver if it exists\n *              Turns x.y.z OR x.y into x.y\n * @param {'x.y.z' || 'x.y' || string} semVerStr\n */ function removePatchFromSemver(semVerStr) {\n                var parts = semVerStr.split(\".\");\n                return \"\".concat(parts[0], \".\").concat(parts[1]);\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/getAnalyticsOptions.js\n            /**\n * @description Gets the analyticsOptions from options- should include sdkSemver, techVersion, sdkCode, and feature\n * @param options\n * @returns {{sdkSemver: (string), sdkCode, feature: string, techVersion: (string)} || {}}\n */ function getAnalyticsOptions(options) {\n                var analyticsOptions = {\n                    sdkSemver: options.sdkSemver,\n                    techVersion: options.techVersion,\n                    sdkCode: options.sdkCode,\n                    feature: \"0\"\n                };\n                if (options.urlAnalytics) {\n                    if (options.accessibility) {\n                        analyticsOptions.feature = \"D\";\n                    }\n                    if (options.loading === \"lazy\") {\n                        analyticsOptions.feature = \"C\";\n                    }\n                    if (options.responsive) {\n                        analyticsOptions.feature = \"A\";\n                    }\n                    if (options.placeholder) {\n                        analyticsOptions.feature = \"B\";\n                    }\n                    return analyticsOptions;\n                } else {\n                    return {};\n                }\n            }\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/assign\",\"commonjs2\":\"lodash/assign\",\"amd\":\"lodash/assign\",\"root\":[\"_\",\"assign\"]}\n            var assign_root_assign_ = __nested_webpack_require_7160__(\"lodash/assign\");\n            var assign_root_assign_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(assign_root_assign_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/cloneDeep\",\"commonjs2\":\"lodash/cloneDeep\",\"amd\":\"lodash/cloneDeep\",\"root\":[\"_\",\"cloneDeep\"]}\n            var cloneDeep_root_cloneDeep_ = __nested_webpack_require_7160__(\"lodash/cloneDeep\");\n            var cloneDeep_root_cloneDeep_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(cloneDeep_root_cloneDeep_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/compact\",\"commonjs2\":\"lodash/compact\",\"amd\":\"lodash/compact\",\"root\":[\"_\",\"compact\"]}\n            var compact_root_compact_ = __nested_webpack_require_7160__(\"lodash/compact\");\n            var compact_root_compact_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(compact_root_compact_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/difference\",\"commonjs2\":\"lodash/difference\",\"amd\":\"lodash/difference\",\"root\":[\"_\",\"difference\"]}\n            var difference_root_difference_ = __nested_webpack_require_7160__(\"lodash/difference\");\n            var difference_root_difference_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(difference_root_difference_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/functions\",\"commonjs2\":\"lodash/functions\",\"amd\":\"lodash/functions\",\"root\":[\"_\",\"functions\"]}\n            var functions_root_functions_ = __nested_webpack_require_7160__(\"lodash/functions\");\n            var functions_root_functions_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(functions_root_functions_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/identity\",\"commonjs2\":\"lodash/identity\",\"amd\":\"lodash/identity\",\"root\":[\"_\",\"identity\"]}\n            var identity_root_identity_ = __nested_webpack_require_7160__(\"lodash/identity\");\n            var identity_root_identity_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(identity_root_identity_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/includes\",\"commonjs2\":\"lodash/includes\",\"amd\":\"lodash/includes\",\"root\":[\"_\",\"includes\"]}\n            var includes_root_includes_ = __nested_webpack_require_7160__(\"lodash/includes\");\n            var includes_root_includes_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(includes_root_includes_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isArray\",\"commonjs2\":\"lodash/isArray\",\"amd\":\"lodash/isArray\",\"root\":[\"_\",\"isArray\"]}\n            var isArray_root_isArray_ = __nested_webpack_require_7160__(\"lodash/isArray\");\n            var isArray_root_isArray_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isArray_root_isArray_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isPlainObject\",\"commonjs2\":\"lodash/isPlainObject\",\"amd\":\"lodash/isPlainObject\",\"root\":[\"_\",\"isPlainObject\"]}\n            var isPlainObject_root_isPlainObject_ = __nested_webpack_require_7160__(\"lodash/isPlainObject\");\n            var isPlainObject_root_isPlainObject_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isPlainObject_root_isPlainObject_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isString\",\"commonjs2\":\"lodash/isString\",\"amd\":\"lodash/isString\",\"root\":[\"_\",\"isString\"]}\n            var isString_root_isString_ = __nested_webpack_require_7160__(\"lodash/isString\");\n            var isString_root_isString_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isString_root_isString_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/merge\",\"commonjs2\":\"lodash/merge\",\"amd\":\"lodash/merge\",\"root\":[\"_\",\"merge\"]}\n            var merge_root_merge_ = __nested_webpack_require_7160__(\"lodash/merge\");\n            var merge_root_merge_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(merge_root_merge_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isElement\",\"commonjs2\":\"lodash/isElement\",\"amd\":\"lodash/isElement\",\"root\":[\"_\",\"isElement\"]}\n            var isElement_root_isElement_ = __nested_webpack_require_7160__(\"lodash/isElement\");\n            var isElement_root_isElement_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isElement_root_isElement_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isFunction\",\"commonjs2\":\"lodash/isFunction\",\"amd\":\"lodash/isFunction\",\"root\":[\"_\",\"isFunction\"]}\n            var isFunction_root_isFunction_ = __nested_webpack_require_7160__(\"lodash/isFunction\");\n            var isFunction_root_isFunction_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isFunction_root_isFunction_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/trim\",\"commonjs2\":\"lodash/trim\",\"amd\":\"lodash/trim\",\"root\":[\"_\",\"trim\"]}\n            var trim_root_trim_ = __nested_webpack_require_7160__(\"lodash/trim\");\n            var trim_root_trim_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(trim_root_trim_);\n            // CONCATENATED MODULE: ./src/util/lazyLoad.js\n            function _typeof(o) {\n                \"@babel/helpers - typeof\";\n                return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, _typeof(o);\n            }\n            /*\n * Includes utility methods for lazy loading media\n */ /**\n * Check if IntersectionObserver is supported\n * @return {boolean} true if window.IntersectionObserver is defined\n */ function isIntersectionObserverSupported() {\n                // Check that 'IntersectionObserver' property is defined on window\n                return  false && 0;\n            }\n            /**\n * Check if native lazy loading is supported\n * @return {boolean} true if 'loading' property is defined for HTMLImageElement\n */ function isNativeLazyLoadSupported() {\n                return (typeof HTMLImageElement === \"undefined\" ? \"undefined\" : _typeof(HTMLImageElement)) === \"object\" && HTMLImageElement.prototype.loading;\n            }\n            /**\n * Calls onIntersect() when intersection is detected, or when\n * no native lazy loading or when IntersectionObserver isn't supported.\n * @param {Element} el - the element to observe\n * @param {function} onIntersect - called when the given element is in view\n */ function detectIntersection(el, onIntersect) {\n                try {\n                    if (isNativeLazyLoadSupported() || !isIntersectionObserverSupported()) {\n                        // Return if there's no need or possibility to detect intersection\n                        onIntersect();\n                        return;\n                    }\n                    // Detect intersection with given element using IntersectionObserver\n                    var observer = new IntersectionObserver(function(entries) {\n                        entries.forEach(function(entry) {\n                            if (entry.isIntersecting) {\n                                onIntersect();\n                                observer.unobserve(entry.target);\n                            }\n                        });\n                    }, {\n                        threshold: [\n                            0,\n                            0.01\n                        ]\n                    });\n                    observer.observe(el);\n                } catch (e) {\n                    onIntersect();\n                }\n            }\n            // CONCATENATED MODULE: ./src/constants.js\n            var VERSION = \"2.5.0\";\n            var CF_SHARED_CDN = \"d3jpl91pxevbkh.cloudfront.net\";\n            var OLD_AKAMAI_SHARED_CDN = \"cloudinary-a.akamaihd.net\";\n            var AKAMAI_SHARED_CDN = \"res.cloudinary.com\";\n            var SHARED_CDN = AKAMAI_SHARED_CDN;\n            var DEFAULT_TIMEOUT_MS = 10000;\n            var DEFAULT_POSTER_OPTIONS = {\n                format: \"jpg\",\n                resource_type: \"video\"\n            };\n            var DEFAULT_VIDEO_SOURCE_TYPES = [\n                \"webm\",\n                \"mp4\",\n                \"ogv\"\n            ];\n            var SEO_TYPES = {\n                \"image/upload\": \"images\",\n                \"image/private\": \"private_images\",\n                \"image/authenticated\": \"authenticated_images\",\n                \"raw/upload\": \"files\",\n                \"video/upload\": \"videos\"\n            };\n            /**\n* @const {Object} Cloudinary.DEFAULT_IMAGE_PARAMS\n* Defaults values for image parameters.\n*\n* (Previously defined using option_consume() )\n */ var DEFAULT_IMAGE_PARAMS = {\n                resource_type: \"image\",\n                transformation: [],\n                type: \"upload\"\n            };\n            /**\n* Defaults values for video parameters.\n* @const {Object} Cloudinary.DEFAULT_VIDEO_PARAMS\n* (Previously defined using option_consume() )\n */ var DEFAULT_VIDEO_PARAMS = {\n                fallback_content: \"\",\n                resource_type: \"video\",\n                source_transformation: {},\n                source_types: DEFAULT_VIDEO_SOURCE_TYPES,\n                transformation: [],\n                type: \"upload\"\n            };\n            /**\n * Recommended sources for video tag\n * @const {Object} Cloudinary.DEFAULT_VIDEO_SOURCES\n */ var DEFAULT_VIDEO_SOURCES = [\n                {\n                    type: \"mp4\",\n                    codecs: \"hev1\",\n                    transformations: {\n                        video_codec: \"h265\"\n                    }\n                },\n                {\n                    type: \"webm\",\n                    codecs: \"vp9\",\n                    transformations: {\n                        video_codec: \"vp9\"\n                    }\n                },\n                {\n                    type: \"mp4\",\n                    transformations: {\n                        video_codec: \"auto\"\n                    }\n                },\n                {\n                    type: \"webm\",\n                    transformations: {\n                        video_codec: \"auto\"\n                    }\n                }\n            ];\n            var DEFAULT_EXTERNAL_LIBRARIES = {\n                seeThru: \"https://unpkg.com/seethru@4/dist/seeThru.min.js\"\n            };\n            /**\n * Predefined placeholder transformations\n * @const {Object} Cloudinary.PLACEHOLDER_IMAGE_MODES\n */ var PLACEHOLDER_IMAGE_MODES = {\n                \"blur\": [\n                    {\n                        effect: \"blur:2000\",\n                        quality: 1,\n                        fetch_format: \"auto\"\n                    }\n                ],\n                // Default\n                \"pixelate\": [\n                    {\n                        effect: \"pixelate\",\n                        quality: 1,\n                        fetch_format: \"auto\"\n                    }\n                ],\n                // Generates a pixel size image which color is the predominant color of the original image.\n                \"predominant-color-pixel\": [\n                    {\n                        width: \"iw_div_2\",\n                        aspect_ratio: 1,\n                        crop: \"pad\",\n                        background: \"auto\"\n                    },\n                    {\n                        crop: \"crop\",\n                        width: 1,\n                        height: 1,\n                        gravity: \"north_east\"\n                    },\n                    {\n                        fetch_format: \"auto\",\n                        quality: \"auto\"\n                    }\n                ],\n                // Generates an image which color is the predominant color of the original image.\n                \"predominant-color\": [\n                    {\n                        variables: [\n                            [\n                                \"$currWidth\",\n                                \"w\"\n                            ],\n                            [\n                                \"$currHeight\",\n                                \"h\"\n                            ]\n                        ]\n                    },\n                    {\n                        width: \"iw_div_2\",\n                        aspect_ratio: 1,\n                        crop: \"pad\",\n                        background: \"auto\"\n                    },\n                    {\n                        crop: \"crop\",\n                        width: 10,\n                        height: 10,\n                        gravity: \"north_east\"\n                    },\n                    {\n                        width: \"$currWidth\",\n                        height: \"$currHeight\",\n                        crop: \"fill\"\n                    },\n                    {\n                        fetch_format: \"auto\",\n                        quality: \"auto\"\n                    }\n                ],\n                \"vectorize\": [\n                    {\n                        effect: \"vectorize:3:0.1\",\n                        fetch_format: \"svg\"\n                    }\n                ]\n            };\n            /**\n * Predefined accessibility transformations\n * @const {Object} Cloudinary.ACCESSIBILITY_MODES\n */ var ACCESSIBILITY_MODES = {\n                darkmode: \"tint:75:black\",\n                brightmode: \"tint:50:white\",\n                monochrome: \"grayscale\",\n                colorblind: \"assist_colorblind\"\n            };\n            /**\n * A list of keys used by the url() function.\n * @private\n */ var URL_KEYS = [\n                \"accessibility\",\n                \"api_secret\",\n                \"auth_token\",\n                \"cdn_subdomain\",\n                \"cloud_name\",\n                \"cname\",\n                \"format\",\n                \"placeholder\",\n                \"private_cdn\",\n                \"resource_type\",\n                \"secure\",\n                \"secure_cdn_subdomain\",\n                \"secure_distribution\",\n                \"shorten\",\n                \"sign_url\",\n                \"signature\",\n                \"ssl_detected\",\n                \"type\",\n                \"url_suffix\",\n                \"use_root_path\",\n                \"version\"\n            ];\n            /**\n * The resource storage type\n * @typedef type\n * @enum {string}\n * @property  {string} 'upload' A resource uploaded directly to Cloudinary\n * @property  {string} 'fetch' A resource fetched by Cloudinary from a 3rd party storage\n * @property  {string} 'private'\n * @property  {string} 'authenticated'\n * @property  {string} 'sprite'\n * @property  {string} 'facebook'\n * @property  {string} 'twitter'\n * @property  {string} 'youtube'\n * @property  {string} 'vimeo'\n *\n */ /**\n * The resource type\n * @typedef resourceType\n * @enum {string}\n * @property {string} 'image' An image file\n * @property {string} 'video' A video file\n * @property {string} 'raw'   A raw file\n */ // CONCATENATED MODULE: ./src/util/baseutil.js\n            function baseutil_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return baseutil_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, baseutil_typeof(o);\n            }\n            /*\n * Includes common utility methods and shims\n */ function omit(obj, keys) {\n                obj = obj || {};\n                var srcKeys = Object.keys(obj).filter(function(key) {\n                    return !includes_root_includes_default()(keys, key);\n                });\n                var filtered = {};\n                srcKeys.forEach(function(key) {\n                    return filtered[key] = obj[key];\n                });\n                return filtered;\n            }\n            /**\n * Return true if all items in list are strings\n * @function Util.allString\n * @param {Array} list - an array of items\n */ var baseutil_allStrings = function allStrings(list) {\n                return list.length && list.every(isString_root_isString_default.a);\n            };\n            /**\n* Creates a new array without the given item.\n* @function Util.without\n* @param {Array} array - original array\n* @param {*} item - the item to exclude from the new array\n* @return {Array} a new array made of the original array's items except for `item`\n */ var without = function without(array, item) {\n                return array.filter(function(v) {\n                    return v !== item;\n                });\n            };\n            /**\n* Return true is value is a number or a string representation of a number.\n* @function Util.isNumberLike\n* @param {*} value\n* @returns {boolean} true if value is a number\n* @example\n*    Util.isNumber(0) // true\n*    Util.isNumber(\"1.3\") // true\n*    Util.isNumber(\"\") // false\n*    Util.isNumber(undefined) // false\n */ var isNumberLike = function isNumberLike(value) {\n                return value != null && !isNaN(parseFloat(value));\n            };\n            /**\n * Escape all characters matching unsafe in the given string\n * @function Util.smartEscape\n * @param {string} string - source string to escape\n * @param {RegExp} unsafe - characters that must be escaped\n * @return {string} escaped string\n */ var smartEscape = function smartEscape(string) {\n                var unsafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /([^a-zA-Z0-9_.\\-\\/:]+)/g;\n                return string.replace(unsafe, function(match) {\n                    return match.split(\"\").map(function(c) {\n                        return \"%\" + c.charCodeAt(0).toString(16).toUpperCase();\n                    }).join(\"\");\n                });\n            };\n            /**\n * Assign values from sources if they are not defined in the destination.\n * Once a value is set it does not change\n * @function Util.defaults\n * @param {Object} destination - the object to assign defaults to\n * @param {...Object} source - the source object(s) to assign defaults from\n * @return {Object} destination after it was modified\n */ var defaults = function defaults(destination) {\n                for(var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    sources[_key - 1] = arguments[_key];\n                }\n                return sources.reduce(function(dest, source) {\n                    var key, value;\n                    for(key in source){\n                        value = source[key];\n                        if (dest[key] === void 0) {\n                            dest[key] = value;\n                        }\n                    }\n                    return dest;\n                }, destination);\n            };\n            /*********** lodash functions */ var objectProto = Object.prototype;\n            /**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */ var objToString = objectProto.toString;\n            /**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n#isObject({});\n * // => true\n *\n#isObject([1, 2, 3]);\n * // => true\n *\n#isObject(1);\n * // => false\n */ var isObject = function isObject(value) {\n                var type;\n                // Avoid a V8 JIT bug in Chrome 19-20.\n                // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n                type = baseutil_typeof(value);\n                return !!value && (type === \"object\" || type === \"function\");\n            };\n            var funcTag = \"[object Function]\";\n            /**\n* Checks if `value` is classified as a `Function` object.\n* @function Util.isFunction\n* @param {*} value The value to check.\n* @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n* @example\n*\n* function Foo(){};\n* isFunction(Foo);\n* // => true\n*\n* isFunction(/abc/);\n* // => false\n */ var isFunction = function isFunction(value) {\n                // The use of `Object#toString` avoids issues with the `typeof` operator\n                // in older versions of Chrome and Safari which return 'function' for regexes\n                // and Safari 8 which returns 'object' for typed array constructors.\n                return isObject(value) && objToString.call(value) === funcTag;\n            };\n            /*********** lodash functions */ /** Used to match words to create compound words. */ var reWords = function() {\n                var lower, upper;\n                upper = \"[A-Z]\";\n                lower = \"[a-z]+\";\n                return RegExp(upper + \"+(?=\" + upper + lower + \")|\" + upper + \"?\" + lower + \"|\" + upper + \"+|[0-9]+\", \"g\");\n            }();\n            /**\n* Convert string to camelCase\n* @function Util.camelCase\n* @param {string} source - the string to convert\n* @return {string} in camelCase format\n */ var camelCase = function camelCase(source) {\n                var words = source.match(reWords);\n                words = words.map(function(word) {\n                    return word.charAt(0).toLocaleUpperCase() + word.slice(1).toLocaleLowerCase();\n                });\n                words[0] = words[0].toLocaleLowerCase();\n                return words.join(\"\");\n            };\n            /**\n * Convert string to snake_case\n * @function Util.snakeCase\n * @param {string} source - the string to convert\n * @return {string} in snake_case format\n */ var snakeCase = function snakeCase(source) {\n                var words = source.match(reWords);\n                words = words.map(function(word) {\n                    return word.toLocaleLowerCase();\n                });\n                return words.join(\"_\");\n            };\n            /**\n * Creates a new object from source, with the keys transformed using the converter.\n * @param {object} source\n * @param {function|null} converter\n * @returns {object}\n */ var convertKeys = function convertKeys(source, converter) {\n                var result, value;\n                result = {};\n                for(var key in source){\n                    value = source[key];\n                    if (converter) {\n                        key = converter(key);\n                    }\n                    if (!isEmpty(key)) {\n                        result[key] = value;\n                    }\n                }\n                return result;\n            };\n            /**\n * Create a copy of the source object with all keys in camelCase\n * @function Util.withCamelCaseKeys\n * @param {Object} value - the object to copy\n * @return {Object} a new object\n */ var withCamelCaseKeys = function withCamelCaseKeys(source) {\n                return convertKeys(source, camelCase);\n            };\n            /**\n * Create a copy of the source object with all keys in snake_case\n * @function Util.withSnakeCaseKeys\n * @param {Object} value - the object to copy\n * @return {Object} a new object\n */ var withSnakeCaseKeys = function withSnakeCaseKeys(source) {\n                return convertKeys(source, snakeCase);\n            };\n            // Browser\n            // Node.js\n            var base64Encode = typeof btoa !== \"undefined\" && isFunction(btoa) ? btoa : typeof Buffer !== \"undefined\" && isFunction(Buffer) ? function(input) {\n                if (!(input instanceof Buffer)) {\n                    input = new Buffer.from(String(input), \"binary\");\n                }\n                return input.toString(\"base64\");\n            } : function(input) {\n                throw new Error(\"No base64 encoding function found\");\n            };\n            /**\n* Returns the Base64-decoded version of url.<br>\n* This method delegates to `btoa` if present. Otherwise it tries `Buffer`.\n* @function Util.base64EncodeURL\n* @param {string} url - the url to encode. the value is URIdecoded and then re-encoded before converting to base64 representation\n* @return {string} the base64 representation of the URL\n */ var base64EncodeURL = function base64EncodeURL(url) {\n                try {\n                    url = decodeURI(url);\n                } finally{\n                    url = encodeURI(url);\n                }\n                return base64Encode(url);\n            };\n            /**\n * Create a new object with only URL parameters\n * @param {object} options The source object\n * @return {Object} An object containing only URL parameters\n */ function extractUrlParams(options) {\n                return URL_KEYS.reduce(function(obj, key) {\n                    if (options[key] != null) {\n                        obj[key] = options[key];\n                    }\n                    return obj;\n                }, {});\n            }\n            /**\n * Handle the format parameter for fetch urls\n * @private\n * @param options url and transformation options. This argument may be changed by the function!\n */ function patchFetchFormat(options) {\n                if (options == null) {\n                    options = {};\n                }\n                if (options.type === \"fetch\") {\n                    if (options.fetch_format == null) {\n                        options.fetch_format = optionConsume(options, \"format\");\n                    }\n                }\n            }\n            /**\n * Deletes `option_name` from `options` and return the value if present.\n * If `options` doesn't contain `option_name` the default value is returned.\n * @param {Object} options a collection\n * @param {String} option_name the name (key) of the desired value\n * @param {*} [default_value] the value to return is option_name is missing\n */ function optionConsume(options, option_name, default_value) {\n                var result = options[option_name];\n                delete options[option_name];\n                if (result != null) {\n                    return result;\n                } else {\n                    return default_value;\n                }\n            }\n            /**\n * Returns true if value is empty:\n * <ul>\n *   <li>value is null or undefined</li>\n *   <li>value is an array or string of length 0</li>\n *   <li>value is an object with no keys</li>\n * </ul>\n * @function Util.isEmpty\n * @param value\n * @returns {boolean} true if value is empty\n */ function isEmpty(value) {\n                if (value == null) {\n                    return true;\n                }\n                if (typeof value.length == \"number\") {\n                    return value.length === 0;\n                }\n                if (typeof value.size == \"number\") {\n                    return value.size === 0;\n                }\n                if (baseutil_typeof(value) == \"object\") {\n                    for(var key in value){\n                        if (value.hasOwnProperty(key)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                return true;\n            }\n            // CONCATENATED MODULE: ./src/util/browser.js\n            /**\n * Based on video.js implementation:\n * https://github.com/videojs/video.js/blob/4238f5c1d88890547153e7e1de7bd0d1d8e0b236/src/js/utils/browser.js\n */ /**\n* Retrieve from the navigator the user agent property.\n* @returns user agent property.\n*/ function getUserAgent() {\n                return navigator && navigator.userAgent || \"\";\n            }\n            /**\n * Detect if current browser is any Android\n * @returns true if current browser is Android, false otherwise.\n */ function isAndroid() {\n                var userAgent = getUserAgent();\n                return /Android/i.test(userAgent);\n            }\n            /**\n * Detect if current browser is any Edge\n * @returns true if current browser is Edge, false otherwise.\n */ function isEdge() {\n                var userAgent = getUserAgent();\n                return /Edg/i.test(userAgent);\n            }\n            /**\n * Detect if current browser is chrome.\n * @returns true if current browser is Chrome, false otherwise.\n */ function isChrome() {\n                var userAgent = getUserAgent();\n                return !isEdge() && (/Chrome/i.test(userAgent) || /CriOS/i.test(userAgent));\n            }\n            /**\n * Detect if current browser is Safari.\n * @returns true if current browser is Safari, false otherwise.\n */ function isSafari() {\n                // User agents for other browsers might include \"Safari\" so we must exclude them.\n                // For example - this is the chrome user agent on windows 10:\n                // Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36\n                var userAgent = getUserAgent();\n                return /Safari/i.test(userAgent) && !isChrome() && !isAndroid() && !isEdge();\n            }\n            // CONCATENATED MODULE: ./src/util/lodash.js\n            var nodeContains;\n            /*\n * Includes utility methods and lodash / jQuery shims\n */ /**\n * Get data from the DOM element.\n *\n * This method will use jQuery's `data()` method if it is available, otherwise it will get the `data-` attribute\n * @param {Element} element - the element to get the data from\n * @param {string} name - the name of the data item\n * @returns the value associated with the `name`\n * @function Util.getData\n */ var lodash_getData = function getData(element, name) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.getAttribute):\n                        return element.getAttribute(\"data-\".concat(name));\n                    case !isFunction_root_isFunction_default()(element.getAttr):\n                        return element.getAttr(\"data-\".concat(name));\n                    case !isFunction_root_isFunction_default()(element.data):\n                        return element.data(name);\n                    case !(isFunction_root_isFunction_default()(typeof jQuery !== \"undefined\" && jQuery.fn && jQuery.fn.data) && isElement_root_isElement_default()(element)):\n                        return jQuery(element).data(name);\n                }\n            };\n            /**\n * Set data in the DOM element.\n *\n * This method will use jQuery's `data()` method if it is available, otherwise it will set the `data-` attribute\n * @function Util.setData\n * @param {Element} element - the element to set the data in\n * @param {string} name - the name of the data item\n * @param {*} value - the value to be set\n *\n */ var lodash_setData = function setData(element, name, value) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.setAttribute):\n                        return element.setAttribute(\"data-\".concat(name), value);\n                    case !isFunction_root_isFunction_default()(element.setAttr):\n                        return element.setAttr(\"data-\".concat(name), value);\n                    case !isFunction_root_isFunction_default()(element.data):\n                        return element.data(name, value);\n                    case !(isFunction_root_isFunction_default()(typeof jQuery !== \"undefined\" && jQuery.fn && jQuery.fn.data) && isElement_root_isElement_default()(element)):\n                        return jQuery(element).data(name, value);\n                }\n            };\n            /**\n * Get attribute from the DOM element.\n *\n * @function Util.getAttribute\n * @param {Element} element - the element to set the attribute for\n * @param {string} name - the name of the attribute\n * @returns {*} the value of the attribute\n *\n */ var lodash_getAttribute = function getAttribute(element, name) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.getAttribute):\n                        return element.getAttribute(name);\n                    case !isFunction_root_isFunction_default()(element.attr):\n                        return element.attr(name);\n                    case !isFunction_root_isFunction_default()(element.getAttr):\n                        return element.getAttr(name);\n                }\n            };\n            /**\n * Set attribute in the DOM element.\n *\n * @function Util.setAttribute\n * @param {Element} element - the element to set the attribute for\n * @param {string} name - the name of the attribute\n * @param {*} value - the value to be set\n */ var lodash_setAttribute = function setAttribute(element, name, value) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.setAttribute):\n                        return element.setAttribute(name, value);\n                    case !isFunction_root_isFunction_default()(element.attr):\n                        return element.attr(name, value);\n                    case !isFunction_root_isFunction_default()(element.setAttr):\n                        return element.setAttr(name, value);\n                }\n            };\n            /**\n * Remove an attribute in the DOM element.\n *\n * @function Util.removeAttribute\n * @param {Element} element - the element to set the attribute for\n * @param {string} name - the name of the attribute\n */ var lodash_removeAttribute = function removeAttribute(element, name) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.removeAttribute):\n                        return element.removeAttribute(name);\n                    default:\n                        return lodash_setAttribute(element, void 0);\n                }\n            };\n            /**\n * Set a group of attributes to the element\n * @function Util.setAttributes\n * @param {Element} element - the element to set the attributes for\n * @param {Object} attributes - a hash of attribute names and values\n */ var setAttributes = function setAttributes(element, attributes) {\n                var name, results, value;\n                results = [];\n                for(name in attributes){\n                    value = attributes[name];\n                    if (value != null) {\n                        results.push(lodash_setAttribute(element, name, value));\n                    } else {\n                        results.push(lodash_removeAttribute(element, name));\n                    }\n                }\n                return results;\n            };\n            /**\n * Checks if element has a css class\n * @function Util.hasClass\n * @param {Element} element - the element to check\n * @param {string} name - the class name\n @returns {boolean} true if the element has the class\n */ var lodash_hasClass = function hasClass(element, name) {\n                if (isElement_root_isElement_default()(element)) {\n                    return element.className.match(new RegExp(\"\\\\b\".concat(name, \"\\\\b\")));\n                }\n            };\n            /**\n * Add class to the element\n * @function Util.addClass\n * @param {Element} element - the element\n * @param {string} name - the class name to add\n */ var lodash_addClass = function addClass(element, name) {\n                if (!element.className.match(new RegExp(\"\\\\b\".concat(name, \"\\\\b\")))) {\n                    return element.className = trim_root_trim_default()(\"\".concat(element.className, \" \").concat(name));\n                }\n            };\n            // The following code is taken from jQuery\n            var getStyles = function getStyles(elem) {\n                // Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n                // IE throws on elements created in popups\n                // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n                if (elem.ownerDocument.defaultView.opener) {\n                    return elem.ownerDocument.defaultView.getComputedStyle(elem, null);\n                }\n                return window.getComputedStyle(elem, null);\n            };\n            var cssExpand = [\n                \"Top\",\n                \"Right\",\n                \"Bottom\",\n                \"Left\"\n            ];\n            nodeContains = function nodeContains(a, b) {\n                var adown, bup;\n                adown = a.nodeType === 9 ? a.documentElement : a;\n                bup = b && b.parentNode;\n                return a === bup || !!(bup && bup.nodeType === 1 && adown.contains(bup));\n            };\n            // Truncated version of jQuery.style(elem, name)\n            var domStyle = function domStyle(elem, name) {\n                if (!(!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style)) {\n                    return elem.style[name];\n                }\n            };\n            var curCSS = function curCSS(elem, name, computed) {\n                var maxWidth, minWidth, ret, rmargin, style, width;\n                rmargin = /^margin/;\n                width = void 0;\n                minWidth = void 0;\n                maxWidth = void 0;\n                ret = void 0;\n                style = elem.style;\n                computed = computed || getStyles(elem);\n                if (computed) {\n                    // Support: IE9\n                    // getPropertyValue is only needed for .css('filter') (#12537)\n                    ret = computed.getPropertyValue(name) || computed[name];\n                }\n                if (computed) {\n                    if (ret === \"\" && !nodeContains(elem.ownerDocument, elem)) {\n                        ret = domStyle(elem, name);\n                    }\n                    // Support: iOS < 6\n                    // A tribute to the \"awesome hack by Dean Edwards\"\n                    // iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n                    // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n                    if (rnumnonpx.test(ret) && rmargin.test(name)) {\n                        // Remember the original values\n                        width = style.width;\n                        minWidth = style.minWidth;\n                        maxWidth = style.maxWidth;\n                        // Put in the new values to get a computed value out\n                        style.minWidth = style.maxWidth = style.width = ret;\n                        ret = computed.width;\n                        // Revert the changed values\n                        style.width = width;\n                        style.minWidth = minWidth;\n                        style.maxWidth = maxWidth;\n                    }\n                }\n                // Support: IE\n                // IE returns zIndex value as an integer.\n                if (ret !== undefined) {\n                    return ret + \"\";\n                } else {\n                    return ret;\n                }\n            };\n            var cssValue = function cssValue(elem, name, convert, styles) {\n                var val;\n                val = curCSS(elem, name, styles);\n                if (convert) {\n                    return parseFloat(val);\n                } else {\n                    return val;\n                }\n            };\n            var augmentWidthOrHeight = function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {\n                var i, len, side, sides, val;\n                // If we already have the right measurement, avoid augmentation\n                // Otherwise initialize for horizontal or vertical properties\n                if (extra === (isBorderBox ? \"border\" : \"content\")) {\n                    return 0;\n                } else {\n                    sides = name === \"width\" ? [\n                        \"Right\",\n                        \"Left\"\n                    ] : [\n                        \"Top\",\n                        \"Bottom\"\n                    ];\n                    val = 0;\n                    for(i = 0, len = sides.length; i < len; i++){\n                        side = sides[i];\n                        if (extra === \"margin\") {\n                            // Both box models exclude margin, so add it if we want it\n                            val += cssValue(elem, extra + side, true, styles);\n                        }\n                        if (isBorderBox) {\n                            if (extra === \"content\") {\n                                // border-box includes padding, so remove it if we want content\n                                val -= cssValue(elem, \"padding\".concat(side), true, styles);\n                            }\n                            if (extra !== \"margin\") {\n                                // At this point, extra isn't border nor margin, so remove border\n                                val -= cssValue(elem, \"border\".concat(side, \"Width\"), true, styles);\n                            }\n                        } else {\n                            // At this point, extra isn't content, so add padding\n                            val += cssValue(elem, \"padding\".concat(side), true, styles);\n                            if (extra !== \"padding\") {\n                                // At this point, extra isn't content nor padding, so add border\n                                val += cssValue(elem, \"border\".concat(side, \"Width\"), true, styles);\n                            }\n                        }\n                    }\n                    return val;\n                }\n            };\n            var pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n            var rnumnonpx = new RegExp(\"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\");\n            var getWidthOrHeight = function getWidthOrHeight(elem, name, extra) {\n                var isBorderBox, styles, val, valueIsBorderBox;\n                // Start with offset property, which is equivalent to the border-box value\n                valueIsBorderBox = true;\n                val = name === \"width\" ? elem.offsetWidth : elem.offsetHeight;\n                styles = getStyles(elem);\n                isBorderBox = cssValue(elem, \"boxSizing\", false, styles) === \"border-box\";\n                // Some non-html elements return undefined for offsetWidth, so check for null/undefined\n                // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n                // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n                if (val <= 0 || val == null) {\n                    // Fall back to computed then uncomputed css if necessary\n                    val = curCSS(elem, name, styles);\n                    if (val < 0 || val == null) {\n                        val = elem.style[name];\n                    }\n                    if (rnumnonpx.test(val)) {\n                        // Computed unit is not pixels. Stop here and return.\n                        return val;\n                    }\n                    // Check for style in case a browser which returns unreliable values\n                    // for getComputedStyle silently falls back to the reliable elem.style\n                    //    valueIsBorderBox = isBorderBox and (support.boxSizingReliable() or val is elem.style[name])\n                    valueIsBorderBox = isBorderBox && val === elem.style[name];\n                    // Normalize \"\", auto, and prepare for extra\n                    val = parseFloat(val) || 0;\n                }\n                // Use the active box-sizing model to add/subtract irrelevant styles\n                return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? \"border\" : \"content\"), valueIsBorderBox, styles);\n            };\n            var lodash_width = function width(element) {\n                return getWidthOrHeight(element, \"width\", \"content\");\n            };\n            /**\n * @class Util\n */ /**\n * Returns true if item is a string\n * @function Util.isString\n * @param item\n * @returns {boolean} true if item is a string\n */ /**\n * Returns true if item is empty:\n * <ul>\n *   <li>item is null or undefined</li>\n *   <li>item is an array or string of length 0</li>\n *   <li>item is an object with no keys</li>\n * </ul>\n * @function Util.isEmpty\n * @param item\n * @returns {boolean} true if item is empty\n */ /**\n * Assign source properties to destination.\n * If the property is an object it is assigned as a whole, overriding the destination object.\n * @function Util.assign\n * @param {Object} destination - the object to assign to\n */ /**\n * Recursively assign source properties to destination\n * @function Util.merge\n * @param {Object} destination - the object to assign to\n * @param {...Object} [sources] The source objects.\n */ /**\n * Create a new copy of the given object, including all internal objects.\n * @function Util.cloneDeep\n * @param {Object} value - the object to clone\n * @return {Object} a new deep copy of the object\n */ /**\n * Creates a new array from the parameter with \"falsey\" values removed\n * @function Util.compact\n * @param {Array} array - the array to remove values from\n * @return {Array} a new array without falsey values\n */ /**\n * Check if a given item is included in the given array\n * @function Util.contains\n * @param {Array} array - the array to search in\n * @param {*} item - the item to search for\n * @return {boolean} true if the item is included in the array\n */ /**\n * Returns values in the given array that are not included in the other array\n * @function Util.difference\n * @param {Array} arr - the array to select from\n * @param {Array} values - values to filter from arr\n * @return {Array} the filtered values\n */ /**\n * Returns a list of all the function names in obj\n * @function Util.functions\n * @param {Object} object - the object to inspect\n * @return {Array} a list of functions of object\n */ /**\n * Returns the provided value. This functions is used as a default predicate function.\n * @function Util.identity\n * @param {*} value\n * @return {*} the provided value\n */ /**\n * Remove leading or trailing spaces from text\n * @function Util.trim\n * @param {string} text\n * @return {string} the `text` without leading or trailing spaces\n */ // CONCATENATED MODULE: ./src/expression.js\n            function expression_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return expression_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, expression_typeof(o);\n            }\n            function _classCallCheck(a, n) {\n                if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n            function _defineProperties(e, r) {\n                for(var t = 0; t < r.length; t++){\n                    var o = r[t];\n                    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n                }\n            }\n            function _createClass(e, r, t) {\n                return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n                    writable: !1\n                }), e;\n            }\n            function _toPropertyKey(t) {\n                var i = _toPrimitive(t, \"string\");\n                return \"symbol\" == expression_typeof(i) ? i : i + \"\";\n            }\n            function _toPrimitive(t, r) {\n                if (\"object\" != expression_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != expression_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            /**\n * Represents a transformation expression.\n * @param {string} expressionStr - An expression in string format.\n * @class Expression\n * Normally this class is not instantiated directly\n */ var Expression = /*#__PURE__*/ function() {\n                function Expression(expressionStr) {\n                    _classCallCheck(this, Expression);\n                    /**\n     * @protected\n     * @inner Expression-expressions\n     */ this.expressions = [];\n                    if (expressionStr != null) {\n                        this.expressions.push(Expression.normalize(expressionStr));\n                    }\n                }\n                /**\n   * Convenience constructor method\n   * @function Expression.new\n   */ return _createClass(Expression, [\n                    {\n                        key: \"serialize\",\n                        value: /**\n     * Serialize the expression\n     * @return {string} the expression as a string\n     */ function serialize() {\n                            return Expression.normalize(this.expressions.join(\"_\"));\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            return this.serialize();\n                        }\n                    },\n                    {\n                        key: \"getParent\",\n                        value: function getParent() {\n                            return this.parent;\n                        }\n                    },\n                    {\n                        key: \"setParent\",\n                        value: function setParent(parent) {\n                            this.parent = parent;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"predicate\",\n                        value: function predicate(name, operator, value) {\n                            if (Expression.OPERATORS[operator] != null) {\n                                operator = Expression.OPERATORS[operator];\n                            }\n                            this.expressions.push(\"\".concat(name, \"_\").concat(operator, \"_\").concat(value));\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"and\",\n                        value: function and() {\n                            this.expressions.push(\"and\");\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"or\",\n                        value: function or() {\n                            this.expressions.push(\"or\");\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"then\",\n                        value: function then() {\n                            return this.getParent()[\"if\"](this.toString());\n                        }\n                    },\n                    {\n                        key: \"height\",\n                        value: function height(operator, value) {\n                            return this.predicate(\"h\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width(operator, value) {\n                            return this.predicate(\"w\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio(operator, value) {\n                            return this.predicate(\"ar\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"pageCount\",\n                        value: function pageCount(operator, value) {\n                            return this.predicate(\"pc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"faceCount\",\n                        value: function faceCount(operator, value) {\n                            return this.predicate(\"fc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value(_value) {\n                            this.expressions.push(_value);\n                            return this;\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(expressionStr) {\n                            return new this(expressionStr);\n                        }\n                    },\n                    {\n                        key: \"normalize\",\n                        value: function normalize(expression) {\n                            if (expression == null) {\n                                return expression;\n                            }\n                            expression = String(expression);\n                            var operators = \"\\\\|\\\\||>=|<=|&&|!=|>|=|<|/|-|\\\\+|\\\\*|\\\\^\";\n                            // operators\n                            var operatorsPattern = \"((\" + operators + \")(?=[ _]))\";\n                            var operatorsReplaceRE = new RegExp(operatorsPattern, \"g\");\n                            expression = expression.replace(operatorsReplaceRE, function(match) {\n                                return Expression.OPERATORS[match];\n                            });\n                            // predefined variables\n                            // The :${v} part is to prevent normalization of vars with a preceding colon (such as :duration),\n                            // It won't be found in PREDEFINED_VARS and so won't be normalized.\n                            // It is done like this because ie11 does not support regex lookbehind\n                            var predefinedVarsPattern = \"(\" + Object.keys(Expression.PREDEFINED_VARS).map(function(v) {\n                                return \":\".concat(v, \"|\").concat(v);\n                            }).join(\"|\") + \")\";\n                            var userVariablePattern = \"(\\\\$_*[^_ ]+)\";\n                            var variablesReplaceRE = new RegExp(\"\".concat(userVariablePattern, \"|\").concat(predefinedVarsPattern), \"g\");\n                            expression = expression.replace(variablesReplaceRE, function(match) {\n                                return Expression.PREDEFINED_VARS[match] || match;\n                            });\n                            return expression.replace(/[ _]+/g, \"_\");\n                        }\n                    },\n                    {\n                        key: \"variable\",\n                        value: function variable(name, value) {\n                            return new this(name).value(value);\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width() {\n                            return new this(\"width\");\n                        }\n                    },\n                    {\n                        key: \"height\",\n                        value: function height() {\n                            return new this(\"height\");\n                        }\n                    },\n                    {\n                        key: \"initialWidth\",\n                        value: function initialWidth() {\n                            return new this(\"initialWidth\");\n                        }\n                    },\n                    {\n                        key: \"initialHeight\",\n                        value: function initialHeight() {\n                            return new this(\"initialHeight\");\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio() {\n                            return new this(\"aspectRatio\");\n                        }\n                    },\n                    {\n                        key: \"initialAspectRatio\",\n                        value: function initialAspectRatio() {\n                            return new this(\"initialAspectRatio\");\n                        }\n                    },\n                    {\n                        key: \"pageCount\",\n                        value: function pageCount() {\n                            return new this(\"pageCount\");\n                        }\n                    },\n                    {\n                        key: \"faceCount\",\n                        value: function faceCount() {\n                            return new this(\"faceCount\");\n                        }\n                    },\n                    {\n                        key: \"currentPage\",\n                        value: function currentPage() {\n                            return new this(\"currentPage\");\n                        }\n                    },\n                    {\n                        key: \"tags\",\n                        value: function tags() {\n                            return new this(\"tags\");\n                        }\n                    },\n                    {\n                        key: \"pageX\",\n                        value: function pageX() {\n                            return new this(\"pageX\");\n                        }\n                    },\n                    {\n                        key: \"pageY\",\n                        value: function pageY() {\n                            return new this(\"pageY\");\n                        }\n                    }\n                ]);\n            }();\n            /**\n * @internal\n */ Expression.OPERATORS = {\n                \"=\": \"eq\",\n                \"!=\": \"ne\",\n                \"<\": \"lt\",\n                \">\": \"gt\",\n                \"<=\": \"lte\",\n                \">=\": \"gte\",\n                \"&&\": \"and\",\n                \"||\": \"or\",\n                \"*\": \"mul\",\n                \"/\": \"div\",\n                \"+\": \"add\",\n                \"-\": \"sub\",\n                \"^\": \"pow\"\n            };\n            /**\n * @internal\n */ Expression.PREDEFINED_VARS = {\n                \"aspect_ratio\": \"ar\",\n                \"aspectRatio\": \"ar\",\n                \"current_page\": \"cp\",\n                \"currentPage\": \"cp\",\n                \"duration\": \"du\",\n                \"face_count\": \"fc\",\n                \"faceCount\": \"fc\",\n                \"height\": \"h\",\n                \"initial_aspect_ratio\": \"iar\",\n                \"initial_duration\": \"idu\",\n                \"initial_height\": \"ih\",\n                \"initial_width\": \"iw\",\n                \"initialAspectRatio\": \"iar\",\n                \"initialDuration\": \"idu\",\n                \"initialHeight\": \"ih\",\n                \"initialWidth\": \"iw\",\n                \"page_count\": \"pc\",\n                \"page_x\": \"px\",\n                \"page_y\": \"py\",\n                \"pageCount\": \"pc\",\n                \"pageX\": \"px\",\n                \"pageY\": \"py\",\n                \"tags\": \"tags\",\n                \"width\": \"w\"\n            };\n            /**\n * @internal\n */ Expression.BOUNDRY = \"[ _]+\";\n            /* harmony default export */ var expression = Expression;\n            // CONCATENATED MODULE: ./src/condition.js\n            function condition_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return condition_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, condition_typeof(o);\n            }\n            function condition_classCallCheck(a, n) {\n                if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n            function condition_defineProperties(e, r) {\n                for(var t = 0; t < r.length; t++){\n                    var o = r[t];\n                    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, condition_toPropertyKey(o.key), o);\n                }\n            }\n            function condition_createClass(e, r, t) {\n                return r && condition_defineProperties(e.prototype, r), t && condition_defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n                    writable: !1\n                }), e;\n            }\n            function condition_toPropertyKey(t) {\n                var i = condition_toPrimitive(t, \"string\");\n                return \"symbol\" == condition_typeof(i) ? i : i + \"\";\n            }\n            function condition_toPrimitive(t, r) {\n                if (\"object\" != condition_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != condition_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function _callSuper(t, o, e) {\n                return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function _possibleConstructorReturn(t, e) {\n                if (e && (\"object\" == condition_typeof(e) || \"function\" == typeof e)) return e;\n                if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n                return _assertThisInitialized(t);\n            }\n            function _assertThisInitialized(e) {\n                if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                return e;\n            }\n            function _isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function _getPrototypeOf(t) {\n                return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {\n                    return t.__proto__ || Object.getPrototypeOf(t);\n                }, _getPrototypeOf(t);\n            }\n            function _inherits(t, e) {\n                if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n                t.prototype = Object.create(e && e.prototype, {\n                    constructor: {\n                        value: t,\n                        writable: !0,\n                        configurable: !0\n                    }\n                }), Object.defineProperty(t, \"prototype\", {\n                    writable: !1\n                }), e && _setPrototypeOf(t, e);\n            }\n            function _setPrototypeOf(t, e) {\n                return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {\n                    return t.__proto__ = e, t;\n                }, _setPrototypeOf(t, e);\n            }\n            /**\n * Represents a transformation condition.\n * @param {string} conditionStr - a condition in string format\n * @class Condition\n * @example\n * // normally this class is not instantiated directly\n * var tr = cloudinary.Transformation.new()\n *    .if().width( \">\", 1000).and().aspectRatio(\"<\", \"3:4\").then()\n *      .width(1000)\n *      .crop(\"scale\")\n *    .else()\n *      .width(500)\n *      .crop(\"scale\")\n *\n * var tr = cloudinary.Transformation.new()\n *    .if(\"w > 1000 and aspectRatio < 3:4\")\n *      .width(1000)\n *      .crop(\"scale\")\n *    .else()\n *      .width(500)\n *      .crop(\"scale\")\n *\n */ var Condition = /*#__PURE__*/ function(_Expression) {\n                function Condition(conditionStr) {\n                    condition_classCallCheck(this, Condition);\n                    return _callSuper(this, Condition, [\n                        conditionStr\n                    ]);\n                }\n                /**\n   * @function Condition#height\n   * @param {string} operator the comparison operator (e.g. \"<\", \"lt\")\n   * @param {string|number} value the right hand side value\n   * @return {Condition} this condition\n   */ _inherits(Condition, _Expression);\n                return condition_createClass(Condition, [\n                    {\n                        key: \"height\",\n                        value: function height(operator, value) {\n                            return this.predicate(\"h\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width(operator, value) {\n                            return this.predicate(\"w\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio(operator, value) {\n                            return this.predicate(\"ar\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"pageCount\",\n                        value: function pageCount(operator, value) {\n                            return this.predicate(\"pc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"faceCount\",\n                        value: function faceCount(operator, value) {\n                            return this.predicate(\"fc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"duration\",\n                        value: function duration(operator, value) {\n                            return this.predicate(\"du\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"initialDuration\",\n                        value: function initialDuration(operator, value) {\n                            return this.predicate(\"idu\", operator, value);\n                        }\n                    }\n                ]);\n            }(expression);\n            /* harmony default export */ var condition = Condition;\n            // CONCATENATED MODULE: ./src/configuration.js\n            function configuration_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return configuration_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, configuration_typeof(o);\n            }\n            function _slicedToArray(r, e) {\n                return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || configuration_unsupportedIterableToArray(r, e) || _nonIterableRest();\n            }\n            function _nonIterableRest() {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function configuration_unsupportedIterableToArray(r, a) {\n                if (r) {\n                    if (\"string\" == typeof r) return configuration_arrayLikeToArray(r, a);\n                    var t = ({}).toString.call(r).slice(8, -1);\n                    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? configuration_arrayLikeToArray(r, a) : void 0;\n                }\n            }\n            function configuration_arrayLikeToArray(r, a) {\n                (null == a || a > r.length) && (a = r.length);\n                for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];\n                return n;\n            }\n            function _iterableToArrayLimit(r, l) {\n                var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n                if (null != t) {\n                    var e, n, i, u, a = [], f = !0, o = !1;\n                    try {\n                        if (i = (t = t.call(r)).next, 0 === l) {\n                            if (Object(t) !== t) return;\n                            f = !1;\n                        } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n                    } catch (r) {\n                        o = !0, n = r;\n                    } finally{\n                        try {\n                            if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n                        } finally{\n                            if (o) throw n;\n                        }\n                    }\n                    return a;\n                }\n            }\n            function _arrayWithHoles(r) {\n                if (Array.isArray(r)) return r;\n            }\n            function configuration_classCallCheck(a, n) {\n                if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n            function configuration_defineProperties(e, r) {\n                for(var t = 0; t < r.length; t++){\n                    var o = r[t];\n                    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, configuration_toPropertyKey(o.key), o);\n                }\n            }\n            function configuration_createClass(e, r, t) {\n                return r && configuration_defineProperties(e.prototype, r), t && configuration_defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n                    writable: !1\n                }), e;\n            }\n            function configuration_toPropertyKey(t) {\n                var i = configuration_toPrimitive(t, \"string\");\n                return \"symbol\" == configuration_typeof(i) ? i : i + \"\";\n            }\n            function configuration_toPrimitive(t, r) {\n                if (\"object\" != configuration_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != configuration_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            /**\n * Class for defining account configuration options.\n * Depends on 'utils'\n */ /**\n * Class for defining account configuration options.\n * @constructor Configuration\n * @param {Object} options - The account configuration parameters to set.\n * @see <a href=\"https://cloudinary.com/documentation/solution_overview#configuration_parameters\"\n *  target=\"_new\">Available configuration options</a>\n */ var configuration_Configuration = /*#__PURE__*/ function() {\n                function Configuration(options) {\n                    configuration_classCallCheck(this, Configuration);\n                    this.configuration = options == null ? {} : cloneDeep_root_cloneDeep_default()(options);\n                    defaults(this.configuration, DEFAULT_CONFIGURATION_PARAMS);\n                }\n                /**\n   * Initializes the configuration. This method is a convenience method that invokes both\n   *  {@link Configuration#fromEnvironment|fromEnvironment()} (Node.js environment only)\n   *  and {@link Configuration#fromDocument|fromDocument()}.\n   *  It first tries to retrieve the configuration from the environment variable.\n   *  If not available, it tries from the document meta tags.\n   * @function Configuration#init\n   * @return {Configuration} returns `this` for chaining\n   * @see fromDocument\n   * @see fromEnvironment\n   */ return configuration_createClass(Configuration, [\n                    {\n                        key: \"init\",\n                        value: function init() {\n                            this.fromEnvironment();\n                            this.fromDocument();\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(name, value) {\n                            this.configuration[name] = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"get\",\n                        value: function get(name) {\n                            return this.configuration[name];\n                        }\n                    },\n                    {\n                        key: \"merge\",\n                        value: function merge(config) {\n                            assign_root_assign_default()(this.configuration, cloneDeep_root_cloneDeep_default()(config));\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fromDocument\",\n                        value: function fromDocument() {\n                            var el, i, len, meta_elements;\n                            meta_elements = typeof document !== \"undefined\" && document !== null ? document.querySelectorAll('meta[name^=\"cloudinary_\"]') : void 0;\n                            if (meta_elements) {\n                                for(i = 0, len = meta_elements.length; i < len; i++){\n                                    el = meta_elements[i];\n                                    this.configuration[el.getAttribute(\"name\").replace(\"cloudinary_\", \"\")] = el.getAttribute(\"content\");\n                                }\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fromEnvironment\",\n                        value: function fromEnvironment() {\n                            var _this = this;\n                            var cloudinary_url, query, uri, uriRegex;\n                            if (typeof process !== \"undefined\" && process !== null && process.env && process.env.CLOUDINARY_URL) {\n                                cloudinary_url = process.env.CLOUDINARY_URL;\n                                uriRegex = /cloudinary:\\/\\/(?:(\\w+)(?:\\:([\\w-]+))?@)?([\\w\\.-]+)(?:\\/([^?]*))?(?:\\?(.+))?/;\n                                uri = uriRegex.exec(cloudinary_url);\n                                if (uri) {\n                                    if (uri[3] != null) {\n                                        this.configuration[\"cloud_name\"] = uri[3];\n                                    }\n                                    if (uri[1] != null) {\n                                        this.configuration[\"api_key\"] = uri[1];\n                                    }\n                                    if (uri[2] != null) {\n                                        this.configuration[\"api_secret\"] = uri[2];\n                                    }\n                                    if (uri[4] != null) {\n                                        this.configuration[\"private_cdn\"] = uri[4] != null;\n                                    }\n                                    if (uri[4] != null) {\n                                        this.configuration[\"secure_distribution\"] = uri[4];\n                                    }\n                                    query = uri[5];\n                                    if (query != null) {\n                                        query.split(\"&\").forEach(function(value) {\n                                            var _value$split = value.split(\"=\"), _value$split2 = _slicedToArray(_value$split, 2), k = _value$split2[0], v = _value$split2[1];\n                                            if (v == null) {\n                                                v = true;\n                                            }\n                                            _this.configuration[k] = v;\n                                        });\n                                    }\n                                }\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"config\",\n                        value: function config(new_config, new_value) {\n                            switch(false){\n                                case new_value === void 0:\n                                    this.set(new_config, new_value);\n                                    return this.configuration;\n                                case !isString_root_isString_default()(new_config):\n                                    return this.get(new_config);\n                                case !isPlainObject_root_isPlainObject_default()(new_config):\n                                    this.merge(new_config);\n                                    return this.configuration;\n                                default:\n                                    // Backward compatibility - return the internal object\n                                    return this.configuration;\n                            }\n                        }\n                    },\n                    {\n                        key: \"toOptions\",\n                        value: function toOptions() {\n                            return cloneDeep_root_cloneDeep_default()(this.configuration);\n                        }\n                    }\n                ]);\n            }();\n            var DEFAULT_CONFIGURATION_PARAMS = {\n                responsive_class: \"cld-responsive\",\n                responsive_use_breakpoints: true,\n                round_dpr: true,\n                secure: ( false ? 0 : void 0) === \"https:\"\n            };\n            configuration_Configuration.CONFIG_PARAMS = [\n                \"api_key\",\n                \"api_secret\",\n                \"callback\",\n                \"cdn_subdomain\",\n                \"cloud_name\",\n                \"cname\",\n                \"private_cdn\",\n                \"protocol\",\n                \"resource_type\",\n                \"responsive\",\n                \"responsive_class\",\n                \"responsive_use_breakpoints\",\n                \"responsive_width\",\n                \"round_dpr\",\n                \"secure\",\n                \"secure_cdn_subdomain\",\n                \"secure_distribution\",\n                \"shorten\",\n                \"type\",\n                \"upload_preset\",\n                \"url_suffix\",\n                \"use_root_path\",\n                \"version\",\n                \"externalLibraries\",\n                \"max_timeout_ms\"\n            ];\n            /* harmony default export */ var src_configuration = configuration_Configuration;\n            // CONCATENATED MODULE: ./src/layer/layer.js\n            function layer_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return layer_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, layer_typeof(o);\n            }\n            function layer_classCallCheck(a, n) {\n                if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n            function layer_defineProperties(e, r) {\n                for(var t = 0; t < r.length; t++){\n                    var o = r[t];\n                    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, layer_toPropertyKey(o.key), o);\n                }\n            }\n            function layer_createClass(e, r, t) {\n                return r && layer_defineProperties(e.prototype, r), t && layer_defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n                    writable: !1\n                }), e;\n            }\n            function layer_toPropertyKey(t) {\n                var i = layer_toPrimitive(t, \"string\");\n                return \"symbol\" == layer_typeof(i) ? i : i + \"\";\n            }\n            function layer_toPrimitive(t, r) {\n                if (\"object\" != layer_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != layer_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            var layer_Layer = /*#__PURE__*/ function() {\n                /**\n   * Layer\n   * @constructor Layer\n   * @param {Object} options - layer parameters\n   */ function Layer1(options) {\n                    var _this = this;\n                    layer_classCallCheck(this, Layer1);\n                    this.options = {};\n                    if (options != null) {\n                        [\n                            \"resourceType\",\n                            \"type\",\n                            \"publicId\",\n                            \"format\"\n                        ].forEach(function(key) {\n                            var ref;\n                            return _this.options[key] = (ref = options[key]) != null ? ref : options[snakeCase(key)];\n                        });\n                    }\n                }\n                return layer_createClass(Layer1, [\n                    {\n                        key: \"resourceType\",\n                        value: function resourceType(value) {\n                            this.options.resourceType = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"type\",\n                        value: function type(value) {\n                            this.options.type = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"publicId\",\n                        value: function publicId(value) {\n                            this.options.publicId = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"getPublicId\",\n                        value: function getPublicId() {\n                            var ref;\n                            return (ref = this.options.publicId) != null ? ref.replace(/\\//g, \":\") : void 0;\n                        }\n                    },\n                    {\n                        key: \"getFullPublicId\",\n                        value: function getFullPublicId() {\n                            if (this.options.format != null) {\n                                return this.getPublicId() + \".\" + this.options.format;\n                            } else {\n                                return this.getPublicId();\n                            }\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(value) {\n                            this.options.format = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            var components;\n                            components = [];\n                            if (this.options.publicId == null) {\n                                throw \"Must supply publicId\";\n                            }\n                            if (!(this.options.resourceType === \"image\")) {\n                                components.push(this.options.resourceType);\n                            }\n                            if (!(this.options.type === \"upload\")) {\n                                components.push(this.options.type);\n                            }\n                            components.push(this.getFullPublicId());\n                            return compact_root_compact_default()(components).join(\":\");\n                        }\n                    },\n                    {\n                        key: \"clone\",\n                        value: function clone() {\n                            return new this.constructor(this.options);\n                        }\n                    }\n                ]);\n            }();\n            /* harmony default export */ var layer_layer = layer_Layer;\n            // CONCATENATED MODULE: ./src/layer/textlayer.js\n            function textlayer_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return textlayer_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, textlayer_typeof(o);\n            }\n            function textlayer_classCallCheck(a, n) {\n                if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n            function textlayer_defineProperties(e, r) {\n                for(var t = 0; t < r.length; t++){\n                    var o = r[t];\n                    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, textlayer_toPropertyKey(o.key), o);\n                }\n            }\n            function textlayer_createClass(e, r, t) {\n                return r && textlayer_defineProperties(e.prototype, r), t && textlayer_defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n                    writable: !1\n                }), e;\n            }\n            function textlayer_toPropertyKey(t) {\n                var i = textlayer_toPrimitive(t, \"string\");\n                return \"symbol\" == textlayer_typeof(i) ? i : i + \"\";\n            }\n            function textlayer_toPrimitive(t, r) {\n                if (\"object\" != textlayer_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != textlayer_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function textlayer_callSuper(t, o, e) {\n                return o = textlayer_getPrototypeOf(o), textlayer_possibleConstructorReturn(t, textlayer_isNativeReflectConstruct() ? Reflect.construct(o, e || [], textlayer_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function textlayer_possibleConstructorReturn(t, e) {\n                if (e && (\"object\" == textlayer_typeof(e) || \"function\" == typeof e)) return e;\n                if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n                return textlayer_assertThisInitialized(t);\n            }\n            function textlayer_assertThisInitialized(e) {\n                if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                return e;\n            }\n            function textlayer_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (textlayer_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function textlayer_getPrototypeOf(t) {\n                return textlayer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {\n                    return t.__proto__ || Object.getPrototypeOf(t);\n                }, textlayer_getPrototypeOf(t);\n            }\n            function textlayer_inherits(t, e) {\n                if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n                t.prototype = Object.create(e && e.prototype, {\n                    constructor: {\n                        value: t,\n                        writable: !0,\n                        configurable: !0\n                    }\n                }), Object.defineProperty(t, \"prototype\", {\n                    writable: !1\n                }), e && textlayer_setPrototypeOf(t, e);\n            }\n            function textlayer_setPrototypeOf(t, e) {\n                return textlayer_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {\n                    return t.__proto__ = e, t;\n                }, textlayer_setPrototypeOf(t, e);\n            }\n            var textlayer_TextLayer = /*#__PURE__*/ function(_Layer) {\n                /**\n   * @constructor TextLayer\n   * @param {Object} options - layer parameters\n   */ function TextLayer(options) {\n                    var _this;\n                    textlayer_classCallCheck(this, TextLayer);\n                    var keys;\n                    _this = textlayer_callSuper(this, TextLayer, [\n                        options\n                    ]);\n                    keys = [\n                        \"resourceType\",\n                        \"resourceType\",\n                        \"fontFamily\",\n                        \"fontSize\",\n                        \"fontWeight\",\n                        \"fontStyle\",\n                        \"textDecoration\",\n                        \"textAlign\",\n                        \"stroke\",\n                        \"letterSpacing\",\n                        \"lineSpacing\",\n                        \"fontHinting\",\n                        \"fontAntialiasing\",\n                        \"text\",\n                        \"textStyle\"\n                    ];\n                    if (options != null) {\n                        keys.forEach(function(key) {\n                            var ref;\n                            return _this.options[key] = (ref = options[key]) != null ? ref : options[snakeCase(key)];\n                        });\n                    }\n                    _this.options.resourceType = \"text\";\n                    return _this;\n                }\n                textlayer_inherits(TextLayer, _Layer);\n                return textlayer_createClass(TextLayer, [\n                    {\n                        key: \"resourceType\",\n                        value: function resourceType(_resourceType) {\n                            throw \"Cannot modify resourceType for text layers\";\n                        }\n                    },\n                    {\n                        key: \"type\",\n                        value: function type(_type) {\n                            throw \"Cannot modify type for text layers\";\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(_format) {\n                            throw \"Cannot modify format for text layers\";\n                        }\n                    },\n                    {\n                        key: \"fontFamily\",\n                        value: function fontFamily(_fontFamily) {\n                            this.options.fontFamily = _fontFamily;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontSize\",\n                        value: function fontSize(_fontSize) {\n                            this.options.fontSize = _fontSize;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontWeight\",\n                        value: function fontWeight(_fontWeight) {\n                            this.options.fontWeight = _fontWeight;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontStyle\",\n                        value: function fontStyle(_fontStyle) {\n                            this.options.fontStyle = _fontStyle;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"textDecoration\",\n                        value: function textDecoration(_textDecoration) {\n                            this.options.textDecoration = _textDecoration;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"textAlign\",\n                        value: function textAlign(_textAlign) {\n                            this.options.textAlign = _textAlign;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"stroke\",\n                        value: function stroke(_stroke) {\n                            this.options.stroke = _stroke;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"letterSpacing\",\n                        value: function letterSpacing(_letterSpacing) {\n                            this.options.letterSpacing = _letterSpacing;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"lineSpacing\",\n                        value: function lineSpacing(_lineSpacing) {\n                            this.options.lineSpacing = _lineSpacing;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontHinting\",\n                        value: function fontHinting(_fontHinting) {\n                            this.options.fontHinting = _fontHinting;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontAntialiasing\",\n                        value: function fontAntialiasing(_fontAntialiasing) {\n                            this.options.fontAntialiasing = _fontAntialiasing;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"text\",\n                        value: function text(_text) {\n                            this.options.text = _text;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"textStyle\",\n                        value: function textStyle(_textStyle) {\n                            this.options.textStyle = _textStyle;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            var components, hasPublicId, hasStyle, publicId, re, res, start, style, text, textSource;\n                            style = this.textStyleIdentifier();\n                            if (this.options.publicId != null) {\n                                publicId = this.getFullPublicId();\n                            }\n                            if (this.options.text != null) {\n                                hasPublicId = !isEmpty(publicId);\n                                hasStyle = !isEmpty(style);\n                                if (hasPublicId && hasStyle || !hasPublicId && !hasStyle) {\n                                    throw \"Must supply either style parameters or a public_id when providing text parameter in a text overlay/underlay, but not both!\";\n                                }\n                                re = /\\$\\([a-zA-Z]\\w*\\)/g;\n                                start = 0;\n                                //        textSource = text.replace(new RegExp(\"[,/]\", 'g'), (c)-> \"%#{c.charCodeAt(0).toString(16).toUpperCase()}\")\n                                textSource = smartEscape(this.options.text, /[,\\/]/g);\n                                text = \"\";\n                                while(res = re.exec(textSource)){\n                                    text += smartEscape(textSource.slice(start, res.index));\n                                    text += res[0];\n                                    start = res.index + res[0].length;\n                                }\n                                text += smartEscape(textSource.slice(start));\n                            }\n                            components = [\n                                this.options.resourceType,\n                                style,\n                                publicId,\n                                text\n                            ];\n                            return compact_root_compact_default()(components).join(\":\");\n                        }\n                    },\n                    {\n                        key: \"textStyleIdentifier\",\n                        value: function textStyleIdentifier() {\n                            // Note: if a text-style argument is provided as a whole, it overrides everything else, no mix and match.\n                            if (!isEmpty(this.options.textStyle)) {\n                                return this.options.textStyle;\n                            }\n                            var components;\n                            components = [];\n                            if (this.options.fontWeight !== \"normal\") {\n                                components.push(this.options.fontWeight);\n                            }\n                            if (this.options.fontStyle !== \"normal\") {\n                                components.push(this.options.fontStyle);\n                            }\n                            if (this.options.textDecoration !== \"none\") {\n                                components.push(this.options.textDecoration);\n                            }\n                            components.push(this.options.textAlign);\n                            if (this.options.stroke !== \"none\") {\n                                components.push(this.options.stroke);\n                            }\n                            if (!(isEmpty(this.options.letterSpacing) && !isNumberLike(this.options.letterSpacing))) {\n                                components.push(\"letter_spacing_\" + this.options.letterSpacing);\n                            }\n                            if (!(isEmpty(this.options.lineSpacing) && !isNumberLike(this.options.lineSpacing))) {\n                                components.push(\"line_spacing_\" + this.options.lineSpacing);\n                            }\n                            if (!isEmpty(this.options.fontAntialiasing)) {\n                                components.push(\"antialias_\" + this.options.fontAntialiasing);\n                            }\n                            if (!isEmpty(this.options.fontHinting)) {\n                                components.push(\"hinting_\" + this.options.fontHinting);\n                            }\n                            if (!isEmpty(compact_root_compact_default()(components))) {\n                                if (isEmpty(this.options.fontFamily)) {\n                                    throw \"Must supply fontFamily. \".concat(components);\n                                }\n                                if (isEmpty(this.options.fontSize) && !isNumberLike(this.options.fontSize)) {\n                                    throw \"Must supply fontSize.\";\n                                }\n                            }\n                            components.unshift(this.options.fontFamily, this.options.fontSize);\n                            components = compact_root_compact_default()(components).join(\"_\");\n                            return components;\n                        }\n                    }\n                ]);\n            }(layer_layer);\n            ;\n            /* harmony default export */ var textlayer = textlayer_TextLayer;\n            // CONCATENATED MODULE: ./src/layer/subtitleslayer.js\n            function subtitleslayer_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return subtitleslayer_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, subtitleslayer_typeof(o);\n            }\n            function subtitleslayer_defineProperties(e, r) {\n                for(var t = 0; t < r.length; t++){\n                    var o = r[t];\n                    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, subtitleslayer_toPropertyKey(o.key), o);\n                }\n            }\n            function subtitleslayer_createClass(e, r, t) {\n                return r && subtitleslayer_defineProperties(e.prototype, r), t && subtitleslayer_defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n                    writable: !1\n                }), e;\n            }\n            function subtitleslayer_toPropertyKey(t) {\n                var i = subtitleslayer_toPrimitive(t, \"string\");\n                return \"symbol\" == subtitleslayer_typeof(i) ? i : i + \"\";\n            }\n            function subtitleslayer_toPrimitive(t, r) {\n                if (\"object\" != subtitleslayer_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != subtitleslayer_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function subtitleslayer_classCallCheck(a, n) {\n                if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n            function subtitleslayer_callSuper(t, o, e) {\n                return o = subtitleslayer_getPrototypeOf(o), subtitleslayer_possibleConstructorReturn(t, subtitleslayer_isNativeReflectConstruct() ? Reflect.construct(o, e || [], subtitleslayer_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function subtitleslayer_possibleConstructorReturn(t, e) {\n                if (e && (\"object\" == subtitleslayer_typeof(e) || \"function\" == typeof e)) return e;\n                if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n                return subtitleslayer_assertThisInitialized(t);\n            }\n            function subtitleslayer_assertThisInitialized(e) {\n                if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                return e;\n            }\n            function subtitleslayer_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (subtitleslayer_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function subtitleslayer_getPrototypeOf(t) {\n                return subtitleslayer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {\n                    return t.__proto__ || Object.getPrototypeOf(t);\n                }, subtitleslayer_getPrototypeOf(t);\n            }\n            function subtitleslayer_inherits(t, e) {\n                if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n                t.prototype = Object.create(e && e.prototype, {\n                    constructor: {\n                        value: t,\n                        writable: !0,\n                        configurable: !0\n                    }\n                }), Object.defineProperty(t, \"prototype\", {\n                    writable: !1\n                }), e && subtitleslayer_setPrototypeOf(t, e);\n            }\n            function subtitleslayer_setPrototypeOf(t, e) {\n                return subtitleslayer_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {\n                    return t.__proto__ = e, t;\n                }, subtitleslayer_setPrototypeOf(t, e);\n            }\n            var SubtitlesLayer = /*#__PURE__*/ function(_TextLayer) {\n                /**\n   * Represent a subtitles layer\n   * @constructor SubtitlesLayer\n   * @param {Object} options - layer parameters\n   */ function SubtitlesLayer(options) {\n                    var _this;\n                    subtitleslayer_classCallCheck(this, SubtitlesLayer);\n                    _this = subtitleslayer_callSuper(this, SubtitlesLayer, [\n                        options\n                    ]);\n                    _this.options.resourceType = \"subtitles\";\n                    return _this;\n                }\n                subtitleslayer_inherits(SubtitlesLayer, _TextLayer);\n                return subtitleslayer_createClass(SubtitlesLayer);\n            }(textlayer);\n            /* harmony default export */ var subtitleslayer = SubtitlesLayer;\n            // CONCATENATED MODULE: ./src/layer/fetchlayer.js\n            function fetchlayer_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return fetchlayer_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, fetchlayer_typeof(o);\n            }\n            function fetchlayer_classCallCheck(a, n) {\n                if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n            function fetchlayer_defineProperties(e, r) {\n                for(var t = 0; t < r.length; t++){\n                    var o = r[t];\n                    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, fetchlayer_toPropertyKey(o.key), o);\n                }\n            }\n            function fetchlayer_createClass(e, r, t) {\n                return r && fetchlayer_defineProperties(e.prototype, r), t && fetchlayer_defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n                    writable: !1\n                }), e;\n            }\n            function fetchlayer_toPropertyKey(t) {\n                var i = fetchlayer_toPrimitive(t, \"string\");\n                return \"symbol\" == fetchlayer_typeof(i) ? i : i + \"\";\n            }\n            function fetchlayer_toPrimitive(t, r) {\n                if (\"object\" != fetchlayer_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != fetchlayer_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function fetchlayer_callSuper(t, o, e) {\n                return o = fetchlayer_getPrototypeOf(o), fetchlayer_possibleConstructorReturn(t, fetchlayer_isNativeReflectConstruct() ? Reflect.construct(o, e || [], fetchlayer_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function fetchlayer_possibleConstructorReturn(t, e) {\n                if (e && (\"object\" == fetchlayer_typeof(e) || \"function\" == typeof e)) return e;\n                if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n                return fetchlayer_assertThisInitialized(t);\n            }\n            function fetchlayer_assertThisInitialized(e) {\n                if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                return e;\n            }\n            function fetchlayer_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (fetchlayer_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function fetchlayer_getPrototypeOf(t) {\n                return fetchlayer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {\n                    return t.__proto__ || Object.getPrototypeOf(t);\n                }, fetchlayer_getPrototypeOf(t);\n            }\n            function fetchlayer_inherits(t, e) {\n                if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n                t.prototype = Object.create(e && e.prototype, {\n                    constructor: {\n                        value: t,\n                        writable: !0,\n                        configurable: !0\n                    }\n                }), Object.defineProperty(t, \"prototype\", {\n                    writable: !1\n                }), e && fetchlayer_setPrototypeOf(t, e);\n            }\n            function fetchlayer_setPrototypeOf(t, e) {\n                return fetchlayer_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {\n                    return t.__proto__ = e, t;\n                }, fetchlayer_setPrototypeOf(t, e);\n            }\n            var fetchlayer_FetchLayer = /*#__PURE__*/ function(_Layer) {\n                /**\n   * @class FetchLayer\n   * @classdesc Creates an image layer using a remote URL.\n   * @param {Object|string} options - layer parameters or a url\n   * @param {string} options.url the url of the image to fetch\n   */ function FetchLayer(options) {\n                    var _this;\n                    fetchlayer_classCallCheck(this, FetchLayer);\n                    _this = fetchlayer_callSuper(this, FetchLayer, [\n                        options\n                    ]);\n                    if (isString_root_isString_default()(options)) {\n                        _this.options.url = options;\n                    } else if (options != null ? options.url : void 0) {\n                        _this.options.url = options.url;\n                    }\n                    return _this;\n                }\n                fetchlayer_inherits(FetchLayer, _Layer);\n                return fetchlayer_createClass(FetchLayer, [\n                    {\n                        key: \"url\",\n                        value: function url(_url) {\n                            this.options.url = _url;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            return \"fetch:\".concat(base64EncodeURL(this.options.url));\n                        }\n                    }\n                ]);\n            }(layer_layer);\n            /* harmony default export */ var fetchlayer = fetchlayer_FetchLayer;\n            // CONCATENATED MODULE: ./src/parameters.js\n            function parameters_callSuper(t, o, e) {\n                return o = parameters_getPrototypeOf(o), parameters_possibleConstructorReturn(t, parameters_isNativeReflectConstruct() ? Reflect.construct(o, e || [], parameters_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function parameters_possibleConstructorReturn(t, e) {\n                if (e && (\"object\" == parameters_typeof(e) || \"function\" == typeof e)) return e;\n                if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n                return parameters_assertThisInitialized(t);\n            }\n            function parameters_assertThisInitialized(e) {\n                if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                return e;\n            }\n            function parameters_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (parameters_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function _superPropGet(t, o, e, r) {\n                var p = _get(parameters_getPrototypeOf(1 & r ? t.prototype : t), o, e);\n                return 2 & r && \"function\" == typeof p ? function(t) {\n                    return p.apply(e, t);\n                } : p;\n            }\n            function _get() {\n                return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {\n                    var p = _superPropBase(e, t);\n                    if (p) {\n                        var n = Object.getOwnPropertyDescriptor(p, t);\n                        return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;\n                    }\n                }, _get.apply(null, arguments);\n            }\n            function _superPropBase(t, o) {\n                for(; !({}).hasOwnProperty.call(t, o) && null !== (t = parameters_getPrototypeOf(t)););\n                return t;\n            }\n            function parameters_getPrototypeOf(t) {\n                return parameters_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {\n                    return t.__proto__ || Object.getPrototypeOf(t);\n                }, parameters_getPrototypeOf(t);\n            }\n            function parameters_inherits(t, e) {\n                if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n                t.prototype = Object.create(e && e.prototype, {\n                    constructor: {\n                        value: t,\n                        writable: !0,\n                        configurable: !0\n                    }\n                }), Object.defineProperty(t, \"prototype\", {\n                    writable: !1\n                }), e && parameters_setPrototypeOf(t, e);\n            }\n            function parameters_setPrototypeOf(t, e) {\n                return parameters_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {\n                    return t.__proto__ = e, t;\n                }, parameters_setPrototypeOf(t, e);\n            }\n            function parameters_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return parameters_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, parameters_typeof(o);\n            }\n            function parameters_classCallCheck(a, n) {\n                if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n            function parameters_defineProperties(e, r) {\n                for(var t = 0; t < r.length; t++){\n                    var o = r[t];\n                    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, parameters_toPropertyKey(o.key), o);\n                }\n            }\n            function parameters_createClass(e, r, t) {\n                return r && parameters_defineProperties(e.prototype, r), t && parameters_defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n                    writable: !1\n                }), e;\n            }\n            function parameters_toPropertyKey(t) {\n                var i = parameters_toPrimitive(t, \"string\");\n                return \"symbol\" == parameters_typeof(i) ? i : i + \"\";\n            }\n            function parameters_toPrimitive(t, r) {\n                if (\"object\" != parameters_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != parameters_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            /**\n * Transformation parameters\n * Depends on 'util', 'transformation'\n */ var parameters_Param = /*#__PURE__*/ function() {\n                /**\n   * Represents a single parameter.\n   * @class Param\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} shortName - The name of the serialized form of the parameter.\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @ignore\n   */ function Param(name, shortName) {\n                    var process1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity_root_identity_default.a;\n                    parameters_classCallCheck(this, Param);\n                    /**\n     * The name of the parameter in snake_case\n     * @member {string} Param#name\n     */ this.name = name;\n                    /**\n     * The name of the serialized form of the parameter\n     * @member {string} Param#shortName\n     */ this.shortName = shortName;\n                    /**\n     * Manipulate origValue when value is called\n     * @member {function} Param#process\n     */ this.process = process1;\n                }\n                /**\n   * Set a (unprocessed) value for this parameter\n   * @function Param#set\n   * @param {*} origValue - the value of the parameter\n   * @return {Param} self for chaining\n   */ return parameters_createClass(Param, [\n                    {\n                        key: \"set\",\n                        value: function set(origValue) {\n                            this.origValue = origValue;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            var val, valid;\n                            val = this.value();\n                            valid = isArray_root_isArray_default()(val) || isPlainObject_root_isPlainObject_default()(val) || isString_root_isString_default()(val) ? !isEmpty(val) : val != null;\n                            if (this.shortName != null && valid) {\n                                return \"\".concat(this.shortName, \"_\").concat(val);\n                            } else {\n                                return \"\";\n                            }\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value() {\n                            return this.process(this.origValue);\n                        }\n                    }\n                ], [\n                    {\n                        key: \"norm_color\",\n                        value: function norm_color(value) {\n                            return value != null ? value.replace(/^#/, \"rgb:\") : void 0;\n                        }\n                    },\n                    {\n                        key: \"build_array\",\n                        value: function build_array(arg) {\n                            if (arg == null) {\n                                return [];\n                            } else if (isArray_root_isArray_default()(arg)) {\n                                return arg;\n                            } else {\n                                return [\n                                    arg\n                                ];\n                            }\n                        }\n                    },\n                    {\n                        key: \"process_video_params\",\n                        value: function process_video_params(param) {\n                            var video;\n                            switch(param.constructor){\n                                case Object:\n                                    video = \"\";\n                                    if (\"codec\" in param) {\n                                        video = param.codec;\n                                        if (\"profile\" in param) {\n                                            video += \":\" + param.profile;\n                                            if (\"level\" in param) {\n                                                video += \":\" + param.level;\n                                                if (\"b_frames\" in param && param.b_frames === false) {\n                                                    video += \":bframes_no\";\n                                                }\n                                            }\n                                        }\n                                    }\n                                    return video;\n                                case String:\n                                    return param;\n                                default:\n                                    return null;\n                            }\n                        }\n                    }\n                ]);\n            }();\n            var parameters_ArrayParam = /*#__PURE__*/ function(_Param) {\n                /**\n   * A parameter that represents an array.\n   * @param {string} name - The name of the parameter in snake_case.\n   * @param {string} shortName - The name of the serialized form of the parameter\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {string} [sep='.'] - The separator to use when joining the array elements together\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @class ArrayParam\n   * @extends Param\n   * @ignore\n   */ function ArrayParam(name, shortName) {\n                    var _this;\n                    var sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \".\";\n                    var process1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n                    parameters_classCallCheck(this, ArrayParam);\n                    _this = parameters_callSuper(this, ArrayParam, [\n                        name,\n                        shortName,\n                        process1\n                    ]);\n                    _this.sep = sep;\n                    return _this;\n                }\n                parameters_inherits(ArrayParam, _Param);\n                return parameters_createClass(ArrayParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            if (this.shortName != null) {\n                                var arrayValue = this.value();\n                                if (isEmpty(arrayValue)) {\n                                    return \"\";\n                                } else if (isString_root_isString_default()(arrayValue)) {\n                                    return \"\".concat(this.shortName, \"_\").concat(arrayValue);\n                                } else {\n                                    var flat = arrayValue.map(function(t) {\n                                        return isFunction_root_isFunction_default()(t.serialize) ? t.serialize() : t;\n                                    }).join(this.sep);\n                                    return \"\".concat(this.shortName, \"_\").concat(flat);\n                                }\n                            } else {\n                                return \"\";\n                            }\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value() {\n                            var _this2 = this;\n                            if (isArray_root_isArray_default()(this.origValue)) {\n                                return this.origValue.map(function(v) {\n                                    return _this2.process(v);\n                                });\n                            } else {\n                                return this.process(this.origValue);\n                            }\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(origValue) {\n                            if (origValue == null || isArray_root_isArray_default()(origValue)) {\n                                return _superPropGet(ArrayParam, \"set\", this, 3)([\n                                    origValue\n                                ]);\n                            } else {\n                                return _superPropGet(ArrayParam, \"set\", this, 3)([\n                                    [\n                                        origValue\n                                    ]\n                                ]);\n                            }\n                        }\n                    }\n                ]);\n            }(parameters_Param);\n            var parameters_TransformationParam = /*#__PURE__*/ function(_Param2) {\n                /**\n   * A parameter that represents a transformation\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} [shortName='t'] - The name of the serialized form of the parameter\n   * @param {string} [sep='.'] - The separator to use when joining the array elements together\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @class TransformationParam\n   * @extends Param\n   * @ignore\n   */ function TransformationParam(name) {\n                    var _this3;\n                    var shortName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"t\";\n                    var sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \".\";\n                    var process1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n                    parameters_classCallCheck(this, TransformationParam);\n                    _this3 = parameters_callSuper(this, TransformationParam, [\n                        name,\n                        shortName,\n                        process1\n                    ]);\n                    _this3.sep = sep;\n                    return _this3;\n                }\n                /**\n   * Generate string representations of the transformation.\n   * @returns {*} Returns either the transformation as a string, or an array of string representations.\n   */ parameters_inherits(TransformationParam, _Param2);\n                return parameters_createClass(TransformationParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            var _this4 = this;\n                            var result = \"\";\n                            var val = this.value();\n                            if (isEmpty(val)) {\n                                return result;\n                            }\n                            // val is an array of strings so join them\n                            if (baseutil_allStrings(val)) {\n                                var joined = val.join(this.sep); // creates t1.t2.t3 in case multiple named transformations were configured\n                                if (!isEmpty(joined)) {\n                                    // in case options.transformation was not set with an empty string (val != ['']);\n                                    result = \"\".concat(this.shortName, \"_\").concat(joined);\n                                }\n                            } else {\n                                // Convert val to an array of strings\n                                result = val.map(function(t) {\n                                    if (isString_root_isString_default()(t) && !isEmpty(t)) {\n                                        return \"\".concat(_this4.shortName, \"_\").concat(t);\n                                    }\n                                    if (isFunction_root_isFunction_default()(t.serialize)) {\n                                        return t.serialize();\n                                    }\n                                    if (isPlainObject_root_isPlainObject_default()(t) && !isEmpty(t)) {\n                                        return new src_transformation(t).serialize();\n                                    }\n                                    return undefined;\n                                }).filter(function(t) {\n                                    return t;\n                                });\n                            }\n                            return result;\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(origValue1) {\n                            this.origValue = origValue1;\n                            if (isArray_root_isArray_default()(this.origValue)) {\n                                return _superPropGet(TransformationParam, \"set\", this, 3)([\n                                    this.origValue\n                                ]);\n                            } else {\n                                return _superPropGet(TransformationParam, \"set\", this, 3)([\n                                    [\n                                        this.origValue\n                                    ]\n                                ]);\n                            }\n                        }\n                    }\n                ]);\n            }(parameters_Param);\n            var number_pattern = \"([0-9]*)\\\\.([0-9]+)|([0-9]+)\";\n            var offset_any_pattern = \"(\" + number_pattern + \")([%pP])?\";\n            var parameters_RangeParam = /*#__PURE__*/ function(_Param3) {\n                /**\n   * A parameter that represents a range\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} shortName - The name of the serialized form of the parameter\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {function} [process=norm_range_value ] - Manipulate origValue when value is called\n   * @class RangeParam\n   * @extends Param\n   * @ignore\n   */ function RangeParam(name, shortName) {\n                    var process1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : RangeParam.norm_range_value;\n                    parameters_classCallCheck(this, RangeParam);\n                    return parameters_callSuper(this, RangeParam, [\n                        name,\n                        shortName,\n                        process1\n                    ]);\n                }\n                parameters_inherits(RangeParam, _Param3);\n                return parameters_createClass(RangeParam, null, [\n                    {\n                        key: \"norm_range_value\",\n                        value: function norm_range_value(value) {\n                            var offset = String(value).match(new RegExp(\"^\" + offset_any_pattern + \"$\"));\n                            if (offset) {\n                                var modifier = offset[5] != null ? \"p\" : \"\";\n                                value = (offset[1] || offset[4]) + modifier;\n                            }\n                            return expression.normalize(value);\n                        }\n                    }\n                ]);\n            }(parameters_Param);\n            var parameters_RawParam = /*#__PURE__*/ function(_Param4) {\n                function RawParam(name, shortName) {\n                    var process1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity_root_identity_default.a;\n                    parameters_classCallCheck(this, RawParam);\n                    return parameters_callSuper(this, RawParam, [\n                        name,\n                        shortName,\n                        process1\n                    ]);\n                }\n                parameters_inherits(RawParam, _Param4);\n                return parameters_createClass(RawParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            return this.value();\n                        }\n                    }\n                ]);\n            }(parameters_Param);\n            var parameters_LayerParam = /*#__PURE__*/ function(_Param5) {\n                function LayerParam() {\n                    parameters_classCallCheck(this, LayerParam);\n                    return parameters_callSuper(this, LayerParam, arguments);\n                }\n                parameters_inherits(LayerParam, _Param5);\n                return parameters_createClass(LayerParam, [\n                    {\n                        key: \"value\",\n                        value: // Parse layer options\n                        // @return [string] layer transformation string\n                        // @private\n                        function value() {\n                            if (this.origValue == null) {\n                                return \"\";\n                            }\n                            var result;\n                            if (this.origValue instanceof layer_layer) {\n                                result = this.origValue;\n                            } else if (isPlainObject_root_isPlainObject_default()(this.origValue)) {\n                                var layerOptions = withCamelCaseKeys(this.origValue);\n                                if (layerOptions.resourceType === \"text\" || layerOptions.text != null) {\n                                    result = new textlayer(layerOptions);\n                                } else if (layerOptions.resourceType === \"subtitles\") {\n                                    result = new subtitleslayer(layerOptions);\n                                } else if (layerOptions.resourceType === \"fetch\" || layerOptions.url != null) {\n                                    result = new fetchlayer(layerOptions);\n                                } else {\n                                    result = new layer_layer(layerOptions);\n                                }\n                            } else if (isString_root_isString_default()(this.origValue)) {\n                                if (/^fetch:.+/.test(this.origValue)) {\n                                    result = new fetchlayer(this.origValue.substr(6));\n                                } else {\n                                    result = this.origValue;\n                                }\n                            } else {\n                                result = \"\";\n                            }\n                            return result.toString();\n                        }\n                    }\n                ], [\n                    {\n                        key: \"textStyle\",\n                        value: function textStyle(layer) {\n                            return new textlayer(layer).textStyleIdentifier();\n                        }\n                    }\n                ]);\n            }(parameters_Param);\n            var parameters_ExpressionParam = /*#__PURE__*/ function(_Param6) {\n                function ExpressionParam() {\n                    parameters_classCallCheck(this, ExpressionParam);\n                    return parameters_callSuper(this, ExpressionParam, arguments);\n                }\n                parameters_inherits(ExpressionParam, _Param6);\n                return parameters_createClass(ExpressionParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            return expression.normalize(_superPropGet(ExpressionParam, \"serialize\", this, 3)([]));\n                        }\n                    }\n                ]);\n            }(parameters_Param);\n            // CONCATENATED MODULE: ./src/transformation.js\n            function transformation_callSuper(t, o, e) {\n                return o = transformation_getPrototypeOf(o), transformation_possibleConstructorReturn(t, transformation_isNativeReflectConstruct() ? Reflect.construct(o, e || [], transformation_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function transformation_possibleConstructorReturn(t, e) {\n                if (e && (\"object\" == transformation_typeof(e) || \"function\" == typeof e)) return e;\n                if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n                return transformation_assertThisInitialized(t);\n            }\n            function transformation_assertThisInitialized(e) {\n                if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                return e;\n            }\n            function transformation_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (transformation_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function transformation_getPrototypeOf(t) {\n                return transformation_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {\n                    return t.__proto__ || Object.getPrototypeOf(t);\n                }, transformation_getPrototypeOf(t);\n            }\n            function transformation_inherits(t, e) {\n                if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n                t.prototype = Object.create(e && e.prototype, {\n                    constructor: {\n                        value: t,\n                        writable: !0,\n                        configurable: !0\n                    }\n                }), Object.defineProperty(t, \"prototype\", {\n                    writable: !1\n                }), e && transformation_setPrototypeOf(t, e);\n            }\n            function transformation_setPrototypeOf(t, e) {\n                return transformation_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {\n                    return t.__proto__ = e, t;\n                }, transformation_setPrototypeOf(t, e);\n            }\n            function transformation_slicedToArray(r, e) {\n                return transformation_arrayWithHoles(r) || transformation_iterableToArrayLimit(r, e) || transformation_unsupportedIterableToArray(r, e) || transformation_nonIterableRest();\n            }\n            function transformation_nonIterableRest() {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function transformation_unsupportedIterableToArray(r, a) {\n                if (r) {\n                    if (\"string\" == typeof r) return transformation_arrayLikeToArray(r, a);\n                    var t = ({}).toString.call(r).slice(8, -1);\n                    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? transformation_arrayLikeToArray(r, a) : void 0;\n                }\n            }\n            function transformation_arrayLikeToArray(r, a) {\n                (null == a || a > r.length) && (a = r.length);\n                for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];\n                return n;\n            }\n            function transformation_iterableToArrayLimit(r, l) {\n                var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n                if (null != t) {\n                    var e, n, i, u, a = [], f = !0, o = !1;\n                    try {\n                        if (i = (t = t.call(r)).next, 0 === l) {\n                            if (Object(t) !== t) return;\n                            f = !1;\n                        } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n                    } catch (r) {\n                        o = !0, n = r;\n                    } finally{\n                        try {\n                            if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n                        } finally{\n                            if (o) throw n;\n                        }\n                    }\n                    return a;\n                }\n            }\n            function transformation_arrayWithHoles(r) {\n                if (Array.isArray(r)) return r;\n            }\n            function transformation_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return transformation_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, transformation_typeof(o);\n            }\n            function transformation_classCallCheck(a, n) {\n                if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n            function transformation_defineProperties(e, r) {\n                for(var t = 0; t < r.length; t++){\n                    var o = r[t];\n                    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, transformation_toPropertyKey(o.key), o);\n                }\n            }\n            function transformation_createClass(e, r, t) {\n                return r && transformation_defineProperties(e.prototype, r), t && transformation_defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n                    writable: !1\n                }), e;\n            }\n            function transformation_toPropertyKey(t) {\n                var i = transformation_toPrimitive(t, \"string\");\n                return \"symbol\" == transformation_typeof(i) ? i : i + \"\";\n            }\n            function transformation_toPrimitive(t, r) {\n                if (\"object\" != transformation_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != transformation_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            /**\n * Assign key, value to target, when value is not null.<br>\n *   This function mutates the target!\n * @param {object} target the object to assign the values to\n * @param {object} sources one or more objects to get values from\n * @returns {object} the target after the assignment\n */ function assignNotNull(target) {\n                for(var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    sources[_key - 1] = arguments[_key];\n                }\n                sources.forEach(function(source) {\n                    Object.keys(source).forEach(function(key) {\n                        if (source[key] != null) {\n                            target[key] = source[key];\n                        }\n                    });\n                });\n                return target;\n            }\n            /**\n * TransformationBase\n * Depends on 'configuration', 'parameters','util'\n * @internal\n */ var transformation_TransformationBase = /*#__PURE__*/ function() {\n                /**\n   * The base class for transformations.\n   * Members of this class are documented as belonging to the {@link Transformation} class for convenience.\n   * @class TransformationBase\n   */ function TransformationBase(options) {\n                    transformation_classCallCheck(this, TransformationBase);\n                    /** @private */ /** @private */ var parent, trans;\n                    parent = void 0;\n                    trans = {};\n                    /**\n     * Return an options object that can be used to create an identical Transformation\n     * @function Transformation#toOptions\n     * @return {Object} Returns a plain object representing this transformation\n     */ this.toOptions = function(withChain) {\n                        var opt = {};\n                        if (withChain == null) {\n                            withChain = true;\n                        }\n                        Object.keys(trans).forEach(function(key) {\n                            return opt[key] = trans[key].origValue;\n                        });\n                        assignNotNull(opt, this.otherOptions);\n                        if (withChain && !isEmpty(this.chained)) {\n                            var list = this.chained.map(function(tr) {\n                                return tr.toOptions();\n                            });\n                            list.push(opt);\n                            opt = {};\n                            assignNotNull(opt, this.otherOptions);\n                            opt.transformation = list;\n                        }\n                        return opt;\n                    };\n                    /**\n     * Set a parent for this object for chaining purposes.\n     *\n     * @function Transformation#setParent\n     * @param {Object} object - the parent to be assigned to\n     * @returns {Transformation} Returns this instance for chaining purposes.\n     */ this.setParent = function(object) {\n                        parent = object;\n                        if (object != null) {\n                            this.fromOptions(typeof object.toOptions === \"function\" ? object.toOptions() : void 0);\n                        }\n                        return this;\n                    };\n                    /**\n     * Returns the parent of this object in the chain\n     * @function Transformation#getParent\n     * @protected\n     * @return {Object} Returns the parent of this object if there is any\n     */ this.getParent = function() {\n                        return parent;\n                    };\n                    // Helper methods to create parameter methods\n                    // These methods are defined here because they access `trans` which is\n                    // a private member of `TransformationBase`\n                    /** @protected */ this.param = function(value, name, abbr, defaultValue, process1) {\n                        if (process1 == null) {\n                            if (isFunction_root_isFunction_default()(defaultValue)) {\n                                process1 = defaultValue;\n                            } else {\n                                process1 = identity_root_identity_default.a;\n                            }\n                        }\n                        trans[name] = new parameters_Param(name, abbr, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.rawParam = function(value, name, abbr, defaultValue, process1) {\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_RawParam(name, abbr, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.rangeParam = function(value, name, abbr, defaultValue, process1) {\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_RangeParam(name, abbr, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.arrayParam = function(value, name, abbr) {\n                        var sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \":\";\n                        var defaultValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n                        var process1 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_ArrayParam(name, abbr, sep, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.transformationParam = function(value, name, abbr) {\n                        var sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \".\";\n                        var defaultValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n                        var process1 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_TransformationParam(name, abbr, sep, process1).set(value);\n                        return this;\n                    };\n                    this.layerParam = function(value, name, abbr) {\n                        trans[name] = new parameters_LayerParam(name, abbr).set(value);\n                        return this;\n                    };\n                    // End Helper methods\n                    /**\n     * Get the value associated with the given name.\n     * @function Transformation#getValue\n     * @param {string} name - the name of the parameter\n     * @return {*} the processed value associated with the given name\n     * @description Use {@link get}.origValue for the value originally provided for the parameter\n     */ this.getValue = function(name) {\n                        var value = trans[name] && trans[name].value();\n                        return value != null ? value : this.otherOptions[name];\n                    };\n                    /**\n     * Get the parameter object for the given parameter name\n     * @function Transformation#get\n     * @param {string} name the name of the transformation parameter\n     * @returns {Param} the param object for the given name, or undefined\n     */ this.get = function(name) {\n                        return trans[name];\n                    };\n                    /**\n     * Remove a transformation option from the transformation.\n     * @function Transformation#remove\n     * @param {string} name - the name of the option to remove\n     * @return {*} Returns the option that was removed or null if no option by that name was found. The type of the\n     *              returned value depends on the value.\n     */ this.remove = function(name) {\n                        var temp;\n                        switch(false){\n                            case trans[name] == null:\n                                temp = trans[name];\n                                delete trans[name];\n                                return temp.origValue;\n                            case this.otherOptions[name] == null:\n                                temp = this.otherOptions[name];\n                                delete this.otherOptions[name];\n                                return temp;\n                            default:\n                                return null;\n                        }\n                    };\n                    /**\n     * Return an array of all the keys (option names) in the transformation.\n     * @return {Array<string>} the keys in snakeCase format\n     */ this.keys = function() {\n                        var key;\n                        return (function() {\n                            var results;\n                            results = [];\n                            for(key in trans){\n                                if (key != null) {\n                                    results.push(key.match(VAR_NAME_RE) ? key : snakeCase(key));\n                                }\n                            }\n                            return results;\n                        })().sort();\n                    };\n                    /**\n     * Returns a plain object representation of the transformation. Values are processed.\n     * @function Transformation#toPlainObject\n     * @return {Object} the transformation options as plain object\n     */ this.toPlainObject = function() {\n                        var hash, key, list;\n                        hash = {};\n                        for(key in trans){\n                            hash[key] = trans[key].value();\n                            if (isPlainObject_root_isPlainObject_default()(hash[key])) {\n                                hash[key] = cloneDeep_root_cloneDeep_default()(hash[key]);\n                            }\n                        }\n                        if (!isEmpty(this.chained)) {\n                            list = this.chained.map(function(tr) {\n                                return tr.toPlainObject();\n                            });\n                            list.push(hash);\n                            hash = {\n                                transformation: list\n                            };\n                        }\n                        return hash;\n                    };\n                    /**\n     * Complete the current transformation and chain to a new one.\n     * In the URL, transformations are chained together by slashes.\n     * @function Transformation#chain\n     * @return {Transformation} Returns this transformation for chaining\n     * @example\n     * var tr = cloudinary.Transformation.new();\n     * tr.width(10).crop('fit').chain().angle(15).serialize()\n     * // produces \"c_fit,w_10/a_15\"\n     */ this.chain = function() {\n                        var names, tr;\n                        names = Object.getOwnPropertyNames(trans);\n                        if (names.length !== 0) {\n                            tr = new this.constructor(this.toOptions(false));\n                            this.resetTransformations();\n                            this.chained.push(tr);\n                        }\n                        return this;\n                    };\n                    this.resetTransformations = function() {\n                        trans = {};\n                        return this;\n                    };\n                    this.otherOptions = {};\n                    this.chained = [];\n                    this.fromOptions(options);\n                }\n                /**\n   * Merge the provided options with own's options\n   * @param {Object} [options={}] key-value list of options\n   * @returns {Transformation} Returns this instance for chaining\n   */ return transformation_createClass(TransformationBase, [\n                    {\n                        key: \"fromOptions\",\n                        value: function fromOptions() {\n                            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                            if (options instanceof TransformationBase) {\n                                this.fromTransformation(options);\n                            } else {\n                                if (isString_root_isString_default()(options) || isArray_root_isArray_default()(options)) {\n                                    options = {\n                                        transformation: options\n                                    };\n                                }\n                                options = cloneDeep_root_cloneDeep_default()(options, function(value) {\n                                    if (value instanceof TransformationBase || value instanceof Layer) {\n                                        return new value.clone();\n                                    }\n                                });\n                                // Handling of \"if\" statements precedes other options as it creates a chained transformation\n                                if (options[\"if\"]) {\n                                    this.set(\"if\", options[\"if\"]);\n                                    delete options[\"if\"];\n                                }\n                                for(var key in options){\n                                    var opt = options[key];\n                                    if (opt != null) {\n                                        if (key.match(VAR_NAME_RE)) {\n                                            if (key !== \"$attr\") {\n                                                this.set(\"variable\", key, opt);\n                                            }\n                                        } else {\n                                            this.set(key, opt);\n                                        }\n                                    }\n                                }\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fromTransformation\",\n                        value: function fromTransformation(other) {\n                            var _this = this;\n                            if (other instanceof TransformationBase) {\n                                other.keys().forEach(function(key) {\n                                    return _this.set(key, other.get(key).origValue);\n                                });\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(key) {\n                            var camelKey;\n                            camelKey = camelCase(key);\n                            for(var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                                values[_key2 - 1] = arguments[_key2];\n                            }\n                            if (includes_root_includes_default()(transformation_Transformation.methods, camelKey)) {\n                                this[camelKey].apply(this, values);\n                            } else {\n                                this.otherOptions[key] = values[0];\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"hasLayer\",\n                        value: function hasLayer() {\n                            return this.getValue(\"overlay\") || this.getValue(\"underlay\");\n                        }\n                    },\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            var ifParam, j, len, paramList, ref, ref1, ref2, ref3, ref4, resultArray, t, transformationList, transformationString, transformations, value, variables, vars;\n                            resultArray = this.chained.map(function(tr) {\n                                return tr.serialize();\n                            });\n                            paramList = this.keys();\n                            transformations = (ref = this.get(\"transformation\")) != null ? ref.serialize() : void 0;\n                            ifParam = (ref1 = this.get(\"if\")) != null ? ref1.serialize() : void 0;\n                            variables = processVar((ref2 = this.get(\"variables\")) != null ? ref2.value() : void 0);\n                            paramList = difference_root_difference_default()(paramList, [\n                                \"transformation\",\n                                \"if\",\n                                \"variables\"\n                            ]);\n                            vars = [];\n                            transformationList = [];\n                            for(j = 0, len = paramList.length; j < len; j++){\n                                t = paramList[j];\n                                if (t.match(VAR_NAME_RE)) {\n                                    vars.push(t + \"_\" + expression.normalize((ref3 = this.get(t)) != null ? ref3.value() : void 0));\n                                } else {\n                                    transformationList.push((ref4 = this.get(t)) != null ? ref4.serialize() : void 0);\n                                }\n                            }\n                            switch(false){\n                                case !isString_root_isString_default()(transformations):\n                                    transformationList.push(transformations);\n                                    break;\n                                case !isArray_root_isArray_default()(transformations):\n                                    resultArray = resultArray.concat(transformations);\n                            }\n                            transformationList = function() {\n                                var k, len1, results;\n                                results = [];\n                                for(k = 0, len1 = transformationList.length; k < len1; k++){\n                                    value = transformationList[k];\n                                    if (isArray_root_isArray_default()(value) && !isEmpty(value) || !isArray_root_isArray_default()(value) && value) {\n                                        results.push(value);\n                                    }\n                                }\n                                return results;\n                            }();\n                            transformationList = vars.sort().concat(variables).concat(transformationList.sort());\n                            if (ifParam === \"if_end\") {\n                                transformationList.push(ifParam);\n                            } else if (!isEmpty(ifParam)) {\n                                transformationList.unshift(ifParam);\n                            }\n                            transformationString = compact_root_compact_default()(transformationList).join(this.param_separator);\n                            if (!isEmpty(transformationString)) {\n                                resultArray.push(transformationString);\n                            }\n                            return compact_root_compact_default()(resultArray).join(this.trans_separator);\n                        }\n                    },\n                    {\n                        key: \"toHtmlAttributes\",\n                        value: /**\n     * Returns the attributes for an HTML tag.\n     * @function Cloudinary.toHtmlAttributes\n     * @return PlainObject\n     */ function toHtmlAttributes() {\n                            var _this2 = this;\n                            var attrName, height, options, ref2, ref3, value, width;\n                            options = {};\n                            var snakeCaseKey;\n                            Object.keys(this.otherOptions).forEach(function(key) {\n                                value = _this2.otherOptions[key];\n                                snakeCaseKey = snakeCase(key);\n                                if (!includes_root_includes_default()(transformation_Transformation.PARAM_NAMES, snakeCaseKey) && !includes_root_includes_default()(URL_KEYS, snakeCaseKey)) {\n                                    attrName = /^html_/.test(key) ? key.slice(5) : key;\n                                    options[attrName] = value;\n                                }\n                            });\n                            // convert all \"html_key\" to \"key\" with the same value\n                            this.keys().forEach(function(key) {\n                                if (/^html_/.test(key)) {\n                                    options[camelCase(key.slice(5))] = _this2.getValue(key);\n                                }\n                            });\n                            if (!(this.hasLayer() || this.getValue(\"angle\") || includes_root_includes_default()([\n                                \"fit\",\n                                \"limit\",\n                                \"lfill\"\n                            ], this.getValue(\"crop\")))) {\n                                width = (ref2 = this.get(\"width\")) != null ? ref2.origValue : void 0;\n                                height = (ref3 = this.get(\"height\")) != null ? ref3.origValue : void 0;\n                                if (parseFloat(width) >= 1.0) {\n                                    if (options.width == null) {\n                                        options.width = width;\n                                    }\n                                }\n                                if (parseFloat(height) >= 1.0) {\n                                    if (options.height == null) {\n                                        options.height = height;\n                                    }\n                                }\n                            }\n                            return options;\n                        }\n                    },\n                    {\n                        key: \"toHtml\",\n                        value: /**\n     * Delegate to the parent (up the call chain) to produce HTML\n     * @function Transformation#toHtml\n     * @return {string} HTML representation of the parent if possible.\n     * @example\n     * tag = cloudinary.ImageTag.new(\"sample\", {cloud_name: \"demo\"})\n     * // ImageTag {name: \"img\", publicId: \"sample\"}\n     * tag.toHtml()\n     * // <img src=\"http://res.cloudinary.com/demo/image/upload/sample\">\n     * tag.transformation().crop(\"fit\").width(300).toHtml()\n     * // <img src=\"http://res.cloudinary.com/demo/image/upload/c_fit,w_300/sample\">\n     */ function toHtml() {\n                            var ref;\n                            return (ref = this.getParent()) != null ? typeof ref.toHtml === \"function\" ? ref.toHtml() : void 0 : void 0;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            return this.serialize();\n                        }\n                    },\n                    {\n                        key: \"clone\",\n                        value: function clone() {\n                            return new this.constructor(this.toOptions(true));\n                        }\n                    }\n                ], [\n                    {\n                        key: \"listNames\",\n                        value: function listNames() {\n                            return transformation_Transformation.methods;\n                        }\n                    },\n                    {\n                        key: \"isValidParamName\",\n                        value: function isValidParamName(name) {\n                            return transformation_Transformation.methods.indexOf(camelCase(name)) >= 0;\n                        }\n                    }\n                ]);\n            }();\n            var VAR_NAME_RE = /^\\$[a-zA-Z0-9]+$/;\n            transformation_TransformationBase.prototype.trans_separator = \"/\";\n            transformation_TransformationBase.prototype.param_separator = \",\";\n            function lastArgCallback(args) {\n                var callback;\n                callback = args != null ? args[args.length - 1] : void 0;\n                if (isFunction_root_isFunction_default()(callback)) {\n                    return callback;\n                } else {\n                    return void 0;\n                }\n            }\n            function processVar(varArray) {\n                var j, len, name, results, v;\n                if (isArray_root_isArray_default()(varArray)) {\n                    results = [];\n                    for(j = 0, len = varArray.length; j < len; j++){\n                        var _varArray$j = transformation_slicedToArray(varArray[j], 2);\n                        name = _varArray$j[0];\n                        v = _varArray$j[1];\n                        results.push(\"\".concat(name, \"_\").concat(expression.normalize(v)));\n                    }\n                    return results;\n                } else {\n                    return varArray;\n                }\n            }\n            function processCustomFunction(_ref) {\n                var function_type = _ref.function_type, source = _ref.source;\n                if (function_type === \"remote\") {\n                    return [\n                        function_type,\n                        btoa(source)\n                    ].join(\":\");\n                } else if (function_type === \"wasm\") {\n                    return [\n                        function_type,\n                        source\n                    ].join(\":\");\n                }\n            }\n            /**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n * @const Transformation.methods\n * @private\n * @ignore\n * @type {Array<string>}\n */ /**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n * @const {Array<string>} Transformation.PARAM_NAMES\n * @private\n * @ignore\n * @see toHtmlAttributes\n */ var transformation_Transformation = /*#__PURE__*/ function(_TransformationBase) {\n                /**\n   * Represents a single transformation.\n   * @class Transformation\n   * @example\n   * t = new cloudinary.Transformation();\n   * t.angle(20).crop(\"scale\").width(\"auto\");\n   *\n   * // or\n   *\n   * t = new cloudinary.Transformation( {angle: 20, crop: \"scale\", width: \"auto\"});\n   * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\"\n   *  target=\"_blank\">Available image transformations</a>\n   * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\"\n   *  target=\"_blank\">Available video transformations</a>\n   */ function Transformation(options) {\n                    transformation_classCallCheck(this, Transformation);\n                    return transformation_callSuper(this, Transformation, [\n                        options\n                    ]);\n                }\n                /**\n   * Convenience constructor\n   * @param {Object} options\n   * @return {Transformation}\n   * @example cl = cloudinary.Transformation.new( {angle: 20, crop: \"scale\", width: \"auto\"})\n   */ transformation_inherits(Transformation, _TransformationBase);\n                return transformation_createClass(Transformation, [\n                    {\n                        key: \"angle\",\n                        value: /*\n      Transformation Parameters\n    */ function angle(value) {\n                            return this.arrayParam(value, \"angle\", \"a\", \".\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"audioCodec\",\n                        value: function audioCodec(value) {\n                            return this.param(value, \"audio_codec\", \"ac\");\n                        }\n                    },\n                    {\n                        key: \"audioFrequency\",\n                        value: function audioFrequency(value) {\n                            return this.param(value, \"audio_frequency\", \"af\");\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio(value) {\n                            return this.param(value, \"aspect_ratio\", \"ar\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"background\",\n                        value: function background(value) {\n                            return this.param(value, \"background\", \"b\", parameters_Param.norm_color);\n                        }\n                    },\n                    {\n                        key: \"bitRate\",\n                        value: function bitRate(value) {\n                            return this.param(value, \"bit_rate\", \"br\");\n                        }\n                    },\n                    {\n                        key: \"border\",\n                        value: function border(value) {\n                            return this.param(value, \"border\", \"bo\", function(border) {\n                                if (isPlainObject_root_isPlainObject_default()(border)) {\n                                    border = assign_root_assign_default()({}, {\n                                        color: \"black\",\n                                        width: 2\n                                    }, border);\n                                    return \"\".concat(border.width, \"px_solid_\").concat(parameters_Param.norm_color(border.color));\n                                } else {\n                                    return border;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"color\",\n                        value: function color(value) {\n                            return this.param(value, \"color\", \"co\", parameters_Param.norm_color);\n                        }\n                    },\n                    {\n                        key: \"colorSpace\",\n                        value: function colorSpace(value) {\n                            return this.param(value, \"color_space\", \"cs\");\n                        }\n                    },\n                    {\n                        key: \"crop\",\n                        value: function crop(value) {\n                            return this.param(value, \"crop\", \"c\");\n                        }\n                    },\n                    {\n                        key: \"customFunction\",\n                        value: function customFunction(value) {\n                            return this.param(value, \"custom_function\", \"fn\", function() {\n                                return processCustomFunction(value);\n                            });\n                        }\n                    },\n                    {\n                        key: \"customPreFunction\",\n                        value: function customPreFunction(value) {\n                            if (this.get(\"custom_function\")) {\n                                return;\n                            }\n                            return this.rawParam(value, \"custom_function\", \"\", function() {\n                                value = processCustomFunction(value);\n                                return value ? \"fn_pre:\".concat(value) : value;\n                            });\n                        }\n                    },\n                    {\n                        key: \"defaultImage\",\n                        value: function defaultImage(value) {\n                            return this.param(value, \"default_image\", \"d\");\n                        }\n                    },\n                    {\n                        key: \"delay\",\n                        value: function delay(value) {\n                            return this.param(value, \"delay\", \"dl\");\n                        }\n                    },\n                    {\n                        key: \"density\",\n                        value: function density(value) {\n                            return this.param(value, \"density\", \"dn\");\n                        }\n                    },\n                    {\n                        key: \"duration\",\n                        value: function duration(value) {\n                            return this.rangeParam(value, \"duration\", \"du\");\n                        }\n                    },\n                    {\n                        key: \"dpr\",\n                        value: function dpr(value) {\n                            return this.param(value, \"dpr\", \"dpr\", function(dpr) {\n                                dpr = dpr.toString();\n                                if (dpr != null ? dpr.match(/^\\d+$/) : void 0) {\n                                    return dpr + \".0\";\n                                } else {\n                                    return expression.normalize(dpr);\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"effect\",\n                        value: function effect(value) {\n                            return this.arrayParam(value, \"effect\", \"e\", \":\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"else\",\n                        value: function _else() {\n                            return this[\"if\"](\"else\");\n                        }\n                    },\n                    {\n                        key: \"endIf\",\n                        value: function endIf() {\n                            return this[\"if\"](\"end\");\n                        }\n                    },\n                    {\n                        key: \"endOffset\",\n                        value: function endOffset(value) {\n                            return this.rangeParam(value, \"end_offset\", \"eo\");\n                        }\n                    },\n                    {\n                        key: \"fallbackContent\",\n                        value: function fallbackContent(value) {\n                            return this.param(value, \"fallback_content\");\n                        }\n                    },\n                    {\n                        key: \"fetchFormat\",\n                        value: function fetchFormat(value) {\n                            return this.param(value, \"fetch_format\", \"f\");\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(value) {\n                            return this.param(value, \"format\");\n                        }\n                    },\n                    {\n                        key: \"flags\",\n                        value: function flags(value) {\n                            return this.arrayParam(value, \"flags\", \"fl\", \".\");\n                        }\n                    },\n                    {\n                        key: \"gravity\",\n                        value: function gravity(value) {\n                            return this.param(value, \"gravity\", \"g\");\n                        }\n                    },\n                    {\n                        key: \"fps\",\n                        value: function fps(value) {\n                            return this.param(value, \"fps\", \"fps\", function(fps) {\n                                if (isString_root_isString_default()(fps)) {\n                                    return fps;\n                                } else if (isArray_root_isArray_default()(fps)) {\n                                    return fps.join(\"-\");\n                                } else {\n                                    return fps;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"height\",\n                        value: function height(value) {\n                            var _this3 = this;\n                            return this.param(value, \"height\", \"h\", function() {\n                                if (_this3.getValue(\"crop\") || _this3.getValue(\"overlay\") || _this3.getValue(\"underlay\")) {\n                                    return expression.normalize(value);\n                                } else {\n                                    return null;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"htmlHeight\",\n                        value: function htmlHeight(value) {\n                            return this.param(value, \"html_height\");\n                        }\n                    },\n                    {\n                        key: \"htmlWidth\",\n                        value: function htmlWidth(value) {\n                            return this.param(value, \"html_width\");\n                        }\n                    },\n                    {\n                        key: \"if\",\n                        value: function _if() {\n                            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n                            var i, ifVal, j, ref, trIf, trRest;\n                            switch(value){\n                                case \"else\":\n                                    this.chain();\n                                    return this.param(value, \"if\", \"if\");\n                                case \"end\":\n                                    this.chain();\n                                    for(i = j = ref = this.chained.length - 1; j >= 0; i = j += -1){\n                                        ifVal = this.chained[i].getValue(\"if\");\n                                        if (ifVal === \"end\") {\n                                            break;\n                                        } else if (ifVal != null) {\n                                            trIf = Transformation[\"new\"]()[\"if\"](ifVal);\n                                            this.chained[i].remove(\"if\");\n                                            trRest = this.chained[i];\n                                            this.chained[i] = Transformation[\"new\"]().transformation([\n                                                trIf,\n                                                trRest\n                                            ]);\n                                            if (ifVal !== \"else\") {\n                                                break;\n                                            }\n                                        }\n                                    }\n                                    return this.param(value, \"if\", \"if\");\n                                case \"\":\n                                    return condition[\"new\"]().setParent(this);\n                                default:\n                                    return this.param(value, \"if\", \"if\", function(value) {\n                                        return condition[\"new\"](value).toString();\n                                    });\n                            }\n                        }\n                    },\n                    {\n                        key: \"keyframeInterval\",\n                        value: function keyframeInterval(value) {\n                            return this.param(value, \"keyframe_interval\", \"ki\");\n                        }\n                    },\n                    {\n                        key: \"ocr\",\n                        value: function ocr(value) {\n                            return this.param(value, \"ocr\", \"ocr\");\n                        }\n                    },\n                    {\n                        key: \"offset\",\n                        value: function offset(value) {\n                            var end_o, start_o;\n                            var _ref2 = isFunction_root_isFunction_default()(value != null ? value.split : void 0) ? value.split(\"..\") : isArray_root_isArray_default()(value) ? value : [\n                                null,\n                                null\n                            ];\n                            var _ref3 = transformation_slicedToArray(_ref2, 2);\n                            start_o = _ref3[0];\n                            end_o = _ref3[1];\n                            if (start_o != null) {\n                                this.startOffset(start_o);\n                            }\n                            if (end_o != null) {\n                                return this.endOffset(end_o);\n                            }\n                        }\n                    },\n                    {\n                        key: \"opacity\",\n                        value: function opacity(value) {\n                            return this.param(value, \"opacity\", \"o\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"overlay\",\n                        value: function overlay(value) {\n                            return this.layerParam(value, \"overlay\", \"l\");\n                        }\n                    },\n                    {\n                        key: \"page\",\n                        value: function page(value) {\n                            return this.param(value, \"page\", \"pg\");\n                        }\n                    },\n                    {\n                        key: \"poster\",\n                        value: function poster(value) {\n                            return this.param(value, \"poster\");\n                        }\n                    },\n                    {\n                        key: \"prefix\",\n                        value: function prefix(value) {\n                            return this.param(value, \"prefix\", \"p\");\n                        }\n                    },\n                    {\n                        key: \"quality\",\n                        value: function quality(value) {\n                            return this.param(value, \"quality\", \"q\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"radius\",\n                        value: function radius(value) {\n                            return this.arrayParam(value, \"radius\", \"r\", \":\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"rawTransformation\",\n                        value: function rawTransformation(value) {\n                            return this.rawParam(value, \"raw_transformation\");\n                        }\n                    },\n                    {\n                        key: \"size\",\n                        value: function size(value) {\n                            var height, width;\n                            if (isFunction_root_isFunction_default()(value != null ? value.split : void 0)) {\n                                var _value$split = value.split(\"x\");\n                                var _value$split2 = transformation_slicedToArray(_value$split, 2);\n                                width = _value$split2[0];\n                                height = _value$split2[1];\n                                this.width(width);\n                                return this.height(height);\n                            }\n                        }\n                    },\n                    {\n                        key: \"sourceTypes\",\n                        value: function sourceTypes(value) {\n                            return this.param(value, \"source_types\");\n                        }\n                    },\n                    {\n                        key: \"sourceTransformation\",\n                        value: function sourceTransformation(value) {\n                            return this.param(value, \"source_transformation\");\n                        }\n                    },\n                    {\n                        key: \"startOffset\",\n                        value: function startOffset(value) {\n                            return this.rangeParam(value, \"start_offset\", \"so\");\n                        }\n                    },\n                    {\n                        key: \"streamingProfile\",\n                        value: function streamingProfile(value) {\n                            return this.param(value, \"streaming_profile\", \"sp\");\n                        }\n                    },\n                    {\n                        key: \"transformation\",\n                        value: function transformation(value) {\n                            return this.transformationParam(value, \"transformation\", \"t\");\n                        }\n                    },\n                    {\n                        key: \"underlay\",\n                        value: function underlay(value) {\n                            return this.layerParam(value, \"underlay\", \"u\");\n                        }\n                    },\n                    {\n                        key: \"variable\",\n                        value: function variable(name, value) {\n                            return this.param(value, name, name);\n                        }\n                    },\n                    {\n                        key: \"variables\",\n                        value: function variables(values) {\n                            return this.arrayParam(values, \"variables\");\n                        }\n                    },\n                    {\n                        key: \"videoCodec\",\n                        value: function videoCodec(value) {\n                            return this.param(value, \"video_codec\", \"vc\", parameters_Param.process_video_params);\n                        }\n                    },\n                    {\n                        key: \"videoSampling\",\n                        value: function videoSampling(value) {\n                            return this.param(value, \"video_sampling\", \"vs\");\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width(value) {\n                            var _this4 = this;\n                            return this.param(value, \"width\", \"w\", function() {\n                                if (_this4.getValue(\"crop\") || _this4.getValue(\"overlay\") || _this4.getValue(\"underlay\")) {\n                                    return expression.normalize(value);\n                                } else {\n                                    return null;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"x\",\n                        value: function x(value) {\n                            return this.param(value, \"x\", \"x\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"y\",\n                        value: function y(value) {\n                            return this.param(value, \"y\", \"y\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"zoom\",\n                        value: function zoom(value) {\n                            return this.param(value, \"zoom\", \"z\", expression.normalize);\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(options) {\n                            return new Transformation(options);\n                        }\n                    }\n                ]);\n            }(transformation_TransformationBase);\n            /**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n */ transformation_Transformation.methods = [\n                \"angle\",\n                \"audioCodec\",\n                \"audioFrequency\",\n                \"aspectRatio\",\n                \"background\",\n                \"bitRate\",\n                \"border\",\n                \"color\",\n                \"colorSpace\",\n                \"crop\",\n                \"customFunction\",\n                \"customPreFunction\",\n                \"defaultImage\",\n                \"delay\",\n                \"density\",\n                \"duration\",\n                \"dpr\",\n                \"effect\",\n                \"else\",\n                \"endIf\",\n                \"endOffset\",\n                \"fallbackContent\",\n                \"fetchFormat\",\n                \"format\",\n                \"flags\",\n                \"gravity\",\n                \"fps\",\n                \"height\",\n                \"htmlHeight\",\n                \"htmlWidth\",\n                \"if\",\n                \"keyframeInterval\",\n                \"ocr\",\n                \"offset\",\n                \"opacity\",\n                \"overlay\",\n                \"page\",\n                \"poster\",\n                \"prefix\",\n                \"quality\",\n                \"radius\",\n                \"rawTransformation\",\n                \"size\",\n                \"sourceTypes\",\n                \"sourceTransformation\",\n                \"startOffset\",\n                \"streamingProfile\",\n                \"transformation\",\n                \"underlay\",\n                \"variable\",\n                \"variables\",\n                \"videoCodec\",\n                \"videoSampling\",\n                \"width\",\n                \"x\",\n                \"y\",\n                \"zoom\"\n            ];\n            /**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n */ transformation_Transformation.PARAM_NAMES = transformation_Transformation.methods.map(snakeCase).concat(src_configuration.CONFIG_PARAMS);\n            /* harmony default export */ var src_transformation = transformation_Transformation;\n            // CONCATENATED MODULE: ./src/tags/htmltag.js\n            function htmltag_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return htmltag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, htmltag_typeof(o);\n            }\n            function htmltag_classCallCheck(a, n) {\n                if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n            function htmltag_defineProperties(e, r) {\n                for(var t = 0; t < r.length; t++){\n                    var o = r[t];\n                    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, htmltag_toPropertyKey(o.key), o);\n                }\n            }\n            function htmltag_createClass(e, r, t) {\n                return r && htmltag_defineProperties(e.prototype, r), t && htmltag_defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n                    writable: !1\n                }), e;\n            }\n            function htmltag_toPropertyKey(t) {\n                var i = htmltag_toPrimitive(t, \"string\");\n                return \"symbol\" == htmltag_typeof(i) ? i : i + \"\";\n            }\n            function htmltag_toPrimitive(t, r) {\n                if (\"object\" != htmltag_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != htmltag_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            /**\n * Generic HTML tag\n * Depends on 'transformation', 'util'\n */ /**\n * Represents an HTML (DOM) tag\n * @constructor HtmlTag\n * @param {string} name - the name of the tag\n * @param {string} [publicId]\n * @param {Object} options\n * @example tag = new HtmlTag( 'div', { 'width': 10})\n */ var htmltag_HtmlTag = /*#__PURE__*/ function() {\n                function HtmlTag(name, publicId, options) {\n                    htmltag_classCallCheck(this, HtmlTag);\n                    var transformation;\n                    this.name = name;\n                    this.publicId = publicId;\n                    if (options == null) {\n                        if (isPlainObject_root_isPlainObject_default()(publicId)) {\n                            options = publicId;\n                            this.publicId = void 0;\n                        } else {\n                            options = {};\n                        }\n                    }\n                    transformation = new src_transformation(options);\n                    transformation.setParent(this);\n                    this.transformation = function() {\n                        return transformation;\n                    };\n                }\n                /**\n   * Convenience constructor\n   * Creates a new instance of an HTML (DOM) tag\n   * @function HtmlTag.new\n   * @param {string} name - the name of the tag\n   * @param {string} [publicId]\n   * @param {Object} options\n   * @return {HtmlTag}\n   * @example tag = HtmlTag.new( 'div', { 'width': 10})\n   */ return htmltag_createClass(HtmlTag, [\n                    {\n                        key: \"htmlAttrs\",\n                        value: /**\n     * combine key and value from the `attr` to generate an HTML tag attributes string.\n     * `Transformation::toHtmlTagOptions` is used to filter out transformation and configuration keys.\n     * @protected\n     * @param {Object} attrs\n     * @return {string} the attributes in the format `'key1=\"value1\" key2=\"value2\"'`\n     * @ignore\n     */ function htmlAttrs(attrs) {\n                            var key, pairs, value;\n                            return pairs = (function() {\n                                var results;\n                                results = [];\n                                for(key in attrs){\n                                    value = escapeQuotes(attrs[key]);\n                                    if (value) {\n                                        results.push(htmltag_toAttribute(key, value));\n                                    }\n                                }\n                                return results;\n                            })().sort().join(\" \");\n                        }\n                    },\n                    {\n                        key: \"getOptions\",\n                        value: function getOptions() {\n                            return this.transformation().toOptions();\n                        }\n                    },\n                    {\n                        key: \"getOption\",\n                        value: function getOption(name) {\n                            return this.transformation().getValue(name);\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            // The attributes are be computed from the options every time this method is invoked.\n                            var htmlAttributes = this.transformation().toHtmlAttributes();\n                            Object.keys(htmlAttributes).forEach(function(key) {\n                                if (isPlainObject_root_isPlainObject_default()(htmlAttributes[key])) {\n                                    delete htmlAttributes[key];\n                                }\n                            });\n                            if (htmlAttributes.attributes) {\n                                // Currently HTML attributes are defined both at the top level and under 'attributes'\n                                merge_root_merge_default()(htmlAttributes, htmlAttributes.attributes);\n                                delete htmlAttributes.attributes;\n                            }\n                            return htmlAttributes;\n                        }\n                    },\n                    {\n                        key: \"setAttr\",\n                        value: function setAttr(name, value) {\n                            this.transformation().set(\"html_\".concat(name), value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"getAttr\",\n                        value: function getAttr(name) {\n                            return this.attributes()[\"html_\".concat(name)] || this.attributes()[name];\n                        }\n                    },\n                    {\n                        key: \"removeAttr\",\n                        value: function removeAttr(name) {\n                            var ref;\n                            return (ref = this.transformation().remove(\"html_\".concat(name))) != null ? ref : this.transformation().remove(name);\n                        }\n                    },\n                    {\n                        key: \"content\",\n                        value: function content() {\n                            return \"\";\n                        }\n                    },\n                    {\n                        key: \"openTag\",\n                        value: function openTag() {\n                            var tag = \"<\" + this.name;\n                            var htmlAttrs = this.htmlAttrs(this.attributes());\n                            if (htmlAttrs && htmlAttrs.length > 0) {\n                                tag += \" \" + htmlAttrs;\n                            }\n                            return tag + \">\";\n                        }\n                    },\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"</\".concat(this.name, \">\");\n                        }\n                    },\n                    {\n                        key: \"toHtml\",\n                        value: function toHtml() {\n                            return this.openTag() + this.content() + this.closeTag();\n                        }\n                    },\n                    {\n                        key: \"toDOM\",\n                        value: function toDOM() {\n                            var element, name, ref, value;\n                            if (!isFunction_root_isFunction_default()(typeof document !== \"undefined\" && document !== null ? document.createElement : void 0)) {\n                                throw \"Can't create DOM if document is not present!\";\n                            }\n                            element = document.createElement(this.name);\n                            ref = this.attributes();\n                            for(name in ref){\n                                value = ref[name];\n                                element.setAttribute(name, value);\n                            }\n                            return element;\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(name, publicId, options) {\n                            return new this(name, publicId, options);\n                        }\n                    },\n                    {\n                        key: \"isResponsive\",\n                        value: function isResponsive(tag, responsiveClass) {\n                            var dataSrc;\n                            dataSrc = lodash_getData(tag, \"src-cache\") || lodash_getData(tag, \"src\");\n                            return lodash_hasClass(tag, responsiveClass) && /\\bw_auto\\b/.exec(dataSrc);\n                        }\n                    }\n                ]);\n            }();\n            ;\n            /**\n * Represent the given key and value as an HTML attribute.\n * @function toAttribute\n * @protected\n * @param {string} key - attribute name\n * @param {*|boolean} value - the value of the attribute. If the value is boolean `true`, return the key only.\n * @returns {string} the attribute\n *\n */ function htmltag_toAttribute(key, value) {\n                if (!value) {\n                    return void 0;\n                } else if (value === true) {\n                    return key;\n                } else {\n                    return \"\".concat(key, '=\"').concat(value, '\"');\n                }\n            }\n            /**\n * If given value is a string, replaces quotes with character entities (&#34;, &#39;)\n * @param value - value to change\n * @returns {*} changed value\n */ function escapeQuotes(value) {\n                return isString_root_isString_default()(value) ? value.replace('\"', \"&#34;\").replace(\"'\", \"&#39;\") : value;\n            }\n            /* harmony default export */ var htmltag = htmltag_HtmlTag;\n            // CONCATENATED MODULE: ./src/url.js\n            var _excluded = [\n                \"placeholder\",\n                \"accessibility\"\n            ];\n            function _objectWithoutProperties(e, t) {\n                if (null == e) return {};\n                var o, r, i = _objectWithoutPropertiesLoose(e, t);\n                if (Object.getOwnPropertySymbols) {\n                    var n = Object.getOwnPropertySymbols(e);\n                    for(r = 0; r < n.length; r++)o = n[r], -1 === t.indexOf(o) && ({}).propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n                }\n                return i;\n            }\n            function _objectWithoutPropertiesLoose(r, e) {\n                if (null == r) return {};\n                var t = {};\n                for(var n in r)if (({}).hasOwnProperty.call(r, n)) {\n                    if (-1 !== e.indexOf(n)) continue;\n                    t[n] = r[n];\n                }\n                return t;\n            }\n            /**\n * Adds protocol, host, pathname prefixes to given string\n * @param str\n * @returns {string}\n */ function makeUrl(str) {\n                var prefix = document.location.protocol + \"//\" + document.location.host;\n                if (str[0] === \"?\") {\n                    prefix += document.location.pathname;\n                } else if (str[0] !== \"/\") {\n                    prefix += document.location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n                }\n                return prefix + str;\n            }\n            /**\n * Check is given string is a url\n * @param str\n * @returns {boolean}\n */ function isUrl(str) {\n                return str ? !!str.match(/^https?:\\//) : false;\n            }\n            // Produce a number between 1 and 5 to be used for cdn sub domains designation\n            function cdnSubdomainNumber(publicId) {\n                return src_crc32(publicId) % 5 + 1;\n            }\n            /**\n * Removes signature from options and returns the signature\n * Makes sure signature is empty or of this format: s--signature--\n * @param {object} options\n * @returns {string} the formatted signature\n */ function handleSignature(options) {\n                var signature = options.signature;\n                var isFormatted = !signature || signature.indexOf(\"s--\") === 0 && signature.substr(-2) === \"--\";\n                delete options.signature;\n                return isFormatted ? signature : \"s--\".concat(signature, \"--\");\n            }\n            /**\n * Create the URL prefix for Cloudinary resources.\n * @param {string} publicId the resource public ID\n * @param {object} options additional options\n * @param {string} options.cloud_name - the cloud name.\n * @param {boolean} [options.cdn_subdomain=false] - Whether to automatically build URLs with\n *  multiple CDN sub-domains.\n * @param {string} [options.private_cdn] - Boolean (default: false). Should be set to true for Advanced plan's users\n *  that have a private CDN distribution.\n * @param {string} [options.protocol=\"http://\"] - the URI protocol to use. If options.secure is true,\n *  the value is overridden to \"https://\"\n * @param {string} [options.secure_distribution] - The domain name of the CDN distribution to use for building HTTPS URLs.\n *  Relevant only for Advanced plan's users that have a private CDN distribution.\n * @param {string} [options.cname] - Custom domain name to use for building HTTP URLs.\n *  Relevant only for Advanced plan's users that have a private CDN distribution and a custom CNAME.\n * @param {boolean} [options.secure_cdn_subdomain=true] - When options.secure is true and this parameter is false,\n *  the subdomain is set to \"res\".\n * @param {boolean} [options.secure=false] - Force HTTPS URLs of images even if embedded in non-secure HTTP pages.\n *  When this value is true, options.secure_distribution will be used as host if provided, and options.protocol is set\n *  to \"https://\".\n * @returns {string} the URL prefix for the resource.\n * @private\n */ function handlePrefix(publicId, options) {\n                if (options.cloud_name && options.cloud_name[0] === \"/\") {\n                    return \"/res\" + options.cloud_name;\n                }\n                // defaults\n                var protocol = \"http://\";\n                var cdnPart = \"\";\n                var subdomain = \"res\";\n                var host = \".cloudinary.com\";\n                var path = \"/\" + options.cloud_name;\n                // modifications\n                if (options.protocol) {\n                    protocol = options.protocol + \"//\";\n                }\n                if (options.private_cdn) {\n                    cdnPart = options.cloud_name + \"-\";\n                    path = \"\";\n                }\n                if (options.cdn_subdomain) {\n                    subdomain = \"res-\" + cdnSubdomainNumber(publicId);\n                }\n                if (options.secure) {\n                    protocol = \"https://\";\n                    if (options.secure_cdn_subdomain === false) {\n                        subdomain = \"res\";\n                    }\n                    if (options.secure_distribution != null && options.secure_distribution !== OLD_AKAMAI_SHARED_CDN && options.secure_distribution !== SHARED_CDN) {\n                        cdnPart = \"\";\n                        subdomain = \"\";\n                        host = options.secure_distribution;\n                    }\n                } else if (options.cname) {\n                    protocol = \"http://\";\n                    cdnPart = \"\";\n                    subdomain = options.cdn_subdomain ? \"a\" + (src_crc32(publicId) % 5 + 1) + \".\" : \"\";\n                    host = options.cname;\n                }\n                return [\n                    protocol,\n                    cdnPart,\n                    subdomain,\n                    host,\n                    path\n                ].join(\"\");\n            }\n            /**\n * Return the resource type and action type based on the given configuration\n * @function Cloudinary#handleResourceType\n * @param {Object|string} resource_type\n * @param {string} [type='upload']\n * @param {string} [url_suffix]\n * @param {boolean} [use_root_path]\n * @param {boolean} [shorten]\n * @returns {string} resource_type/type\n * @ignore\n */ function handleResourceType(_ref) {\n                var _ref$resource_type = _ref.resource_type, resource_type = _ref$resource_type === void 0 ? \"image\" : _ref$resource_type, _ref$type = _ref.type, type = _ref$type === void 0 ? \"upload\" : _ref$type, url_suffix = _ref.url_suffix, use_root_path = _ref.use_root_path, shorten = _ref.shorten;\n                var options, resourceType = resource_type;\n                if (isPlainObject_root_isPlainObject_default()(resourceType)) {\n                    options = resourceType;\n                    resourceType = options.resource_type;\n                    type = options.type;\n                    shorten = options.shorten;\n                }\n                if (type == null) {\n                    type = \"upload\";\n                }\n                if (url_suffix != null) {\n                    resourceType = SEO_TYPES[\"\".concat(resourceType, \"/\").concat(type)];\n                    type = null;\n                    if (resourceType == null) {\n                        throw new Error(\"URL Suffix only supported for \".concat(Object.keys(SEO_TYPES).join(\", \")));\n                    }\n                }\n                if (use_root_path) {\n                    if (resourceType === \"image\" && type === \"upload\" || resourceType === \"images\") {\n                        resourceType = null;\n                        type = null;\n                    } else {\n                        throw new Error(\"Root path only supported for image/upload\");\n                    }\n                }\n                if (shorten && resourceType === \"image\" && type === \"upload\") {\n                    resourceType = \"iu\";\n                    type = null;\n                }\n                return [\n                    resourceType,\n                    type\n                ].join(\"/\");\n            }\n            /**\n * Encode publicId\n * @param publicId\n * @returns {string} encoded publicId\n */ function encodePublicId(publicId) {\n                return encodeURIComponent(publicId).replace(/%3A/g, \":\").replace(/%2F/g, \"/\");\n            }\n            /**\n * Encode and format publicId\n * @param publicId\n * @param options\n * @returns {string} publicId\n */ function formatPublicId(publicId, options) {\n                if (isUrl(publicId)) {\n                    publicId = encodePublicId(publicId);\n                } else {\n                    try {\n                        // Make sure publicId is URI encoded.\n                        publicId = decodeURIComponent(publicId);\n                    } catch (error) {}\n                    publicId = encodePublicId(publicId);\n                    if (options.url_suffix) {\n                        publicId = publicId + \"/\" + options.url_suffix;\n                    }\n                    if (options.format) {\n                        if (!options.trust_public_id) {\n                            publicId = publicId.replace(/\\.(jpg|png|gif|webp)$/, \"\");\n                        }\n                        publicId = publicId + \".\" + options.format;\n                    }\n                }\n                return publicId;\n            }\n            /**\n * Get any error with url options\n * @param options\n * @returns {string} if error, otherwise return undefined\n */ function validate(options) {\n                var cloud_name = options.cloud_name, url_suffix = options.url_suffix;\n                if (!cloud_name) {\n                    return \"Unknown cloud_name\";\n                }\n                if (url_suffix && url_suffix.match(/[\\.\\/]/)) {\n                    return \"url_suffix should not include . or /\";\n                }\n            }\n            /**\n * Get version part of the url\n * @param publicId\n * @param options\n * @returns {string}\n */ function handleVersion(publicId, options) {\n                // force_version param means to make sure there is a version in the url (Default is true)\n                var isForceVersion = options.force_version || typeof options.force_version === \"undefined\";\n                // Is version included in publicId or in options, or publicId is a url (doesn't need version)\n                var isVersionExist = publicId.indexOf(\"/\") < 0 || publicId.match(/^v[0-9]+/) || isUrl(publicId) || options.version;\n                if (isForceVersion && !isVersionExist) {\n                    options.version = 1;\n                }\n                return options.version ? \"v\".concat(options.version) : \"\";\n            }\n            /**\n * Get final transformation component for url string\n * @param options\n * @returns {string}\n */ function handleTransformation(options) {\n                var _ref2 = options || {}, placeholder = _ref2.placeholder, accessibility = _ref2.accessibility, otherOptions = _objectWithoutProperties(_ref2, _excluded);\n                var result = new src_transformation(otherOptions);\n                // Append accessibility transformations\n                if (accessibility && ACCESSIBILITY_MODES[accessibility]) {\n                    result.chain().effect(ACCESSIBILITY_MODES[accessibility]);\n                }\n                // Append placeholder transformations\n                if (placeholder) {\n                    if (placeholder === \"predominant-color\" && result.getValue(\"width\") && result.getValue(\"height\")) {\n                        placeholder += \"-pixel\";\n                    }\n                    var placeholderTransformations = PLACEHOLDER_IMAGE_MODES[placeholder] || PLACEHOLDER_IMAGE_MODES.blur;\n                    placeholderTransformations.forEach(function(t) {\n                        return result.chain().transformation(t);\n                    });\n                }\n                return result.serialize();\n            }\n            /**\n * If type is 'fetch', update publicId to be a url\n * @param publicId\n * @param type\n * @returns {string}\n */ function preparePublicId(publicId, _ref3) {\n                var type = _ref3.type;\n                return !isUrl(publicId) && type === \"fetch\" ? makeUrl(publicId) : publicId;\n            }\n            /**\n * Generate url string\n * @param publicId\n * @param options\n * @returns {string} final url\n */ function urlString(publicId, options) {\n                if (isUrl(publicId) && (options.type === \"upload\" || options.type === \"asset\")) {\n                    return publicId;\n                }\n                var version = handleVersion(publicId, options);\n                var transformationString = handleTransformation(options);\n                var prefix = handlePrefix(publicId, options);\n                var signature = handleSignature(options);\n                var resourceType = handleResourceType(options);\n                publicId = formatPublicId(publicId, options);\n                return compact_root_compact_default()([\n                    prefix,\n                    resourceType,\n                    signature,\n                    transformationString,\n                    version,\n                    publicId\n                ]).join(\"/\").replace(/([^:])\\/+/g, \"$1/\") // replace '///' with '//'\n                .replace(\" \", \"%20\");\n            }\n            /**\n * Merge options and config with defaults\n * update options fetch_format according to 'type' param\n * @param options\n * @param config\n * @returns {*} updated options\n */ function prepareOptions(options, config) {\n                if (options instanceof src_transformation) {\n                    options = options.toOptions();\n                }\n                options = defaults({}, options, config, DEFAULT_IMAGE_PARAMS);\n                if (options.type === \"fetch\") {\n                    options.fetch_format = options.fetch_format || options.format;\n                }\n                return options;\n            }\n            /**\n * Generates a URL for any asset in your Media library.\n * @function url\n * @ignore\n * @param {string} publicId - The public ID of the media asset.\n * @param {Object} [options={}] - The {@link Transformation} parameters to include in the URL.\n * @param {object} [config={}] - URL configuration parameters\n * @param {type} [options.type='upload'] - The asset's storage type.\n *  For details on all fetch types, see\n * <a href=\"https://cloudinary.com/documentation/image_transformations#fetching_images_from_remote_locations\"\n *  target=\"_blank\">Fetch types</a>.\n * @param {Object} [options.resource_type='image'] - The type of asset. <p>Possible values:<br/>\n *  - `image`<br/>\n *  - `video`<br/>\n *  - `raw`\n * @param {signature} [options.signature='s--12345678--'] - The signature component of a\n *  signed delivery URL of the format: /s--SIGNATURE--/.\n *  For details on signatures, see\n * <a href=\"https://cloudinary.com/documentation/signatures\" target=\"_blank\">Signatures</a>.\n * @return {string} The media asset URL.\n * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\" target=\"_blank\">\n *  Available image transformations</a>\n * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\" target=\"_blank\">\n *  Available video transformations</a>\n */ function url_url(publicId) {\n                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                if (!publicId) {\n                    return publicId;\n                }\n                options = prepareOptions(options, config);\n                publicId = preparePublicId(publicId, options);\n                var error = validate(options);\n                if (error) {\n                    throw error;\n                }\n                var resultUrl = urlString(publicId, options);\n                if (options.urlAnalytics) {\n                    var analyticsOptions = getAnalyticsOptions(options);\n                    var sdkAnalyticsSignature = getSDKAnalyticsSignature(analyticsOptions);\n                    // url might already have a '?' query param\n                    var appender = \"?\";\n                    if (resultUrl.indexOf(\"?\") >= 0) {\n                        appender = \"&\";\n                    }\n                    resultUrl = \"\".concat(resultUrl).concat(appender, \"_a=\").concat(sdkAnalyticsSignature);\n                }\n                if (options.auth_token) {\n                    var _appender = resultUrl.indexOf(\"?\") >= 0 ? \"&\" : \"?\";\n                    resultUrl = \"\".concat(resultUrl).concat(_appender, \"__cld_token__=\").concat(options.auth_token);\n                }\n                return resultUrl;\n            }\n            ;\n            // CONCATENATED MODULE: ./src/util/generateBreakpoints.js\n            function generateBreakpoints_slicedToArray(r, e) {\n                return generateBreakpoints_arrayWithHoles(r) || generateBreakpoints_iterableToArrayLimit(r, e) || generateBreakpoints_unsupportedIterableToArray(r, e) || generateBreakpoints_nonIterableRest();\n            }\n            function generateBreakpoints_nonIterableRest() {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function generateBreakpoints_unsupportedIterableToArray(r, a) {\n                if (r) {\n                    if (\"string\" == typeof r) return generateBreakpoints_arrayLikeToArray(r, a);\n                    var t = ({}).toString.call(r).slice(8, -1);\n                    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? generateBreakpoints_arrayLikeToArray(r, a) : void 0;\n                }\n            }\n            function generateBreakpoints_arrayLikeToArray(r, a) {\n                (null == a || a > r.length) && (a = r.length);\n                for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];\n                return n;\n            }\n            function generateBreakpoints_iterableToArrayLimit(r, l) {\n                var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n                if (null != t) {\n                    var e, n, i, u, a = [], f = !0, o = !1;\n                    try {\n                        if (i = (t = t.call(r)).next, 0 === l) {\n                            if (Object(t) !== t) return;\n                            f = !1;\n                        } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n                    } catch (r) {\n                        o = !0, n = r;\n                    } finally{\n                        try {\n                            if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n                        } finally{\n                            if (o) throw n;\n                        }\n                    }\n                    return a;\n                }\n            }\n            function generateBreakpoints_arrayWithHoles(r) {\n                if (Array.isArray(r)) return r;\n            }\n            /**\n * Helper function. Gets or populates srcset breakpoints using provided parameters\n * Either the breakpoints or min_width, max_width, max_images must be provided.\n *\n * @private\n * @param {srcset} srcset Options with either `breakpoints` or `min_width`, `max_width`, and `max_images`\n *\n * @return {number[]} Array of breakpoints\n *\n */ function generateBreakpoints(srcset) {\n                var breakpoints = srcset.breakpoints || [];\n                if (breakpoints.length) {\n                    return breakpoints;\n                }\n                var _map = [\n                    srcset.min_width,\n                    srcset.max_width,\n                    srcset.max_images\n                ].map(Number), _map2 = generateBreakpoints_slicedToArray(_map, 3), min_width = _map2[0], max_width = _map2[1], max_images = _map2[2];\n                if ([\n                    min_width,\n                    max_width,\n                    max_images\n                ].some(isNaN)) {\n                    throw \"Either (min_width, max_width, max_images) \" + \"or breakpoints must be provided to the image srcset attribute\";\n                }\n                if (min_width > max_width) {\n                    throw \"min_width must be less than max_width\";\n                }\n                if (max_images <= 0) {\n                    throw \"max_images must be a positive integer\";\n                } else if (max_images === 1) {\n                    min_width = max_width;\n                }\n                var stepSize = Math.ceil((max_width - min_width) / Math.max(max_images - 1, 1));\n                for(var current = min_width; current < max_width; current += stepSize){\n                    breakpoints.push(current);\n                }\n                breakpoints.push(max_width);\n                return breakpoints;\n            }\n            // CONCATENATED MODULE: ./src/util/srcsetUtils.js\n            var srcsetUtils_isEmpty = isEmpty;\n            /**\n * Options used to generate the srcset attribute.\n * @typedef {object} srcset\n * @property {(number[]|string[])}   [breakpoints] An array of breakpoints.\n * @property {number}                [min_width]   Minimal width of the srcset images.\n * @property {number}                [max_width]   Maximal width of the srcset images.\n * @property {number}                [max_images]  Number of srcset images to generate.\n * @property {object|string}         [transformation] The transformation to use in the srcset urls.\n * @property {boolean}               [sizes] Whether to calculate and add the sizes attribute.\n */ /**\n * Helper function. Generates a single srcset item url\n *\n * @private\n * @param {string} public_id  Public ID of the resource.\n * @param {number} width      Width in pixels of the srcset item.\n * @param {object|string} transformation\n * @param {object} options    Additional options.\n *\n * @return {string} Resulting URL of the item\n */ function scaledUrl(public_id, width, transformation) {\n                var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n                var configParams = extractUrlParams(options);\n                transformation = transformation || options;\n                configParams.raw_transformation = new src_transformation([\n                    merge_root_merge_default.a({}, transformation),\n                    {\n                        crop: \"scale\",\n                        width: width\n                    }\n                ]).toString();\n                return url_url(public_id, configParams);\n            }\n            /**\n * If cache is enabled, get the breakpoints from the cache. If the values were not found in the cache,\n * or cache is not enabled, generate the values.\n * @param {srcset} srcset The srcset configuration parameters\n * @param {string} public_id\n * @param {object} options\n * @return {*|Array}\n */ function getOrGenerateBreakpoints(public_id) {\n                var srcset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                return generateBreakpoints(srcset);\n            }\n            /**\n * Helper function. Generates srcset attribute value of the HTML img tag\n * @private\n *\n * @param {string} public_id  Public ID of the resource\n * @param {number[]} breakpoints An array of breakpoints (in pixels)\n * @param {object} transformation The transformation\n * @param {object} options Includes html tag options, transformation options\n * @return {string} Resulting srcset attribute value\n */ function generateSrcsetAttribute(public_id, breakpoints, transformation, options) {\n                options = cloneDeep_root_cloneDeep_default.a(options);\n                patchFetchFormat(options);\n                return breakpoints.map(function(width) {\n                    return \"\".concat(scaledUrl(public_id, width, transformation, options), \" \").concat(width, \"w\");\n                }).join(\", \");\n            }\n            /**\n * Helper function. Generates sizes attribute value of the HTML img tag\n * @private\n * @param {number[]} breakpoints An array of breakpoints.\n * @return {string} Resulting sizes attribute value\n */ function generateSizesAttribute(breakpoints) {\n                if (breakpoints == null) {\n                    return \"\";\n                }\n                return breakpoints.map(function(width) {\n                    return \"(max-width: \".concat(width, \"px) \").concat(width, \"px\");\n                }).join(\", \");\n            }\n            /**\n * Helper function. Generates srcset and sizes attributes of the image tag\n *\n * Generated attributes are added to attributes argument\n *\n * @private\n * @param {string}    publicId  The public ID of the resource\n * @param {object}    attributes Existing HTML attributes.\n * @param {srcset}    srcsetData\n * @param {object}    options    Additional options.\n *\n * @return array The responsive attributes\n */ function generateImageResponsiveAttributes(publicId) {\n                var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                var srcsetData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n                // Create both srcset and sizes here to avoid fetching breakpoints twice\n                var responsiveAttributes = {};\n                if (srcsetUtils_isEmpty(srcsetData)) {\n                    return responsiveAttributes;\n                }\n                var generateSizes = !attributes.sizes && srcsetData.sizes === true;\n                var generateSrcset = !attributes.srcset;\n                if (generateSrcset || generateSizes) {\n                    var breakpoints = getOrGenerateBreakpoints(publicId, srcsetData, options);\n                    if (generateSrcset) {\n                        var transformation = srcsetData.transformation;\n                        var srcsetAttr = generateSrcsetAttribute(publicId, breakpoints, transformation, options);\n                        if (!srcsetUtils_isEmpty(srcsetAttr)) {\n                            responsiveAttributes.srcset = srcsetAttr;\n                        }\n                    }\n                    if (generateSizes) {\n                        var sizesAttr = generateSizesAttribute(breakpoints);\n                        if (!srcsetUtils_isEmpty(sizesAttr)) {\n                            responsiveAttributes.sizes = sizesAttr;\n                        }\n                    }\n                }\n                return responsiveAttributes;\n            }\n            /**\n * Generate a media query\n *\n * @private\n * @param {object} options configuration options\n * @param {number|string} options.min_width\n * @param {number|string} options.max_width\n * @return {string} a media query string\n */ function generateMediaAttr(options) {\n                var mediaQuery = [];\n                if (options != null) {\n                    if (options.min_width != null) {\n                        mediaQuery.push(\"(min-width: \".concat(options.min_width, \"px)\"));\n                    }\n                    if (options.max_width != null) {\n                        mediaQuery.push(\"(max-width: \".concat(options.max_width, \"px)\"));\n                    }\n                }\n                return mediaQuery.join(\" and \");\n            }\n            var srcsetUrl = scaledUrl;\n            // CONCATENATED MODULE: ./src/tags/imagetag.js\n            function imagetag_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return imagetag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, imagetag_typeof(o);\n            }\n            function imagetag_classCallCheck(a, n) {\n                if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n            function imagetag_defineProperties(e, r) {\n                for(var t = 0; t < r.length; t++){\n                    var o = r[t];\n                    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, imagetag_toPropertyKey(o.key), o);\n                }\n            }\n            function imagetag_createClass(e, r, t) {\n                return r && imagetag_defineProperties(e.prototype, r), t && imagetag_defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n                    writable: !1\n                }), e;\n            }\n            function imagetag_toPropertyKey(t) {\n                var i = imagetag_toPrimitive(t, \"string\");\n                return \"symbol\" == imagetag_typeof(i) ? i : i + \"\";\n            }\n            function imagetag_toPrimitive(t, r) {\n                if (\"object\" != imagetag_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != imagetag_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function imagetag_callSuper(t, o, e) {\n                return o = imagetag_getPrototypeOf(o), imagetag_possibleConstructorReturn(t, imagetag_isNativeReflectConstruct() ? Reflect.construct(o, e || [], imagetag_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function imagetag_possibleConstructorReturn(t, e) {\n                if (e && (\"object\" == imagetag_typeof(e) || \"function\" == typeof e)) return e;\n                if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n                return imagetag_assertThisInitialized(t);\n            }\n            function imagetag_assertThisInitialized(e) {\n                if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                return e;\n            }\n            function imagetag_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (imagetag_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function imagetag_superPropGet(t, o, e, r) {\n                var p = imagetag_get(imagetag_getPrototypeOf(1 & r ? t.prototype : t), o, e);\n                return 2 & r && \"function\" == typeof p ? function(t) {\n                    return p.apply(e, t);\n                } : p;\n            }\n            function imagetag_get() {\n                return imagetag_get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {\n                    var p = imagetag_superPropBase(e, t);\n                    if (p) {\n                        var n = Object.getOwnPropertyDescriptor(p, t);\n                        return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;\n                    }\n                }, imagetag_get.apply(null, arguments);\n            }\n            function imagetag_superPropBase(t, o) {\n                for(; !({}).hasOwnProperty.call(t, o) && null !== (t = imagetag_getPrototypeOf(t)););\n                return t;\n            }\n            function imagetag_getPrototypeOf(t) {\n                return imagetag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {\n                    return t.__proto__ || Object.getPrototypeOf(t);\n                }, imagetag_getPrototypeOf(t);\n            }\n            function imagetag_inherits(t, e) {\n                if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n                t.prototype = Object.create(e && e.prototype, {\n                    constructor: {\n                        value: t,\n                        writable: !0,\n                        configurable: !0\n                    }\n                }), Object.defineProperty(t, \"prototype\", {\n                    writable: !1\n                }), e && imagetag_setPrototypeOf(t, e);\n            }\n            function imagetag_setPrototypeOf(t, e) {\n                return imagetag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {\n                    return t.__proto__ = e, t;\n                }, imagetag_setPrototypeOf(t, e);\n            }\n            /**\n * Image Tag\n * Depends on 'tags/htmltag', 'cloudinary'\n */ /**\n * Creates an HTML (DOM) Image tag using Cloudinary as the source.\n * @constructor ImageTag\n * @extends HtmlTag\n * @param {string} [publicId]\n * @param {Object} [options]\n */ var imagetag_ImageTag = /*#__PURE__*/ function(_HtmlTag) {\n                function ImageTag(publicId) {\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    imagetag_classCallCheck(this, ImageTag);\n                    return imagetag_callSuper(this, ImageTag, [\n                        \"img\",\n                        publicId,\n                        options\n                    ]);\n                }\n                /** @override */ imagetag_inherits(ImageTag, _HtmlTag);\n                return imagetag_createClass(ImageTag, [\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"\";\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var attr, options, srcAttribute;\n                            attr = imagetag_superPropGet(ImageTag, \"attributes\", this, 3)([]) || {};\n                            options = this.getOptions();\n                            var attributes = this.getOption(\"attributes\") || {};\n                            var srcsetParam = this.getOption(\"srcset\") || attributes.srcset;\n                            var responsiveAttributes = {};\n                            if (isString_root_isString_default()(srcsetParam)) {\n                                responsiveAttributes.srcset = srcsetParam;\n                            } else {\n                                responsiveAttributes = generateImageResponsiveAttributes(this.publicId, attributes, srcsetParam, options);\n                            }\n                            if (!isEmpty(responsiveAttributes)) {\n                                delete attr.width;\n                                delete attr.height;\n                            }\n                            merge_root_merge_default()(attr, responsiveAttributes);\n                            srcAttribute = options.responsive && !options.client_hints ? \"data-src\" : \"src\";\n                            if (attr[srcAttribute] == null) {\n                                attr[srcAttribute] = url_url(this.publicId, this.getOptions());\n                            }\n                            return attr;\n                        }\n                    }\n                ]);\n            }(htmltag);\n            ;\n            /* harmony default export */ var imagetag = imagetag_ImageTag;\n            // CONCATENATED MODULE: ./src/tags/sourcetag.js\n            function sourcetag_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return sourcetag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, sourcetag_typeof(o);\n            }\n            function sourcetag_classCallCheck(a, n) {\n                if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n            function sourcetag_defineProperties(e, r) {\n                for(var t = 0; t < r.length; t++){\n                    var o = r[t];\n                    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, sourcetag_toPropertyKey(o.key), o);\n                }\n            }\n            function sourcetag_createClass(e, r, t) {\n                return r && sourcetag_defineProperties(e.prototype, r), t && sourcetag_defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n                    writable: !1\n                }), e;\n            }\n            function sourcetag_toPropertyKey(t) {\n                var i = sourcetag_toPrimitive(t, \"string\");\n                return \"symbol\" == sourcetag_typeof(i) ? i : i + \"\";\n            }\n            function sourcetag_toPrimitive(t, r) {\n                if (\"object\" != sourcetag_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != sourcetag_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function sourcetag_callSuper(t, o, e) {\n                return o = sourcetag_getPrototypeOf(o), sourcetag_possibleConstructorReturn(t, sourcetag_isNativeReflectConstruct() ? Reflect.construct(o, e || [], sourcetag_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function sourcetag_possibleConstructorReturn(t, e) {\n                if (e && (\"object\" == sourcetag_typeof(e) || \"function\" == typeof e)) return e;\n                if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n                return sourcetag_assertThisInitialized(t);\n            }\n            function sourcetag_assertThisInitialized(e) {\n                if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                return e;\n            }\n            function sourcetag_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (sourcetag_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function sourcetag_superPropGet(t, o, e, r) {\n                var p = sourcetag_get(sourcetag_getPrototypeOf(1 & r ? t.prototype : t), o, e);\n                return 2 & r && \"function\" == typeof p ? function(t) {\n                    return p.apply(e, t);\n                } : p;\n            }\n            function sourcetag_get() {\n                return sourcetag_get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {\n                    var p = sourcetag_superPropBase(e, t);\n                    if (p) {\n                        var n = Object.getOwnPropertyDescriptor(p, t);\n                        return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;\n                    }\n                }, sourcetag_get.apply(null, arguments);\n            }\n            function sourcetag_superPropBase(t, o) {\n                for(; !({}).hasOwnProperty.call(t, o) && null !== (t = sourcetag_getPrototypeOf(t)););\n                return t;\n            }\n            function sourcetag_getPrototypeOf(t) {\n                return sourcetag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {\n                    return t.__proto__ || Object.getPrototypeOf(t);\n                }, sourcetag_getPrototypeOf(t);\n            }\n            function sourcetag_inherits(t, e) {\n                if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n                t.prototype = Object.create(e && e.prototype, {\n                    constructor: {\n                        value: t,\n                        writable: !0,\n                        configurable: !0\n                    }\n                }), Object.defineProperty(t, \"prototype\", {\n                    writable: !1\n                }), e && sourcetag_setPrototypeOf(t, e);\n            }\n            function sourcetag_setPrototypeOf(t, e) {\n                return sourcetag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {\n                    return t.__proto__ = e, t;\n                }, sourcetag_setPrototypeOf(t, e);\n            }\n            /**\n * Image Tag\n * Depends on 'tags/htmltag', 'cloudinary'\n */ /**\n * Creates an HTML (DOM) Image tag using Cloudinary as the source.\n * @constructor SourceTag\n * @extends HtmlTag\n * @param {string} [publicId]\n * @param {Object} [options]\n */ var sourcetag_SourceTag = /*#__PURE__*/ function(_HtmlTag) {\n                function SourceTag(publicId) {\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    sourcetag_classCallCheck(this, SourceTag);\n                    return sourcetag_callSuper(this, SourceTag, [\n                        \"source\",\n                        publicId,\n                        options\n                    ]);\n                }\n                /** @override */ sourcetag_inherits(SourceTag, _HtmlTag);\n                return sourcetag_createClass(SourceTag, [\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"\";\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var srcsetParam = this.getOption(\"srcset\");\n                            var attr = sourcetag_superPropGet(SourceTag, \"attributes\", this, 3)([]) || {};\n                            var options = this.getOptions();\n                            merge_root_merge_default()(attr, generateImageResponsiveAttributes(this.publicId, attr, srcsetParam, options));\n                            if (!attr.srcset) {\n                                attr.srcset = url_url(this.publicId, options);\n                            }\n                            if (!attr.media && options.media) {\n                                attr.media = generateMediaAttr(options.media);\n                            }\n                            return attr;\n                        }\n                    }\n                ]);\n            }(htmltag);\n            ;\n            /* harmony default export */ var sourcetag = sourcetag_SourceTag;\n            // CONCATENATED MODULE: ./src/tags/picturetag.js\n            function picturetag_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return picturetag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, picturetag_typeof(o);\n            }\n            function picturetag_classCallCheck(a, n) {\n                if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n            function picturetag_defineProperties(e, r) {\n                for(var t = 0; t < r.length; t++){\n                    var o = r[t];\n                    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, picturetag_toPropertyKey(o.key), o);\n                }\n            }\n            function picturetag_createClass(e, r, t) {\n                return r && picturetag_defineProperties(e.prototype, r), t && picturetag_defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n                    writable: !1\n                }), e;\n            }\n            function picturetag_toPropertyKey(t) {\n                var i = picturetag_toPrimitive(t, \"string\");\n                return \"symbol\" == picturetag_typeof(i) ? i : i + \"\";\n            }\n            function picturetag_toPrimitive(t, r) {\n                if (\"object\" != picturetag_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != picturetag_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function picturetag_callSuper(t, o, e) {\n                return o = picturetag_getPrototypeOf(o), picturetag_possibleConstructorReturn(t, picturetag_isNativeReflectConstruct() ? Reflect.construct(o, e || [], picturetag_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function picturetag_possibleConstructorReturn(t, e) {\n                if (e && (\"object\" == picturetag_typeof(e) || \"function\" == typeof e)) return e;\n                if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n                return picturetag_assertThisInitialized(t);\n            }\n            function picturetag_assertThisInitialized(e) {\n                if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                return e;\n            }\n            function picturetag_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (picturetag_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function picturetag_superPropGet(t, o, e, r) {\n                var p = picturetag_get(picturetag_getPrototypeOf(1 & r ? t.prototype : t), o, e);\n                return 2 & r && \"function\" == typeof p ? function(t) {\n                    return p.apply(e, t);\n                } : p;\n            }\n            function picturetag_get() {\n                return picturetag_get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {\n                    var p = picturetag_superPropBase(e, t);\n                    if (p) {\n                        var n = Object.getOwnPropertyDescriptor(p, t);\n                        return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;\n                    }\n                }, picturetag_get.apply(null, arguments);\n            }\n            function picturetag_superPropBase(t, o) {\n                for(; !({}).hasOwnProperty.call(t, o) && null !== (t = picturetag_getPrototypeOf(t)););\n                return t;\n            }\n            function picturetag_getPrototypeOf(t) {\n                return picturetag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {\n                    return t.__proto__ || Object.getPrototypeOf(t);\n                }, picturetag_getPrototypeOf(t);\n            }\n            function picturetag_inherits(t, e) {\n                if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n                t.prototype = Object.create(e && e.prototype, {\n                    constructor: {\n                        value: t,\n                        writable: !0,\n                        configurable: !0\n                    }\n                }), Object.defineProperty(t, \"prototype\", {\n                    writable: !1\n                }), e && picturetag_setPrototypeOf(t, e);\n            }\n            function picturetag_setPrototypeOf(t, e) {\n                return picturetag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {\n                    return t.__proto__ = e, t;\n                }, picturetag_setPrototypeOf(t, e);\n            }\n            var picturetag_PictureTag = /*#__PURE__*/ function(_HtmlTag) {\n                function PictureTag(publicId) {\n                    var _this;\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    var sources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n                    picturetag_classCallCheck(this, PictureTag);\n                    _this = picturetag_callSuper(this, PictureTag, [\n                        \"picture\",\n                        publicId,\n                        options\n                    ]);\n                    _this.widthList = sources;\n                    return _this;\n                }\n                /** @override */ picturetag_inherits(PictureTag, _HtmlTag);\n                return picturetag_createClass(PictureTag, [\n                    {\n                        key: \"content\",\n                        value: function content() {\n                            var _this2 = this;\n                            return this.widthList.map(function(_ref) {\n                                var min_width = _ref.min_width, max_width = _ref.max_width, transformation = _ref.transformation;\n                                var options = _this2.getOptions();\n                                var sourceTransformation = new src_transformation(options);\n                                sourceTransformation.chain().fromOptions(typeof transformation === \"string\" ? {\n                                    raw_transformation: transformation\n                                } : transformation);\n                                options = extractUrlParams(options);\n                                options.media = {\n                                    min_width: min_width,\n                                    max_width: max_width\n                                };\n                                options.transformation = sourceTransformation;\n                                return new sourcetag(_this2.publicId, options).toHtml();\n                            }).join(\"\") + new imagetag(this.publicId, this.getOptions()).toHtml();\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var attr = picturetag_superPropGet(PictureTag, \"attributes\", this, 3)([]);\n                            delete attr.width;\n                            delete attr.height;\n                            return attr;\n                        }\n                    },\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"</\" + this.name + \">\";\n                        }\n                    }\n                ]);\n            }(htmltag);\n            ;\n            /* harmony default export */ var picturetag = picturetag_PictureTag;\n            // CONCATENATED MODULE: ./src/tags/videotag.js\n            function videotag_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return videotag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, videotag_typeof(o);\n            }\n            function videotag_classCallCheck(a, n) {\n                if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n            function videotag_defineProperties(e, r) {\n                for(var t = 0; t < r.length; t++){\n                    var o = r[t];\n                    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, videotag_toPropertyKey(o.key), o);\n                }\n            }\n            function videotag_createClass(e, r, t) {\n                return r && videotag_defineProperties(e.prototype, r), t && videotag_defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n                    writable: !1\n                }), e;\n            }\n            function videotag_toPropertyKey(t) {\n                var i = videotag_toPrimitive(t, \"string\");\n                return \"symbol\" == videotag_typeof(i) ? i : i + \"\";\n            }\n            function videotag_toPrimitive(t, r) {\n                if (\"object\" != videotag_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != videotag_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function videotag_callSuper(t, o, e) {\n                return o = videotag_getPrototypeOf(o), videotag_possibleConstructorReturn(t, videotag_isNativeReflectConstruct() ? Reflect.construct(o, e || [], videotag_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function videotag_possibleConstructorReturn(t, e) {\n                if (e && (\"object\" == videotag_typeof(e) || \"function\" == typeof e)) return e;\n                if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n                return videotag_assertThisInitialized(t);\n            }\n            function videotag_assertThisInitialized(e) {\n                if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                return e;\n            }\n            function videotag_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (videotag_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function videotag_superPropGet(t, o, e, r) {\n                var p = videotag_get(videotag_getPrototypeOf(1 & r ? t.prototype : t), o, e);\n                return 2 & r && \"function\" == typeof p ? function(t) {\n                    return p.apply(e, t);\n                } : p;\n            }\n            function videotag_get() {\n                return videotag_get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {\n                    var p = videotag_superPropBase(e, t);\n                    if (p) {\n                        var n = Object.getOwnPropertyDescriptor(p, t);\n                        return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;\n                    }\n                }, videotag_get.apply(null, arguments);\n            }\n            function videotag_superPropBase(t, o) {\n                for(; !({}).hasOwnProperty.call(t, o) && null !== (t = videotag_getPrototypeOf(t)););\n                return t;\n            }\n            function videotag_getPrototypeOf(t) {\n                return videotag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {\n                    return t.__proto__ || Object.getPrototypeOf(t);\n                }, videotag_getPrototypeOf(t);\n            }\n            function videotag_inherits(t, e) {\n                if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n                t.prototype = Object.create(e && e.prototype, {\n                    constructor: {\n                        value: t,\n                        writable: !0,\n                        configurable: !0\n                    }\n                }), Object.defineProperty(t, \"prototype\", {\n                    writable: !1\n                }), e && videotag_setPrototypeOf(t, e);\n            }\n            function videotag_setPrototypeOf(t, e) {\n                return videotag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {\n                    return t.__proto__ = e, t;\n                }, videotag_setPrototypeOf(t, e);\n            }\n            /**\n * Video Tag\n * Depends on 'tags/htmltag', 'util', 'cloudinary'\n */ var VIDEO_TAG_PARAMS = [\n                \"source_types\",\n                \"source_transformation\",\n                \"fallback_content\",\n                \"poster\",\n                \"sources\"\n            ];\n            var videotag_DEFAULT_VIDEO_SOURCE_TYPES = [\n                \"webm\",\n                \"mp4\",\n                \"ogv\"\n            ];\n            var videotag_DEFAULT_POSTER_OPTIONS = {\n                format: \"jpg\",\n                resource_type: \"video\"\n            };\n            /**\n * Creates an HTML (DOM) Video tag using Cloudinary as the source.\n * @constructor VideoTag\n * @extends HtmlTag\n * @param {string} [publicId]\n * @param {Object} [options]\n */ var videotag_VideoTag = /*#__PURE__*/ function(_HtmlTag) {\n                function VideoTag(publicId) {\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    videotag_classCallCheck(this, VideoTag);\n                    options = defaults({}, options, DEFAULT_VIDEO_PARAMS);\n                    return videotag_callSuper(this, VideoTag, [\n                        \"video\",\n                        publicId.replace(/\\.(mp4|ogv|webm)$/, \"\"),\n                        options\n                    ]);\n                }\n                /**\n   * Set the transformation to apply on each source\n   * @function VideoTag#setSourceTransformation\n   * @param {Object} an object with pairs of source type and source transformation\n   * @returns {VideoTag} Returns this instance for chaining purposes.\n   */ videotag_inherits(VideoTag, _HtmlTag);\n                return videotag_createClass(VideoTag, [\n                    {\n                        key: \"setSourceTransformation\",\n                        value: function setSourceTransformation(value) {\n                            this.transformation().sourceTransformation(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setSourceTypes\",\n                        value: function setSourceTypes(value) {\n                            this.transformation().sourceTypes(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setPoster\",\n                        value: function setPoster(value) {\n                            this.transformation().poster(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setFallbackContent\",\n                        value: function setFallbackContent(value) {\n                            this.transformation().fallbackContent(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"content\",\n                        value: function content() {\n                            var _this = this;\n                            var sourceTypes = this.transformation().getValue(\"source_types\");\n                            var sourceTransformation = this.transformation().getValue(\"source_transformation\");\n                            var fallback = this.transformation().getValue(\"fallback_content\");\n                            var sources = this.getOption(\"sources\");\n                            var innerTags = [];\n                            if (isArray_root_isArray_default()(sources) && !isEmpty(sources)) {\n                                innerTags = sources.map(function(source) {\n                                    var src = url_url(_this.publicId, defaults({}, source.transformations || {}, {\n                                        resource_type: \"video\",\n                                        format: source.type\n                                    }), _this.getOptions());\n                                    return _this.createSourceTag(src, source.type, source.codecs);\n                                });\n                            } else {\n                                if (isEmpty(sourceTypes)) {\n                                    sourceTypes = videotag_DEFAULT_VIDEO_SOURCE_TYPES;\n                                }\n                                if (isArray_root_isArray_default()(sourceTypes)) {\n                                    innerTags = sourceTypes.map(function(srcType) {\n                                        var src = url_url(_this.publicId, defaults({}, sourceTransformation[srcType] || {}, {\n                                            resource_type: \"video\",\n                                            format: srcType\n                                        }), _this.getOptions());\n                                        return _this.createSourceTag(src, srcType);\n                                    });\n                                }\n                            }\n                            return innerTags.join(\"\") + fallback;\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var sourceTypes = this.getOption(\"source_types\");\n                            var poster = this.getOption(\"poster\");\n                            if (poster === undefined) {\n                                poster = {};\n                            }\n                            if (isPlainObject_root_isPlainObject_default()(poster)) {\n                                var defaultOptions = poster.public_id != null ? DEFAULT_IMAGE_PARAMS : videotag_DEFAULT_POSTER_OPTIONS;\n                                poster = url_url(poster.public_id || this.publicId, defaults({}, poster, defaultOptions, this.getOptions()));\n                            }\n                            var attr = videotag_superPropGet(VideoTag, \"attributes\", this, 3)([]) || {};\n                            attr = omit(attr, VIDEO_TAG_PARAMS);\n                            var sources = this.getOption(\"sources\");\n                            // In case of empty sourceTypes - fallback to default source types is used.\n                            var hasSourceTags = !isEmpty(sources) || isEmpty(sourceTypes) || isArray_root_isArray_default()(sourceTypes);\n                            if (!hasSourceTags) {\n                                attr[\"src\"] = url_url(this.publicId, this.getOptions(), {\n                                    resource_type: \"video\",\n                                    format: sourceTypes\n                                });\n                            }\n                            if (poster != null) {\n                                attr[\"poster\"] = poster;\n                            }\n                            return attr;\n                        }\n                    },\n                    {\n                        key: \"createSourceTag\",\n                        value: function createSourceTag(src, sourceType) {\n                            var codecs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n                            var mimeType = null;\n                            if (!isEmpty(sourceType)) {\n                                var videoType = sourceType === \"ogv\" ? \"ogg\" : sourceType;\n                                mimeType = \"video/\" + videoType;\n                                if (!isEmpty(codecs)) {\n                                    var codecsStr = isArray_root_isArray_default()(codecs) ? codecs.join(\", \") : codecs;\n                                    mimeType += \"; codecs=\" + codecsStr;\n                                }\n                            }\n                            return \"<source \" + this.htmlAttrs({\n                                src: src,\n                                type: mimeType\n                            }) + \">\";\n                        }\n                    }\n                ]);\n            }(htmltag);\n            /* harmony default export */ var videotag = videotag_VideoTag;\n            // CONCATENATED MODULE: ./src/tags/clienthintsmetatag.js\n            function clienthintsmetatag_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return clienthintsmetatag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, clienthintsmetatag_typeof(o);\n            }\n            function clienthintsmetatag_classCallCheck(a, n) {\n                if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n            function clienthintsmetatag_defineProperties(e, r) {\n                for(var t = 0; t < r.length; t++){\n                    var o = r[t];\n                    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, clienthintsmetatag_toPropertyKey(o.key), o);\n                }\n            }\n            function clienthintsmetatag_createClass(e, r, t) {\n                return r && clienthintsmetatag_defineProperties(e.prototype, r), t && clienthintsmetatag_defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n                    writable: !1\n                }), e;\n            }\n            function clienthintsmetatag_toPropertyKey(t) {\n                var i = clienthintsmetatag_toPrimitive(t, \"string\");\n                return \"symbol\" == clienthintsmetatag_typeof(i) ? i : i + \"\";\n            }\n            function clienthintsmetatag_toPrimitive(t, r) {\n                if (\"object\" != clienthintsmetatag_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != clienthintsmetatag_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function clienthintsmetatag_callSuper(t, o, e) {\n                return o = clienthintsmetatag_getPrototypeOf(o), clienthintsmetatag_possibleConstructorReturn(t, clienthintsmetatag_isNativeReflectConstruct() ? Reflect.construct(o, e || [], clienthintsmetatag_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function clienthintsmetatag_possibleConstructorReturn(t, e) {\n                if (e && (\"object\" == clienthintsmetatag_typeof(e) || \"function\" == typeof e)) return e;\n                if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n                return clienthintsmetatag_assertThisInitialized(t);\n            }\n            function clienthintsmetatag_assertThisInitialized(e) {\n                if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                return e;\n            }\n            function clienthintsmetatag_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (clienthintsmetatag_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function clienthintsmetatag_getPrototypeOf(t) {\n                return clienthintsmetatag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {\n                    return t.__proto__ || Object.getPrototypeOf(t);\n                }, clienthintsmetatag_getPrototypeOf(t);\n            }\n            function clienthintsmetatag_inherits(t, e) {\n                if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n                t.prototype = Object.create(e && e.prototype, {\n                    constructor: {\n                        value: t,\n                        writable: !0,\n                        configurable: !0\n                    }\n                }), Object.defineProperty(t, \"prototype\", {\n                    writable: !1\n                }), e && clienthintsmetatag_setPrototypeOf(t, e);\n            }\n            function clienthintsmetatag_setPrototypeOf(t, e) {\n                return clienthintsmetatag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {\n                    return t.__proto__ = e, t;\n                }, clienthintsmetatag_setPrototypeOf(t, e);\n            }\n            /**\n * Image Tag\n * Depends on 'tags/htmltag', 'cloudinary'\n */ /**\n * Creates an HTML (DOM) Meta tag that enables Client-Hints for the HTML page. <br/>\n *  See\n *  <a href=\"https://cloudinary.com/documentation/responsive_images#automating_responsive_images_with_client_hints\"\n *  target=\"_new\">Automating responsive images with Client Hints</a> for more details.\n * @constructor ClientHintsMetaTag\n * @extends HtmlTag\n * @param {object} options\n * @example\n * tag = new ClientHintsMetaTag()\n * //returns: <meta http-equiv=\"Accept-CH\" content=\"DPR, Viewport-Width, Width\">\n */ var clienthintsmetatag_ClientHintsMetaTag = /*#__PURE__*/ function(_HtmlTag) {\n                function ClientHintsMetaTag(options) {\n                    clienthintsmetatag_classCallCheck(this, ClientHintsMetaTag);\n                    return clienthintsmetatag_callSuper(this, ClientHintsMetaTag, [\n                        \"meta\",\n                        void 0,\n                        assign_root_assign_default()({\n                            \"http-equiv\": \"Accept-CH\",\n                            content: \"DPR, Viewport-Width, Width\"\n                        }, options)\n                    ]);\n                }\n                /** @override */ clienthintsmetatag_inherits(ClientHintsMetaTag, _HtmlTag);\n                return clienthintsmetatag_createClass(ClientHintsMetaTag, [\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"\";\n                        }\n                    }\n                ]);\n            }(htmltag);\n            ;\n            /* harmony default export */ var clienthintsmetatag = clienthintsmetatag_ClientHintsMetaTag;\n            // CONCATENATED MODULE: ./src/util/parse/normalizeToArray.js\n            function normalizeToArray_toConsumableArray(r) {\n                return normalizeToArray_arrayWithoutHoles(r) || normalizeToArray_iterableToArray(r) || normalizeToArray_unsupportedIterableToArray(r) || normalizeToArray_nonIterableSpread();\n            }\n            function normalizeToArray_nonIterableSpread() {\n                throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function normalizeToArray_unsupportedIterableToArray(r, a) {\n                if (r) {\n                    if (\"string\" == typeof r) return normalizeToArray_arrayLikeToArray(r, a);\n                    var t = ({}).toString.call(r).slice(8, -1);\n                    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? normalizeToArray_arrayLikeToArray(r, a) : void 0;\n                }\n            }\n            function normalizeToArray_iterableToArray(r) {\n                if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n            }\n            function normalizeToArray_arrayWithoutHoles(r) {\n                if (Array.isArray(r)) return normalizeToArray_arrayLikeToArray(r);\n            }\n            function normalizeToArray_arrayLikeToArray(r, a) {\n                (null == a || a > r.length) && (a = r.length);\n                for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];\n                return n;\n            }\n            /**\n * @desc normalize elements, support a single element, array or nodelist, always outputs array\n * @param elements<HTMLElement[]>\n * @returns {[]}\n */ function normalizeToArray(elements) {\n                if (isArray_root_isArray_default()(elements)) {\n                    return elements;\n                } else if (elements.constructor.name === \"NodeList\") {\n                    return normalizeToArray_toConsumableArray(elements); // ensure an array is always returned, even if nodelist\n                } else if (isString_root_isString_default()(elements)) {\n                    return Array.prototype.slice.call(document.querySelectorAll(elements), 0);\n                } else {\n                    return [\n                        elements\n                    ];\n                }\n            }\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/mountCloudinaryVideoTag.js\n            /**\n * @param {HTMLElement} htmlElContainer\n * @param {object} clInstance cloudinary instance\n * @param {string} publicId\n * @param {object} options - TransformationOptions\n * @returns Promise<HTMLElement>\n */ function mountCloudinaryVideoTag(htmlElContainer, clInstance, publicId, options) {\n                return new Promise(function(resolve, reject) {\n                    htmlElContainer.innerHTML = clInstance.videoTag(publicId, options).toHtml();\n                    // All videos under the html container must have a width of 100%, or they might overflow from the container\n                    var cloudinaryVideoElement = htmlElContainer.querySelector(\".cld-transparent-video\");\n                    cloudinaryVideoElement.style.width = \"100%\";\n                    resolve(htmlElContainer);\n                });\n            }\n            /* harmony default export */ var transparentVideo_mountCloudinaryVideoTag = mountCloudinaryVideoTag;\n            // CONCATENATED MODULE: ./src/util/transformations/addFlag.js\n            /**\n * @description - Function will push a flag to incoming options\n * @param {{transformation} | {...transformation}} options - These options are the same options provided to all our SDK methods\n *                           We expect options to either be the transformation itself, or an object containing\n *                           an array of transformations\n *\n * @param {string} flag\n * @returns the mutated options object\n */ function addFlagToOptions(options, flag) {\n                // Do we have transformation\n                if (options.transformation) {\n                    options.transformation.push({\n                        flags: [\n                            flag\n                        ]\n                    });\n                } else {\n                    // no transformation\n                    // ensure the flags are extended\n                    if (!options.flags) {\n                        options.flags = [];\n                    }\n                    if (typeof options.flags === \"string\") {\n                        options.flags = [\n                            options.flags\n                        ];\n                    }\n                    options.flags.push(flag);\n                }\n            }\n            /* harmony default export */ var addFlag = addFlagToOptions;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/enforceOptionsForTransparentVideo.js\n            /**\n * @description - Enforce option structure, sets defaults and ensures alpha flag exists\n * @param options {TransformationOptions}\n */ function enforceOptionsForTransparentVideo(options) {\n                options.autoplay = true;\n                options.muted = true;\n                options.controls = false;\n                options.max_timeout_ms = options.max_timeout_ms || DEFAULT_TIMEOUT_MS;\n                options[\"class\"] = options[\"class\"] || \"\";\n                options[\"class\"] += \" cld-transparent-video\";\n                options.externalLibraries = options.externalLibraries || {};\n                if (!options.externalLibraries.seeThru) {\n                    options.externalLibraries.seeThru = DEFAULT_EXTERNAL_LIBRARIES.seeThru;\n                }\n                // ensure there's an alpha transformation present\n                // this is a non documented internal flag\n                addFlag(options, \"alpha\");\n            }\n            /* harmony default export */ var transparentVideo_enforceOptionsForTransparentVideo = enforceOptionsForTransparentVideo;\n            // CONCATENATED MODULE: ./src/util/xhr/loadScript.js\n            /**\n * @description - Given a string URL, this function will load the script and resolve the promise.\n *                The function doesn't resolve any value,\n *                this is not a UMD loader where you can get your library name back.\n * @param scriptURL {string}\n * @param {number} max_timeout_ms - Time to elapse before promise is rejected\n * @param isAlreadyLoaded {boolean} if true, the loadScript resolves immediately\n *                                  this is used for multiple invocations - prevents the script from being loaded multiple times\n * @return {Promise<any | {status:string, message:string}>}\n */ function loadScript(scriptURL, max_timeout_ms, isAlreadyLoaded) {\n                return new Promise(function(resolve, reject) {\n                    if (isAlreadyLoaded) {\n                        resolve();\n                    } else {\n                        var scriptTag = document.createElement(\"script\");\n                        scriptTag.src = scriptURL;\n                        var timerID = setTimeout(function() {\n                            reject({\n                                status: \"error\",\n                                message: \"Timeout loading script \".concat(scriptURL)\n                            });\n                        }, max_timeout_ms); // 10 seconds for timeout\n                        scriptTag.onerror = function() {\n                            clearTimeout(timerID); // clear timeout reject error\n                            reject({\n                                status: \"error\",\n                                message: \"Error loading \".concat(scriptURL)\n                            });\n                        };\n                        scriptTag.onload = function() {\n                            clearTimeout(timerID); // clear timeout reject error\n                            resolve();\n                        };\n                        document.head.appendChild(scriptTag);\n                    }\n                });\n            }\n            /* harmony default export */ var xhr_loadScript = loadScript;\n            // CONCATENATED MODULE: ./src/util/xhr/getBlobFromURL.js\n            /**\n * Reject on timeout\n * @param maxTimeoutMS\n * @param reject\n * @returns {number} timerID\n */ function rejectOnTimeout(maxTimeoutMS, reject) {\n                return setTimeout(function() {\n                    reject({\n                        status: \"error\",\n                        message: \"Timeout loading Blob URL\"\n                    });\n                }, maxTimeoutMS);\n            }\n            /**\n * @description Converts a URL to a BLOB URL\n * @param {string} urlToLoad\n * @param {number} max_timeout_ms - Time to elapse before promise is rejected\n * @return {Promise<{\n *   status: 'success' | 'error'\n *   message?: string,\n *    payload: {\n *      url: string\n *    }\n * }>}\n */ function getBlobFromURL(urlToLoad, maxTimeoutMS) {\n                return new Promise(function(resolve, reject) {\n                    var timerID = rejectOnTimeout(maxTimeoutMS, reject);\n                    // If fetch exists, use it to fetch blob, otherwise use XHR.\n                    // XHR causes issues on safari 14.1 so we prefer fetch\n                    var fetchBlob = typeof fetch !== \"undefined\" && fetch ? loadUrlUsingFetch : loadUrlUsingXhr;\n                    fetchBlob(urlToLoad).then(function(blob) {\n                        resolve({\n                            status: \"success\",\n                            payload: {\n                                blobURL: URL.createObjectURL(blob)\n                            }\n                        });\n                    })[\"catch\"](function() {\n                        reject({\n                            status: \"error\",\n                            message: \"Error loading Blob URL\"\n                        });\n                    })[\"finally\"](function() {\n                        // Clear the timeout timer on fail or success.\n                        clearTimeout(timerID);\n                    });\n                });\n            }\n            /**\n * Use fetch function to fetch file\n * @param urlToLoad\n * @returns {Promise<unknown>}\n */ function loadUrlUsingFetch(urlToLoad) {\n                return new Promise(function(resolve, reject) {\n                    fetch(urlToLoad).then(function(response) {\n                        response.blob().then(function(blob) {\n                            resolve(blob);\n                        });\n                    })[\"catch\"](function() {\n                        reject(\"error\");\n                    });\n                });\n            }\n            /**\n * Use XHR to fetch file\n * @param urlToLoad\n * @returns {Promise<unknown>}\n */ function loadUrlUsingXhr(urlToLoad) {\n                return new Promise(function(resolve, reject) {\n                    var xhr = new XMLHttpRequest();\n                    xhr.responseType = \"blob\";\n                    xhr.onload = function(response) {\n                        resolve(xhr.response);\n                    };\n                    xhr.onerror = function() {\n                        reject(\"error\");\n                    };\n                    xhr.open(\"GET\", urlToLoad, true);\n                    xhr.send();\n                });\n            }\n            /* harmony default export */ var xhr_getBlobFromURL = getBlobFromURL;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/createHiddenVideoTag.js\n            /**\n * @description Creates a hidden HTMLVideoElement with the specified videoOptions\n * @param {{autoplay, playsinline, loop, muted, poster, blobURL, videoURL }} videoOptions\n * @param {boolean} videoOptions.autoplay - autoplays the video if true\n * @param {string} videoOptions.blobURL - the blobURL to set as video.src\n * @param {string} videoOptions.videoURL - the original videoURL the user created (with transformations)\n * @return {HTMLVideoElement}\n */ function createHiddenVideoTag(videoOptions) {\n                var autoplay = videoOptions.autoplay, playsinline = videoOptions.playsinline, loop = videoOptions.loop, muted = videoOptions.muted, poster = videoOptions.poster, blobURL = videoOptions.blobURL, videoURL = videoOptions.videoURL;\n                var el = document.createElement(\"video\");\n                el.style.visibility = \"hidden\";\n                el.position = \"absolute\";\n                el.x = 0;\n                el.y = 0;\n                el.src = blobURL;\n                el.setAttribute(\"data-video-url\", videoURL); // for debugging/testing\n                autoplay && el.setAttribute(\"autoplay\", autoplay);\n                playsinline && el.setAttribute(\"playsinline\", playsinline);\n                loop && el.setAttribute(\"loop\", loop);\n                muted && el.setAttribute(\"muted\", muted);\n                muted && (el.muted = muted); // this is also needed for autoplay, on top of setAttribute\n                poster && el.setAttribute(\"poster\", poster);\n                // Free memory at the end of the file loading.\n                el.onload = function() {\n                    URL.revokeObjectURL(blobURL);\n                };\n                return el;\n            }\n            /* harmony default export */ var transparentVideo_createHiddenVideoTag = createHiddenVideoTag;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/instantiateSeeThru.js\n            /**\n * @description This function creates a new instanc eof seeThru (seeThru.create()) and returns a promise of the seeThru instance\n * @param {HTMLVideoElement} videoElement\n * @param {number} max_timeout_ms - Time to elapse before promise is rejected\n * @param {string} customClass - A classname to be added to the canvas element created by seeThru\n * @param {boolean} autoPlay\n * @return {Promise<any>} SeeThru instance or rejection error\n */ function instantiateSeeThru(videoElement, max_timeout_ms, customClass, autoPlay) {\n                var _window = window, seeThru = _window.seeThru, setTimeout1 = _window.setTimeout, clearTimeout1 = _window.clearTimeout;\n                return new Promise(function(resolve, reject) {\n                    var timerID = setTimeout1(function() {\n                        reject({\n                            status: \"error\",\n                            message: \"Timeout instantiating seeThru instance\"\n                        });\n                    }, max_timeout_ms);\n                    if (seeThru) {\n                        var seeThruInstance = seeThru.create(videoElement).ready(function() {\n                            // clear timeout reject error\n                            clearTimeout1(timerID);\n                            // force container width, else the canvas can overflow out\n                            var canvasElement = seeThruInstance.getCanvas();\n                            canvasElement.style.width = \"100%\";\n                            canvasElement.className += \" \" + customClass;\n                            // start the video if autoplay is set\n                            if (autoPlay) {\n                                seeThruInstance.play();\n                            }\n                            resolve(seeThruInstance);\n                        });\n                    } else {\n                        reject({\n                            status: \"error\",\n                            message: \"Error instantiating seeThru instance\"\n                        });\n                    }\n                });\n            }\n            /* harmony default export */ var transparentVideo_instantiateSeeThru = instantiateSeeThru;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/mountSeeThruCanvasTag.js\n            /**\n *\n * @param {HTMLElement} htmlElContainer\n * @param {string} videoURL\n * @param {TransformationOptions} options\n * @return {Promise<any>}\n */ function mountSeeThruCanvasTag(htmlElContainer, videoURL, options) {\n                var poster = options.poster, autoplay = options.autoplay, playsinline = options.playsinline, loop = options.loop, muted = options.muted;\n                videoURL = videoURL + \".mp4\"; // seeThru always uses mp4\n                return new Promise(function(resolve, reject) {\n                    xhr_loadScript(options.externalLibraries.seeThru, options.max_timeout_ms, window.seeThru).then(function() {\n                        xhr_getBlobFromURL(videoURL, options.max_timeout_ms).then(function(_ref) {\n                            var payload = _ref.payload;\n                            var videoElement = transparentVideo_createHiddenVideoTag({\n                                blobURL: payload.blobURL,\n                                videoURL: videoURL,\n                                // for debugging/testing\n                                poster: poster,\n                                autoplay: autoplay,\n                                playsinline: playsinline,\n                                loop: loop,\n                                muted: muted\n                            });\n                            htmlElContainer.appendChild(videoElement);\n                            transparentVideo_instantiateSeeThru(videoElement, options.max_timeout_ms, options[\"class\"], options.autoplay).then(function() {\n                                resolve(htmlElContainer);\n                            })[\"catch\"](function(err) {\n                                reject(err);\n                            });\n                        // catch for getBlobFromURL()\n                        })[\"catch\"](function(_ref2) {\n                            var status = _ref2.status, message = _ref2.message;\n                            reject({\n                                status: status,\n                                message: message\n                            });\n                        });\n                    // catch for loadScript()\n                    })[\"catch\"](function(_ref3) {\n                        var status = _ref3.status, message = _ref3.message;\n                        reject({\n                            status: status,\n                            message: message\n                        });\n                    });\n                });\n            }\n            /* harmony default export */ var transparentVideo_mountSeeThruCanvasTag = mountSeeThruCanvasTag;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/checkSupportForTransparency.js\n            /**\n * @return {Promise<boolean>} - Whether the browser supports transparent videos or not\n */ function checkSupportForTransparency() {\n                return new Promise(function(resolve, reject) {\n                    // Resolve early for safari.\n                    // Currently (29 December 2021) Safari can play webm/vp9,\n                    // but it does not support transparent video in the format we're outputting\n                    if (isSafari()) {\n                        resolve(false);\n                    }\n                    var video = document.createElement(\"video\");\n                    var canPlay = video.canPlayType && video.canPlayType('video/webm; codecs=\"vp9\"');\n                    resolve(canPlay === \"maybe\" || canPlay === \"probably\");\n                });\n            }\n            /* harmony default export */ var transparentVideo_checkSupportForTransparency = checkSupportForTransparency;\n            // CONCATENATED MODULE: ./src/cloudinary.js\n            function cloudinary_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return cloudinary_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, cloudinary_typeof(o);\n            }\n            function cloudinary_classCallCheck(a, n) {\n                if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n            function cloudinary_defineProperties(e, r) {\n                for(var t = 0; t < r.length; t++){\n                    var o = r[t];\n                    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, cloudinary_toPropertyKey(o.key), o);\n                }\n            }\n            function cloudinary_createClass(e, r, t) {\n                return r && cloudinary_defineProperties(e.prototype, r), t && cloudinary_defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n                    writable: !1\n                }), e;\n            }\n            function cloudinary_toPropertyKey(t) {\n                var i = cloudinary_toPrimitive(t, \"string\");\n                return \"symbol\" == cloudinary_typeof(i) ? i : i + \"\";\n            }\n            function cloudinary_toPrimitive(t, r) {\n                if (\"object\" != cloudinary_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != cloudinary_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            var applyBreakpoints, closestAbove, defaultBreakpoints, cloudinary_findContainerWidth, cloudinary_maxWidth, updateDpr;\n            //\n            defaultBreakpoints = function defaultBreakpoints(width) {\n                var steps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n                return steps * Math.ceil(width / steps);\n            };\n            closestAbove = function closestAbove(list, value) {\n                var i;\n                i = list.length - 2;\n                while(i >= 0 && list[i] >= value){\n                    i--;\n                }\n                return list[i + 1];\n            };\n            applyBreakpoints = function applyBreakpoints(tag, width, steps, options) {\n                var ref, ref1, ref2, responsive_use_breakpoints;\n                responsive_use_breakpoints = (ref = (ref1 = (ref2 = options[\"responsive_use_breakpoints\"]) != null ? ref2 : options[\"responsive_use_stoppoints\"]) != null ? ref1 : this.config(\"responsive_use_breakpoints\")) != null ? ref : this.config(\"responsive_use_stoppoints\");\n                if (!responsive_use_breakpoints || responsive_use_breakpoints === \"resize\" && !options.resizing) {\n                    return width;\n                } else {\n                    return this.calc_breakpoint(tag, width, steps);\n                }\n            };\n            cloudinary_findContainerWidth = function findContainerWidth(element) {\n                var containerWidth, style;\n                containerWidth = 0;\n                while((element = element != null ? element.parentNode : void 0) instanceof Element && !containerWidth){\n                    style = window.getComputedStyle(element);\n                    if (!/^inline/.test(style.display)) {\n                        containerWidth = lodash_width(element);\n                    }\n                }\n                return containerWidth;\n            };\n            updateDpr = function updateDpr(dataSrc, roundDpr) {\n                return dataSrc.replace(/\\bdpr_(1\\.0|auto)\\b/g, \"dpr_\" + this.device_pixel_ratio(roundDpr));\n            };\n            cloudinary_maxWidth = function maxWidth(requiredWidth, tag) {\n                var imageWidth;\n                imageWidth = lodash_getData(tag, \"width\") || 0;\n                if (requiredWidth > imageWidth) {\n                    imageWidth = requiredWidth;\n                    lodash_setData(tag, \"width\", requiredWidth);\n                }\n                return imageWidth;\n            };\n            var cloudinary_Cloudinary = /*#__PURE__*/ function() {\n                /**\n   * Creates a new Cloudinary instance.\n   * @class Cloudinary\n   * @classdesc Main class for accessing Cloudinary functionality.\n   * @param {Object} options - A {@link Configuration} object for globally configuring Cloudinary account settings.\n   * @example<br/>\n   *  var cl = new cloudinary.Cloudinary( { cloud_name: \"mycloud\"});<br/>\n   *  var imgTag = cl.image(\"myPicID\");\n   * @see <a href=\"https://cloudinary.com/documentation/solution_overview#configuration_parameters\" target=\"_blank\">\n   *  Available configuration options</a>\n   */ function Cloudinary(options) {\n                    cloudinary_classCallCheck(this, Cloudinary);\n                    var configuration;\n                    this.devicePixelRatioCache = {};\n                    this.responsiveConfig = {};\n                    this.responsiveResizeInitialized = false;\n                    configuration = new src_configuration(options);\n                    // Provided for backward compatibility\n                    this.config = function(newConfig, newValue) {\n                        return configuration.config(newConfig, newValue);\n                    };\n                    /**\n     * Use \\<meta\\> tags in the document to configure this `cloudinary` instance.\n     * @return This {Cloudinary} instance for chaining.\n     */ this.fromDocument = function() {\n                        configuration.fromDocument();\n                        return this;\n                    };\n                    /**\n     * Use environment variables to configure this `cloudinary` instance.\n     * @return This {Cloudinary} instance for chaining.\n     */ this.fromEnvironment = function() {\n                        configuration.fromEnvironment();\n                        return this;\n                    };\n                    /**\n     * Initializes the configuration of this `cloudinary` instance.\n     *  This is a convenience method that invokes both {@link Configuration#fromEnvironment|fromEnvironment()}\n     *  (Node.js environment only) and {@link Configuration#fromDocument|fromDocument()}.\n     *  It first tries to retrieve the configuration from the environment variable.\n     *  If not available, it tries from the document meta tags.\n     * @function Cloudinary#init\n     * @see Configuration#init\n     * @return This {Cloudinary} instance for chaining.\n     */ this.init = function() {\n                        configuration.init();\n                        return this;\n                    };\n                }\n                /**\n   * Convenience constructor\n   * @param {Object} options\n   * @return {Cloudinary}\n   * @example cl = cloudinary.Cloudinary.new( { cloud_name: \"mycloud\"})\n   */ return cloudinary_createClass(Cloudinary, [\n                    {\n                        key: \"url\",\n                        value: /**\n     * Generates a URL for any asset in your Media library.\n     * @function Cloudinary#url\n     * @param {string} publicId - The public ID of the media asset.\n     * @param {Object} [options] - The {@link Transformation} parameters to include in the URL.\n     * @param {type} [options.type='upload'] - The asset's storage type.\n     *  For details on all fetch types, see\n     * <a href=\"https://cloudinary.com/documentation/image_transformations#fetching_images_from_remote_locations\"\n     *  target=\"_blank\">Fetch types</a>.\n     * @param {resourceType} [options.resource_type='image'] - The type of asset. Possible values:<br/>\n     *  - `image`<br/>\n     *  - `video`<br/>\n     *  - `raw`\n     * @return {string} The media asset URL.\n     * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\" target=\"_blank\">\n     *  Available image transformations</a>\n     * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\" target=\"_blank\">\n     *  Available video transformations</a>\n     */ function url(publicId) {\n                            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            return url_url(publicId, options, this.config());\n                        }\n                    },\n                    {\n                        key: \"video_url\",\n                        value: function video_url(publicId, options) {\n                            options = assign_root_assign_default()({\n                                resource_type: \"video\"\n                            }, options);\n                            return this.url(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"video_thumbnail_url\",\n                        value: function video_thumbnail_url(publicId, options) {\n                            options = assign_root_assign_default()({}, DEFAULT_POSTER_OPTIONS, options);\n                            return this.url(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"transformation_string\",\n                        value: function transformation_string(options) {\n                            return new src_transformation(options).serialize();\n                        }\n                    },\n                    {\n                        key: \"image\",\n                        value: function image(publicId) {\n                            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            var client_hints, img, ref;\n                            img = this.imageTag(publicId, options);\n                            client_hints = (ref = options.client_hints != null ? options.client_hints : this.config(\"client_hints\")) != null ? ref : false;\n                            if (options.src == null && !client_hints) {\n                                // src must be removed before creating the DOM element to avoid loading the image\n                                img.setAttr(\"src\", \"\");\n                            }\n                            img = img.toDOM();\n                            if (!client_hints) {\n                                // cache the image src\n                                lodash_setData(img, \"src-cache\", this.url(publicId, options));\n                                // set image src taking responsiveness in account\n                                this.cloudinary_update(img, options);\n                            }\n                            return img;\n                        }\n                    },\n                    {\n                        key: \"imageTag\",\n                        value: function imageTag(publicId, options) {\n                            var tag;\n                            tag = new imagetag(publicId, this.config());\n                            tag.transformation().fromOptions(options);\n                            return tag;\n                        }\n                    },\n                    {\n                        key: \"pictureTag\",\n                        value: function pictureTag(publicId, options, sources) {\n                            var tag;\n                            tag = new picturetag(publicId, this.config(), sources);\n                            tag.transformation().fromOptions(options);\n                            return tag;\n                        }\n                    },\n                    {\n                        key: \"sourceTag\",\n                        value: function sourceTag(publicId, options) {\n                            var tag;\n                            tag = new sourcetag(publicId, this.config());\n                            tag.transformation().fromOptions(options);\n                            return tag;\n                        }\n                    },\n                    {\n                        key: \"video_thumbnail\",\n                        value: function video_thumbnail(publicId, options) {\n                            return this.image(publicId, merge_root_merge_default()({}, DEFAULT_POSTER_OPTIONS, options));\n                        }\n                    },\n                    {\n                        key: \"facebook_profile_image\",\n                        value: function facebook_profile_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"facebook\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"twitter_profile_image\",\n                        value: function twitter_profile_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"twitter\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"twitter_name_profile_image\",\n                        value: function twitter_name_profile_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"twitter_name\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"gravatar_image\",\n                        value: function gravatar_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"gravatar\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"fetch_image\",\n                        value: function fetch_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"fetch\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"video\",\n                        value: function video(publicId) {\n                            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            return this.videoTag(publicId, options).toHtml();\n                        }\n                    },\n                    {\n                        key: \"videoTag\",\n                        value: function videoTag(publicId, options) {\n                            options = defaults({}, options, this.config());\n                            return new videotag(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"sprite_css\",\n                        value: function sprite_css(publicId, options) {\n                            options = assign_root_assign_default()({\n                                type: \"sprite\"\n                            }, options);\n                            if (!publicId.match(/.css$/)) {\n                                options.format = \"css\";\n                            }\n                            return this.url(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"responsive\",\n                        value: function responsive(options) {\n                            var _this = this;\n                            var bootstrap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n                            var ref, ref1, ref2, responsiveClass, responsiveResize, timeout;\n                            this.responsiveConfig = merge_root_merge_default()(this.responsiveConfig || {}, options);\n                            responsiveClass = (ref = this.responsiveConfig.responsive_class) != null ? ref : this.config(\"responsive_class\");\n                            if (bootstrap) {\n                                this.cloudinary_update(\"img.\".concat(responsiveClass, \", img.cld-hidpi\"), this.responsiveConfig);\n                            }\n                            responsiveResize = (ref1 = (ref2 = this.responsiveConfig.responsive_resize) != null ? ref2 : this.config(\"responsive_resize\")) != null ? ref1 : true;\n                            if (responsiveResize && !this.responsiveResizeInitialized) {\n                                this.responsiveConfig.resizing = this.responsiveResizeInitialized = true;\n                                timeout = null;\n                                var makeResponsive = function makeResponsive() {\n                                    var debounce, ref3, ref4, reset, run, wait, waitFunc;\n                                    debounce = (ref3 = (ref4 = _this.responsiveConfig.responsive_debounce) != null ? ref4 : _this.config(\"responsive_debounce\")) != null ? ref3 : 100;\n                                    reset = function reset() {\n                                        if (timeout) {\n                                            clearTimeout(timeout);\n                                            timeout = null;\n                                        }\n                                    };\n                                    run = function run() {\n                                        return _this.cloudinary_update(\"img.\".concat(responsiveClass), _this.responsiveConfig);\n                                    };\n                                    waitFunc = function waitFunc() {\n                                        reset();\n                                        return run();\n                                    };\n                                    wait = function wait() {\n                                        reset();\n                                        timeout = setTimeout(waitFunc, debounce);\n                                    };\n                                    if (debounce) {\n                                        return wait();\n                                    } else {\n                                        return run();\n                                    }\n                                };\n                                window.addEventListener(\"resize\", makeResponsive);\n                                return function() {\n                                    return window.removeEventListener(\"resize\", makeResponsive);\n                                };\n                            }\n                        }\n                    },\n                    {\n                        key: \"calc_breakpoint\",\n                        value: function calc_breakpoint(element, width, steps) {\n                            var breakpoints = lodash_getData(element, \"breakpoints\") || lodash_getData(element, \"stoppoints\") || this.config(\"breakpoints\") || this.config(\"stoppoints\") || defaultBreakpoints;\n                            if (isFunction_root_isFunction_default()(breakpoints)) {\n                                return breakpoints(width, steps);\n                            } else {\n                                if (isString_root_isString_default()(breakpoints)) {\n                                    breakpoints = breakpoints.split(\",\").map(function(point) {\n                                        return parseInt(point);\n                                    }).sort(function(a, b) {\n                                        return a - b;\n                                    });\n                                }\n                                return closestAbove(breakpoints, width);\n                            }\n                        }\n                    },\n                    {\n                        key: \"calc_stoppoint\",\n                        value: function calc_stoppoint(element, width, steps) {\n                            return this.calc_breakpoint(element, width, steps);\n                        }\n                    },\n                    {\n                        key: \"device_pixel_ratio\",\n                        value: function device_pixel_ratio(roundDpr) {\n                            roundDpr = roundDpr == null ? true : roundDpr;\n                            var dpr = ( false ? 0 : void 0) || 1;\n                            if (roundDpr) {\n                                dpr = Math.ceil(dpr);\n                            }\n                            if (dpr <= 0 || dpr === 0 / 0) {\n                                dpr = 1;\n                            }\n                            var dprString = dpr.toString();\n                            if (dprString.match(/^\\d+$/)) {\n                                dprString += \".0\";\n                            }\n                            return dprString;\n                        }\n                    },\n                    {\n                        key: \"processImageTags\",\n                        value: function processImageTags(nodes, options) {\n                            if (isEmpty(nodes)) {\n                                // similar to `$.fn.cloudinary`\n                                return this;\n                            }\n                            options = defaults({}, options || {}, this.config());\n                            var images = nodes.filter(function(node) {\n                                return /^img$/i.test(node.tagName);\n                            }).map(function(node) {\n                                var imgOptions = assign_root_assign_default()({\n                                    width: node.getAttribute(\"width\"),\n                                    height: node.getAttribute(\"height\"),\n                                    src: node.getAttribute(\"src\")\n                                }, options);\n                                var publicId = imgOptions[\"source\"] || imgOptions[\"src\"];\n                                delete imgOptions[\"source\"];\n                                delete imgOptions[\"src\"];\n                                var attr = new src_transformation(imgOptions).toHtmlAttributes();\n                                lodash_setData(node, \"src-cache\", url_url(publicId, imgOptions));\n                                node.setAttribute(\"width\", attr.width);\n                                node.setAttribute(\"height\", attr.height);\n                                return node;\n                            });\n                            this.cloudinary_update(images, options);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"cloudinary_update\",\n                        value: function cloudinary_update(elements, options) {\n                            var _this2 = this;\n                            var containerWidth, dataSrc, match, ref4, requiredWidth;\n                            if (elements === null) {\n                                return this;\n                            }\n                            if (options == null) {\n                                options = {};\n                            }\n                            var responsive = options.responsive != null ? options.responsive : this.config(\"responsive\");\n                            elements = normalizeToArray(elements);\n                            var responsiveClass;\n                            if (this.responsiveConfig && this.responsiveConfig.responsive_class != null) {\n                                responsiveClass = this.responsiveConfig.responsive_class;\n                            } else if (options.responsive_class != null) {\n                                responsiveClass = options.responsive_class;\n                            } else {\n                                responsiveClass = this.config(\"responsive_class\");\n                            }\n                            var roundDpr = options.round_dpr != null ? options.round_dpr : this.config(\"round_dpr\");\n                            elements.forEach(function(tag) {\n                                if (/img/i.test(tag.tagName)) {\n                                    var setUrl = true;\n                                    if (responsive) {\n                                        lodash_addClass(tag, responsiveClass);\n                                    }\n                                    dataSrc = lodash_getData(tag, \"src-cache\") || lodash_getData(tag, \"src\");\n                                    if (!isEmpty(dataSrc)) {\n                                        // Update dpr according to the device's devicePixelRatio\n                                        dataSrc = updateDpr.call(_this2, dataSrc, roundDpr);\n                                        if (htmltag.isResponsive(tag, responsiveClass)) {\n                                            containerWidth = cloudinary_findContainerWidth(tag);\n                                            if (containerWidth !== 0) {\n                                                if (/w_auto:breakpoints/.test(dataSrc)) {\n                                                    requiredWidth = cloudinary_maxWidth(containerWidth, tag);\n                                                    if (requiredWidth) {\n                                                        dataSrc = dataSrc.replace(/w_auto:breakpoints([_0-9]*)(:[0-9]+)?/, \"w_auto:breakpoints$1:\".concat(requiredWidth));\n                                                    } else {\n                                                        setUrl = false;\n                                                    }\n                                                } else {\n                                                    match = /w_auto(:(\\d+))?/.exec(dataSrc);\n                                                    if (match) {\n                                                        requiredWidth = applyBreakpoints.call(_this2, tag, containerWidth, match[2], options);\n                                                        requiredWidth = cloudinary_maxWidth(requiredWidth, tag);\n                                                        if (requiredWidth) {\n                                                            dataSrc = dataSrc.replace(/w_auto[^,\\/]*/g, \"w_\".concat(requiredWidth));\n                                                        } else {\n                                                            setUrl = false;\n                                                        }\n                                                    }\n                                                }\n                                                lodash_removeAttribute(tag, \"width\");\n                                                if (!options.responsive_preserve_height) {\n                                                    lodash_removeAttribute(tag, \"height\");\n                                                }\n                                            } else {\n                                                // Container doesn't know the size yet - usually because the image is hidden or outside the DOM.\n                                                setUrl = false;\n                                            }\n                                        }\n                                        var isLazyLoading = options.loading === \"lazy\" && !_this2.isNativeLazyLoadSupported() && _this2.isLazyLoadSupported() && !elements[0].getAttribute(\"src\");\n                                        if (setUrl || isLazyLoading) {\n                                            // If data-width exists, set width to be data-width\n                                            _this2.setAttributeIfExists(elements[0], \"width\", \"data-width\");\n                                        }\n                                        if (setUrl && !isLazyLoading) {\n                                            lodash_setAttribute(tag, \"src\", dataSrc);\n                                        }\n                                    }\n                                }\n                            });\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setAttributeIfExists\",\n                        value: function setAttributeIfExists(element, toAttribute, fromAttribute) {\n                            var attributeValue = element.getAttribute(fromAttribute);\n                            if (attributeValue != null) {\n                                lodash_setAttribute(element, toAttribute, attributeValue);\n                            }\n                        }\n                    },\n                    {\n                        key: \"isLazyLoadSupported\",\n                        value: function isLazyLoadSupported() {\n                            return window && \"IntersectionObserver\" in window;\n                        }\n                    },\n                    {\n                        key: \"isNativeLazyLoadSupported\",\n                        value: function isNativeLazyLoadSupported() {\n                            return \"loading\" in HTMLImageElement.prototype;\n                        }\n                    },\n                    {\n                        key: \"transformation\",\n                        value: function transformation(options) {\n                            return src_transformation[\"new\"](this.config()).fromOptions(options).setParent(this);\n                        }\n                    },\n                    {\n                        key: \"injectTransparentVideoElement\",\n                        value: function injectTransparentVideoElement(htmlElContainer, publicId) {\n                            var _this3 = this;\n                            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                            return new Promise(function(resolve, reject) {\n                                if (!htmlElContainer) {\n                                    reject({\n                                        status: \"error\",\n                                        message: \"Expecting htmlElContainer to be HTMLElement\"\n                                    });\n                                }\n                                transparentVideo_enforceOptionsForTransparentVideo(options);\n                                var videoURL = _this3.video_url(publicId, options);\n                                transparentVideo_checkSupportForTransparency().then(function(isNativelyTransparent) {\n                                    var mountPromise;\n                                    if (isNativelyTransparent) {\n                                        mountPromise = transparentVideo_mountCloudinaryVideoTag(htmlElContainer, _this3, publicId, options);\n                                        resolve(htmlElContainer);\n                                    } else {\n                                        mountPromise = transparentVideo_mountSeeThruCanvasTag(htmlElContainer, videoURL, options);\n                                    }\n                                    mountPromise.then(function() {\n                                        resolve(htmlElContainer);\n                                    })[\"catch\"](function(_ref) {\n                                        var status = _ref.status, message = _ref.message;\n                                        reject({\n                                            status: status,\n                                            message: message\n                                        });\n                                    });\n                                // catch for checkSupportForTransparency()\n                                })[\"catch\"](function(_ref2) {\n                                    var status = _ref2.status, message = _ref2.message;\n                                    reject({\n                                        status: status,\n                                        message: message\n                                    });\n                                });\n                            });\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(options) {\n                            return new this(options);\n                        }\n                    }\n                ]);\n            }();\n            assign_root_assign_default()(cloudinary_Cloudinary, constants_namespaceObject);\n            /* harmony default export */ var cloudinary = cloudinary_Cloudinary;\n            // CONCATENATED MODULE: ./src/namespace/cloudinary-core.js\n            /**\n * Creates the namespace for Cloudinary\n */ /* harmony default export */ var cloudinary_core = __nested_webpack_exports__[\"default\"] = {\n                ClientHintsMetaTag: clienthintsmetatag,\n                Cloudinary: cloudinary,\n                Condition: condition,\n                Configuration: src_configuration,\n                crc32: src_crc32,\n                Expression: expression,\n                FetchLayer: fetchlayer,\n                HtmlTag: htmltag,\n                ImageTag: imagetag,\n                Layer: layer_layer,\n                PictureTag: picturetag,\n                SubtitlesLayer: subtitleslayer,\n                TextLayer: textlayer,\n                Transformation: src_transformation,\n                utf8_encode: src_utf8_encode,\n                Util: lodash_namespaceObject,\n                VideoTag: videotag\n            };\n        /***/ },\n        /***/ \"lodash/assign\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_assign__;\n        /***/ },\n        /***/ \"lodash/cloneDeep\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_cloneDeep__;\n        /***/ },\n        /***/ \"lodash/compact\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_compact__;\n        /***/ },\n        /***/ \"lodash/difference\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_difference__;\n        /***/ },\n        /***/ \"lodash/functions\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_functions__;\n        /***/ },\n        /***/ \"lodash/identity\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_identity__;\n        /***/ },\n        /***/ \"lodash/includes\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_includes__;\n        /***/ },\n        /***/ \"lodash/isArray\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isArray__;\n        /***/ },\n        /***/ \"lodash/isElement\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isElement__;\n        /***/ },\n        /***/ \"lodash/isFunction\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isFunction__;\n        /***/ },\n        /***/ \"lodash/isPlainObject\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isPlainObject__;\n        /***/ },\n        /***/ \"lodash/isString\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isString__;\n        /***/ },\n        /***/ \"lodash/merge\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_merge__;\n        /***/ },\n        /***/ \"lodash/trim\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_trim__;\n        /***/ }\n    });\n}); //# sourceMappingURL=cloudinary-core.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2xvdWRpbmFyeS1jb3JlL2Nsb3VkaW5hcnktY29yZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7OztHQU1HLEdBQ0YsVUFBU0EsaUNBQWlDQyxJQUFJLEVBQUVDLE9BQU87SUFDdkQsSUFBRyxJQUFpRCxFQUNuREUsT0FBT0QsT0FBTyxHQUFHRCxRQUFRRyxtQkFBT0EsQ0FBQyxvQ0FBZSxHQUFHQSxtQkFBT0EsQ0FBQywwQ0FBa0IsR0FBR0EsbUJBQU9BLENBQUMsc0NBQWdCLEdBQUdBLG1CQUFPQSxDQUFDLDRDQUFtQixHQUFHQSxtQkFBT0EsQ0FBQywwQ0FBa0IsR0FBR0EsbUJBQU9BLENBQUMsd0NBQWlCLEdBQUdBLG1CQUFPQSxDQUFDLHdDQUFpQixHQUFHQSxtQkFBT0EsQ0FBQyxzQ0FBZ0IsR0FBR0EsbUJBQU9BLENBQUMsMENBQWtCLEdBQUdBLG1CQUFPQSxDQUFDLDRDQUFtQixHQUFHQSxtQkFBT0EsQ0FBQyxrREFBc0IsR0FBR0EsbUJBQU9BLENBQUMsd0NBQWlCLEdBQUdBLG1CQUFPQSxDQUFDLGtDQUFjLEdBQUdBLG1CQUFPQSxDQUFDLGdDQUFhO1NBQzNaLEVBSzRWO0FBQ2xXLEdBQUcsUUFBTSxTQUFTRyx5Q0FBeUMsRUFBRUMsNENBQTRDLEVBQUVDLDBDQUEwQyxFQUFFQyw2Q0FBNkMsRUFBRUMsNENBQTRDLEVBQUVDLDJDQUEyQyxFQUFFQywyQ0FBMkMsRUFBRUMsMENBQTBDLEVBQUVDLDRDQUE0QyxFQUFFQyw2Q0FBNkMsRUFBRUMsZ0RBQWdELEVBQUVDLDJDQUEyQyxFQUFFQyx3Q0FBd0MsRUFBRUMsdUNBQXVDO0lBQ3ZvQixPQUFnQixNQUFILEdBQUksU0FBU0MsT0FBTztRQUNqQyxNQUFNLEdBQUksbUJBQW1CO1FBQzdCLE1BQU0sR0FBSSxJQUFJQyxtQkFBbUIsQ0FBQztRQUNsQyxNQUFNLEdBQ04sTUFBTSxHQUFJLHVCQUF1QjtRQUNqQyxNQUFNLEdBQUksU0FBU0MsK0JBQW1CQSxDQUFDQyxR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cGxveW1lbnQvLi9ub2RlX21vZHVsZXMvY2xvdWRpbmFyeS1jb3JlL2Nsb3VkaW5hcnktY29yZS5qcz9mNzNjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICAgKiBjbG91ZGluYXJ5LWNvcmUuanNcbiAgICogQ2xvdWRpbmFyeSdzIEphdmFTY3JpcHQgbGlicmFyeSAtIFZlcnNpb24gMi4xNC4wXG4gICAqIENvcHlyaWdodCBDbG91ZGluYXJ5XG4gICAqIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2xvdWRpbmFyeS9jbG91ZGluYXJ5X2pzXG4gICAqXG4gICAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwibG9kYXNoL2Fzc2lnblwiKSwgcmVxdWlyZShcImxvZGFzaC9jbG9uZURlZXBcIiksIHJlcXVpcmUoXCJsb2Rhc2gvY29tcGFjdFwiKSwgcmVxdWlyZShcImxvZGFzaC9kaWZmZXJlbmNlXCIpLCByZXF1aXJlKFwibG9kYXNoL2Z1bmN0aW9uc1wiKSwgcmVxdWlyZShcImxvZGFzaC9pZGVudGl0eVwiKSwgcmVxdWlyZShcImxvZGFzaC9pbmNsdWRlc1wiKSwgcmVxdWlyZShcImxvZGFzaC9pc0FycmF5XCIpLCByZXF1aXJlKFwibG9kYXNoL2lzRWxlbWVudFwiKSwgcmVxdWlyZShcImxvZGFzaC9pc0Z1bmN0aW9uXCIpLCByZXF1aXJlKFwibG9kYXNoL2lzUGxhaW5PYmplY3RcIiksIHJlcXVpcmUoXCJsb2Rhc2gvaXNTdHJpbmdcIiksIHJlcXVpcmUoXCJsb2Rhc2gvbWVyZ2VcIiksIHJlcXVpcmUoXCJsb2Rhc2gvdHJpbVwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJsb2Rhc2gvYXNzaWduXCIsIFwibG9kYXNoL2Nsb25lRGVlcFwiLCBcImxvZGFzaC9jb21wYWN0XCIsIFwibG9kYXNoL2RpZmZlcmVuY2VcIiwgXCJsb2Rhc2gvZnVuY3Rpb25zXCIsIFwibG9kYXNoL2lkZW50aXR5XCIsIFwibG9kYXNoL2luY2x1ZGVzXCIsIFwibG9kYXNoL2lzQXJyYXlcIiwgXCJsb2Rhc2gvaXNFbGVtZW50XCIsIFwibG9kYXNoL2lzRnVuY3Rpb25cIiwgXCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiLCBcImxvZGFzaC9pc1N0cmluZ1wiLCBcImxvZGFzaC9tZXJnZVwiLCBcImxvZGFzaC90cmltXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImNsb3VkaW5hcnlcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJsb2Rhc2gvYXNzaWduXCIpLCByZXF1aXJlKFwibG9kYXNoL2Nsb25lRGVlcFwiKSwgcmVxdWlyZShcImxvZGFzaC9jb21wYWN0XCIpLCByZXF1aXJlKFwibG9kYXNoL2RpZmZlcmVuY2VcIiksIHJlcXVpcmUoXCJsb2Rhc2gvZnVuY3Rpb25zXCIpLCByZXF1aXJlKFwibG9kYXNoL2lkZW50aXR5XCIpLCByZXF1aXJlKFwibG9kYXNoL2luY2x1ZGVzXCIpLCByZXF1aXJlKFwibG9kYXNoL2lzQXJyYXlcIiksIHJlcXVpcmUoXCJsb2Rhc2gvaXNFbGVtZW50XCIpLCByZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIiksIHJlcXVpcmUoXCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiKSwgcmVxdWlyZShcImxvZGFzaC9pc1N0cmluZ1wiKSwgcmVxdWlyZShcImxvZGFzaC9tZXJnZVwiKSwgcmVxdWlyZShcImxvZGFzaC90cmltXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJjbG91ZGluYXJ5XCJdID0gZmFjdG9yeShyb290W1wiX1wiXVtcImFzc2lnblwiXSwgcm9vdFtcIl9cIl1bXCJjbG9uZURlZXBcIl0sIHJvb3RbXCJfXCJdW1wiY29tcGFjdFwiXSwgcm9vdFtcIl9cIl1bXCJkaWZmZXJlbmNlXCJdLCByb290W1wiX1wiXVtcImZ1bmN0aW9uc1wiXSwgcm9vdFtcIl9cIl1bXCJpZGVudGl0eVwiXSwgcm9vdFtcIl9cIl1bXCJpbmNsdWRlc1wiXSwgcm9vdFtcIl9cIl1bXCJpc0FycmF5XCJdLCByb290W1wiX1wiXVtcImlzRWxlbWVudFwiXSwgcm9vdFtcIl9cIl1bXCJpc0Z1bmN0aW9uXCJdLCByb290W1wiX1wiXVtcImlzUGxhaW5PYmplY3RcIl0sIHJvb3RbXCJfXCJdW1wiaXNTdHJpbmdcIl0sIHJvb3RbXCJfXCJdW1wibWVyZ2VcIl0sIHJvb3RbXCJfXCJdW1widHJpbVwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9hc3NpZ25fXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfY2xvbmVEZWVwX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2NvbXBhY3RfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfZGlmZmVyZW5jZV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9mdW5jdGlvbnNfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaWRlbnRpdHlfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaW5jbHVkZXNfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNBcnJheV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc0VsZW1lbnRfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNGdW5jdGlvbl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc1BsYWluT2JqZWN0X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzU3RyaW5nX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX21lcmdlX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX3RyaW1fXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9uYW1lc3BhY2UvY2xvdWRpbmFyeS1jb3JlLmpzXCIpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoe1xuXG4vKioqLyBcIi4vc3JjL25hbWVzcGFjZS9jbG91ZGluYXJ5LWNvcmUuanNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBFU00gQ09NUEFUIEZMQUdcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiQ2xpZW50SGludHNNZXRhVGFnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gY2xpZW50aGludHNtZXRhdGFnOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkNsb3VkaW5hcnlcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBjbG91ZGluYXJ5OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkNvbmRpdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGNvbmRpdGlvbjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJDb25maWd1cmF0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gc3JjX2NvbmZpZ3VyYXRpb247IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY3JjMzJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBzcmNfY3JjMzI7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiRXhwcmVzc2lvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGV4cHJlc3Npb247IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiRmV0Y2hMYXllclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGZldGNobGF5ZXI7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiSHRtbFRhZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGh0bWx0YWc7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiSW1hZ2VUYWdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBpbWFnZXRhZzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJMYXllclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGxheWVyX2xheWVyOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlBpY3R1cmVUYWdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBwaWN0dXJldGFnOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlN1YnRpdGxlc0xheWVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gc3VidGl0bGVzbGF5ZXI7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVGV4dExheWVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gdGV4dGxheWVyOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlRyYW5zZm9ybWF0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gc3JjX3RyYW5zZm9ybWF0aW9uOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInV0ZjhfZW5jb2RlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gc3JjX3V0ZjhfZW5jb2RlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlV0aWxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZpZGVvVGFnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gdmlkZW90YWc7IH0pO1xuXG4vLyBOQU1FU1BBQ0UgT0JKRUNUOiAuL3NyYy9jb25zdGFudHMuanNcbnZhciBjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0ID0ge307XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJWRVJTSU9OXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVkVSU0lPTjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJDRl9TSEFSRURfQ0ROXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQ0ZfU0hBUkVEX0NETjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJPTERfQUtBTUFJX1NIQVJFRF9DRE5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBPTERfQUtBTUFJX1NIQVJFRF9DRE47IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiQUtBTUFJX1NIQVJFRF9DRE5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBBS0FNQUlfU0hBUkVEX0NETjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJTSEFSRURfQ0ROXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU0hBUkVEX0NETjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJERUZBVUxUX1RJTUVPVVRfTVNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBERUZBVUxUX1RJTUVPVVRfTVM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiREVGQVVMVF9QT1NURVJfT1BUSU9OU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERFRkFVTFRfUE9TVEVSX09QVElPTlM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiREVGQVVMVF9WSURFT19TT1VSQ0VfVFlQRVNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBERUZBVUxUX1ZJREVPX1NPVVJDRV9UWVBFUzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJTRU9fVFlQRVNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTRU9fVFlQRVM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiREVGQVVMVF9JTUFHRV9QQVJBTVNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBERUZBVUxUX0lNQUdFX1BBUkFNUzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJERUZBVUxUX1ZJREVPX1BBUkFNU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERFRkFVTFRfVklERU9fUEFSQU1TOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIkRFRkFVTFRfVklERU9fU09VUkNFU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERFRkFVTFRfVklERU9fU09VUkNFUzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJERUZBVUxUX0VYVEVSTkFMX0xJQlJBUklFU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERFRkFVTFRfRVhURVJOQUxfTElCUkFSSUVTOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIlBMQUNFSE9MREVSX0lNQUdFX01PREVTXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUExBQ0VIT0xERVJfSU1BR0VfTU9ERVM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiQUNDRVNTSUJJTElUWV9NT0RFU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEFDQ0VTU0lCSUxJVFlfTU9ERVM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiVVJMX0tFWVNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBVUkxfS0VZUzsgfSk7XG5cbi8vIE5BTUVTUEFDRSBPQkpFQ1Q6IC4vc3JjL3V0aWwvbG9kYXNoLmpzXG52YXIgbG9kYXNoX25hbWVzcGFjZU9iamVjdCA9IHt9O1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZ2V0U0RLQW5hbHl0aWNzU2lnbmF0dXJlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0U0RLQW5hbHl0aWNzU2lnbmF0dXJlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImdldEFuYWx5dGljc09wdGlvbnNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRBbmFseXRpY3NPcHRpb25zOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImFzc2lnblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiY2xvbmVEZWVwXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwX2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJjb21wYWN0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY29tcGFjdF9yb290X2NvbXBhY3RfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImRpZmZlcmVuY2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkaWZmZXJlbmNlX3Jvb3RfZGlmZmVyZW5jZV9kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZnVuY3Rpb25zXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZnVuY3Rpb25zX3Jvb3RfZnVuY3Rpb25zX2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpZGVudGl0eVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlkZW50aXR5X3Jvb3RfaWRlbnRpdHlfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImluY2x1ZGVzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaW5jbHVkZXNfcm9vdF9pbmNsdWRlc19kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNBcnJheVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc1BsYWluT2JqZWN0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzU3RyaW5nXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwibWVyZ2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBtZXJnZV9yb290X21lcmdlX2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJjb250YWluc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzSW50ZXJzZWN0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0ludGVyc2VjdGlvbk9ic2VydmVyU3VwcG9ydGVkOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzTmF0aXZlTGF6eUxvYWRTdXBwb3J0ZWRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc05hdGl2ZUxhenlMb2FkU3VwcG9ydGVkOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImRldGVjdEludGVyc2VjdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRldGVjdEludGVyc2VjdGlvbjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJvbWl0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gb21pdDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJhbGxTdHJpbmdzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYmFzZXV0aWxfYWxsU3RyaW5nczsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJ3aXRob3V0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gd2l0aG91dDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc051bWJlckxpa2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc051bWJlckxpa2U7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwic21hcnRFc2NhcGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzbWFydEVzY2FwZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJkZWZhdWx0c1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRlZmF1bHRzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcIm9iamVjdFByb3RvXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gb2JqZWN0UHJvdG87IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwib2JqVG9TdHJpbmdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBvYmpUb1N0cmluZzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc09iamVjdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzT2JqZWN0OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImZ1bmNUYWdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmdW5jVGFnOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcInJlV29yZHNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiByZVdvcmRzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImNhbWVsQ2FzZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNhbWVsQ2FzZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJzbmFrZUNhc2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzbmFrZUNhc2U7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiY29udmVydEtleXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjb252ZXJ0S2V5czsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJ3aXRoQ2FtZWxDYXNlS2V5c1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHdpdGhDYW1lbENhc2VLZXlzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcIndpdGhTbmFrZUNhc2VLZXlzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gd2l0aFNuYWtlQ2FzZUtleXM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiYmFzZTY0RW5jb2RlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYmFzZTY0RW5jb2RlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImJhc2U2NEVuY29kZVVSTFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGJhc2U2NEVuY29kZVVSTDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJleHRyYWN0VXJsUGFyYW1zXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZXh0cmFjdFVybFBhcmFtczsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJwYXRjaEZldGNoRm9ybWF0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcGF0Y2hGZXRjaEZvcm1hdDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJvcHRpb25Db25zdW1lXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gb3B0aW9uQ29uc3VtZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc0VtcHR5XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNFbXB0eTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc0FuZHJvaWRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0FuZHJvaWQ7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNFZGdlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNFZGdlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzQ2hyb21lXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNDaHJvbWU7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNTYWZhcmlcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc1NhZmFyaTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc0VsZW1lbnRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0VsZW1lbnRfcm9vdF9pc0VsZW1lbnRfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzRnVuY3Rpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwidHJpbVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHRyaW1fcm9vdF90cmltX2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJnZXREYXRhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9kYXNoX2dldERhdGE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwic2V0RGF0YVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGxvZGFzaF9zZXREYXRhOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImdldEF0dHJpYnV0ZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGxvZGFzaF9nZXRBdHRyaWJ1dGU7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwic2V0QXR0cmlidXRlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9kYXNoX3NldEF0dHJpYnV0ZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJyZW1vdmVBdHRyaWJ1dGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsb2Rhc2hfcmVtb3ZlQXR0cmlidXRlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcInNldEF0dHJpYnV0ZXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzZXRBdHRyaWJ1dGVzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImhhc0NsYXNzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9kYXNoX2hhc0NsYXNzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImFkZENsYXNzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9kYXNoX2FkZENsYXNzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImdldFN0eWxlc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldFN0eWxlczsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJjc3NFeHBhbmRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjc3NFeHBhbmQ7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZG9tU3R5bGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkb21TdHlsZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJjdXJDU1NcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjdXJDU1M7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiY3NzVmFsdWVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjc3NWYWx1ZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJhdWdtZW50V2lkdGhPckhlaWdodFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGF1Z21lbnRXaWR0aE9ySGVpZ2h0OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImdldFdpZHRoT3JIZWlnaHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcIndpZHRoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9kYXNoX3dpZHRoOyB9KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRmOF9lbmNvZGUuanNcbi8qKlxuICogVVRGOCBlbmNvZGVyXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgdXRmOF9lbmNvZGU7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfdXRmOF9lbmNvZGUgPSAodXRmOF9lbmNvZGUgPSBmdW5jdGlvbiB1dGY4X2VuY29kZShhcmdTdHJpbmcpIHtcbiAgdmFyIGMxLCBlbmMsIGVuZCwgbiwgc3RhcnQsIHN0cmluZywgc3RyaW5nbCwgdXRmdGV4dDtcbiAgLy8gaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXRcbiAgLy8gKyAgIG9yaWdpbmFsIGJ5OiBXZWJ0b29sa2l0LmluZm8gKGh0dHA6Ly93d3cud2VidG9vbGtpdC5pbmZvLylcbiAgLy8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcbiAgLy8gKyAgIGltcHJvdmVkIGJ5OiBzb3diZXJyeVxuICAvLyArICAgIHR3ZWFrZWQgYnk6IEphY2tcbiAgLy8gKyAgIGJ1Z2ZpeGVkIGJ5OiBPbm5vIE1hcnNtYW5cbiAgLy8gKyAgIGltcHJvdmVkIGJ5OiBZdmVzIFN1Y2FldFxuICAvLyArICAgYnVnZml4ZWQgYnk6IE9ubm8gTWFyc21hblxuICAvLyArICAgYnVnZml4ZWQgYnk6IFVscmljaFxuICAvLyArICAgYnVnZml4ZWQgYnk6IFJhZmFsIEt1a2F3c2tpXG4gIC8vICsgICBpbXByb3ZlZCBieToga2lyaWxsb2lkXG4gIC8vICogICAgIGV4YW1wbGUgMTogdXRmOF9lbmNvZGUoJ0tldmluIHZhbiBab25uZXZlbGQnKTtcbiAgLy8gKiAgICAgcmV0dXJucyAxOiAnS2V2aW4gdmFuIFpvbm5ldmVsZCdcbiAgaWYgKGFyZ1N0cmluZyA9PT0gbnVsbCB8fCB0eXBlb2YgYXJnU3RyaW5nID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBzdHJpbmcgPSBhcmdTdHJpbmcgKyAnJztcbiAgLy8gLnJlcGxhY2UoL1xcclxcbi9nLCBcIlxcblwiKS5yZXBsYWNlKC9cXHIvZywgXCJcXG5cIik7XG4gIHV0ZnRleHQgPSAnJztcbiAgc3RhcnQgPSB2b2lkIDA7XG4gIGVuZCA9IHZvaWQgMDtcbiAgc3RyaW5nbCA9IDA7XG4gIHN0YXJ0ID0gZW5kID0gMDtcbiAgc3RyaW5nbCA9IHN0cmluZy5sZW5ndGg7XG4gIG4gPSAwO1xuICB3aGlsZSAobiA8IHN0cmluZ2wpIHtcbiAgICBjMSA9IHN0cmluZy5jaGFyQ29kZUF0KG4pO1xuICAgIGVuYyA9IG51bGw7XG4gICAgaWYgKGMxIDwgMTI4KSB7XG4gICAgICBlbmQrKztcbiAgICB9IGVsc2UgaWYgKGMxID4gMTI3ICYmIGMxIDwgMjA0OCkge1xuICAgICAgZW5jID0gU3RyaW5nLmZyb21DaGFyQ29kZShjMSA+PiA2IHwgMTkyLCBjMSAmIDYzIHwgMTI4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jID0gU3RyaW5nLmZyb21DaGFyQ29kZShjMSA+PiAxMiB8IDIyNCwgYzEgPj4gNiAmIDYzIHwgMTI4LCBjMSAmIDYzIHwgMTI4KTtcbiAgICB9XG4gICAgaWYgKGVuYyAhPT0gbnVsbCkge1xuICAgICAgaWYgKGVuZCA+IHN0YXJ0KSB7XG4gICAgICAgIHV0ZnRleHQgKz0gc3RyaW5nLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgdXRmdGV4dCArPSBlbmM7XG4gICAgICBzdGFydCA9IGVuZCA9IG4gKyAxO1xuICAgIH1cbiAgICBuKys7XG4gIH1cbiAgaWYgKGVuZCA+IHN0YXJ0KSB7XG4gICAgdXRmdGV4dCArPSBzdHJpbmcuc2xpY2Uoc3RhcnQsIHN0cmluZ2wpO1xuICB9XG4gIHJldHVybiB1dGZ0ZXh0O1xufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jcmMzMi5qc1xuXG5cbi8qKlxuICogQ1JDMzIgY2FsY3VsYXRvclxuICogRGVwZW5kcyBvbiAndXRmOF9lbmNvZGUnXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFRoZSBzdHJpbmcgdG8gY2FsY3VsYXRlIHRoZSBDUkMzMiBmb3IuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGNyYzMyKHN0cikge1xuICB2YXIgY3JjLCBpLCBpVG9wLCB0YWJsZSwgeCwgeTtcbiAgLy8gaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXRcbiAgLy8gKyAgIG9yaWdpbmFsIGJ5OiBXZWJ0b29sa2l0LmluZm8gKGh0dHA6Ly93d3cud2VidG9vbGtpdC5pbmZvLylcbiAgLy8gKyAgIGltcHJvdmVkIGJ5OiBUMGJzblxuICAvLyArICAgaW1wcm92ZWQgYnk6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjY0NzkzNS9qYXZhc2NyaXB0LWNyYzMyLWZ1bmN0aW9uLWFuZC1waHAtY3JjMzItbm90LW1hdGNoaW5nXG4gIC8vIC0gICAgZGVwZW5kcyBvbjogdXRmOF9lbmNvZGVcbiAgLy8gKiAgICAgZXhhbXBsZSAxOiBjcmMzMignS2V2aW4gdmFuIFpvbm5ldmVsZCcpO1xuICAvLyAqICAgICByZXR1cm5zIDE6IDEyNDk5OTEyNDlcbiAgc3RyID0gc3JjX3V0ZjhfZW5jb2RlKHN0cik7XG4gIHRhYmxlID0gJzAwMDAwMDAwIDc3MDczMDk2IEVFMEU2MTJDIDk5MDk1MUJBIDA3NkRDNDE5IDcwNkFGNDhGIEU5NjNBNTM1IDlFNjQ5NUEzIDBFREI4ODMyIDc5RENCOEE0IEUwRDVFOTFFIDk3RDJEOTg4IDA5QjY0QzJCIDdFQjE3Q0JEIEU3QjgyRDA3IDkwQkYxRDkxIDFEQjcxMDY0IDZBQjAyMEYyIEYzQjk3MTQ4IDg0QkU0MURFIDFBREFENDdEIDZERERFNEVCIEY0RDRCNTUxIDgzRDM4NUM3IDEzNkM5ODU2IDY0NkJBOEMwIEZENjJGOTdBIDhBNjVDOUVDIDE0MDE1QzRGIDYzMDY2Q0Q5IEZBMEYzRDYzIDhEMDgwREY1IDNCNkUyMEM4IDRDNjkxMDVFIEQ1NjA0MUU0IEEyNjc3MTcyIDNDMDNFNEQxIDRCMDRENDQ3IEQyMEQ4NUZEIEE1MEFCNTZCIDM1QjVBOEZBIDQyQjI5ODZDIERCQkJDOUQ2IEFDQkNGOTQwIDMyRDg2Q0UzIDQ1REY1Qzc1IERDRDYwRENGIEFCRDEzRDU5IDI2RDkzMEFDIDUxREUwMDNBIEM4RDc1MTgwIEJGRDA2MTE2IDIxQjRGNEI1IDU2QjNDNDIzIENGQkE5NTk5IEI4QkRBNTBGIDI4MDJCODlFIDVGMDU4ODA4IEM2MENEOUIyIEIxMEJFOTI0IDJGNkY3Qzg3IDU4Njg0QzExIEMxNjExREFCIEI2NjYyRDNEIDc2REM0MTkwIDAxREI3MTA2IDk4RDIyMEJDIEVGRDUxMDJBIDcxQjE4NTg5IDA2QjZCNTFGIDlGQkZFNEE1IEU4QjhENDMzIDc4MDdDOUEyIDBGMDBGOTM0IDk2MDlBODhFIEUxMEU5ODE4IDdGNkEwREJCIDA4NkQzRDJEIDkxNjQ2Qzk3IEU2NjM1QzAxIDZCNkI1MUY0IDFDNkM2MTYyIDg1NjUzMEQ4IEYyNjIwMDRFIDZDMDY5NUVEIDFCMDFBNTdCIDgyMDhGNEMxIEY1MEZDNDU3IDY1QjBEOUM2IDEyQjdFOTUwIDhCQkVCOEVBIEZDQjk4ODdDIDYyREQxRERGIDE1REEyRDQ5IDhDRDM3Q0YzIEZCRDQ0QzY1IDREQjI2MTU4IDNBQjU1MUNFIEEzQkMwMDc0IEQ0QkIzMEUyIDRBREZBNTQxIDNERDg5NUQ3IEE0RDFDNDZEIEQzRDZGNEZCIDQzNjlFOTZBIDM0NkVEOUZDIEFENjc4ODQ2IERBNjBCOEQwIDQ0MDQyRDczIDMzMDMxREU1IEFBMEE0QzVGIEREMEQ3Q0M5IDUwMDU3MTNDIDI3MDI0MUFBIEJFMEIxMDEwIEM5MEMyMDg2IDU3NjhCNTI1IDIwNkY4NUIzIEI5NjZENDA5IENFNjFFNDlGIDVFREVGOTBFIDI5RDlDOTk4IEIwRDA5ODIyIEM3RDdBOEI0IDU5QjMzRDE3IDJFQjQwRDgxIEI3QkQ1QzNCIEMwQkE2Q0FEIEVEQjg4MzIwIDlBQkZCM0I2IDAzQjZFMjBDIDc0QjFEMjlBIEVBRDU0NzM5IDlERDI3N0FGIDA0REIyNjE1IDczREMxNjgzIEUzNjMwQjEyIDk0NjQzQjg0IDBENkQ2QTNFIDdBNkE1QUE4IEU0MEVDRjBCIDkzMDlGRjlEIDBBMDBBRTI3IDdEMDc5RUIxIEYwMEY5MzQ0IDg3MDhBM0QyIDFFMDFGMjY4IDY5MDZDMkZFIEY3NjI1NzVEIDgwNjU2N0NCIDE5NkMzNjcxIDZFNkIwNkU3IEZFRDQxQjc2IDg5RDMyQkUwIDEwREE3QTVBIDY3REQ0QUNDIEY5QjlERjZGIDhFQkVFRkY5IDE3QjdCRTQzIDYwQjA4RUQ1IEQ2RDZBM0U4IEExRDE5MzdFIDM4RDhDMkM0IDRGREZGMjUyIEQxQkI2N0YxIEE2QkM1NzY3IDNGQjUwNkREIDQ4QjIzNjRCIEQ4MEQyQkRBIEFGMEExQjRDIDM2MDM0QUY2IDQxMDQ3QTYwIERGNjBFRkMzIEE4NjdERjU1IDMxNkU4RUVGIDQ2NjlCRTc5IENCNjFCMzhDIEJDNjY4MzFBIDI1NkZEMkEwIDUyNjhFMjM2IENDMEM3Nzk1IEJCMEI0NzAzIDIyMDIxNkI5IDU1MDUyNjJGIEM1QkEzQkJFIEIyQkQwQjI4IDJCQjQ1QTkyIDVDQjM2QTA0IEMyRDdGRkE3IEI1RDBDRjMxIDJDRDk5RThCIDVCREVBRTFEIDlCNjRDMkIwIEVDNjNGMjI2IDc1NkFBMzlDIDAyNkQ5MzBBIDlDMDkwNkE5IEVCMEUzNjNGIDcyMDc2Nzg1IDA1MDA1NzEzIDk1QkY0QTgyIEUyQjg3QTE0IDdCQjEyQkFFIDBDQjYxQjM4IDkyRDI4RTlCIEU1RDVCRTBEIDdDRENFRkI3IDBCREJERjIxIDg2RDNEMkQ0IEYxRDRFMjQyIDY4RERCM0Y4IDFGREE4MzZFIDgxQkUxNkNEIEY2QjkyNjVCIDZGQjA3N0UxIDE4Qjc0Nzc3IDg4MDg1QUU2IEZGMEY2QTcwIDY2MDYzQkNBIDExMDEwQjVDIDhGNjU5RUZGIEY4NjJBRTY5IDYxNkJGRkQzIDE2NkNDRjQ1IEEwMEFFMjc4IEQ3MEREMkVFIDRFMDQ4MzU0IDM5MDNCM0MyIEE3NjcyNjYxIEQwNjAxNkY3IDQ5Njk0NzREIDNFNkU3N0RCIEFFRDE2QTRBIEQ5RDY1QURDIDQwREYwQjY2IDM3RDgzQkYwIEE5QkNBRTUzIERFQkI5RUM1IDQ3QjJDRjdGIDMwQjVGRkU5IEJEQkRGMjFDIENBQkFDMjhBIDUzQjM5MzMwIDI0QjRBM0E2IEJBRDAzNjA1IENERDcwNjkzIDU0REU1NzI5IDIzRDk2N0JGIEIzNjY3QTJFIEM0NjE0QUI4IDVENjgxQjAyIDJBNkYyQjk0IEI0MEJCRTM3IEMzMEM4RUExIDVBMDVERjFCIDJEMDJFRjhEJztcbiAgY3JjID0gMDtcbiAgeCA9IDA7XG4gIHkgPSAwO1xuICBjcmMgPSBjcmMgXiAtMTtcbiAgaSA9IDA7XG4gIGlUb3AgPSBzdHIubGVuZ3RoO1xuICB3aGlsZSAoaSA8IGlUb3ApIHtcbiAgICB5ID0gKGNyYyBeIHN0ci5jaGFyQ29kZUF0KGkpKSAmIDB4RkY7XG4gICAgeCA9ICcweCcgKyB0YWJsZS5zdWJzdHIoeSAqIDksIDgpO1xuICAgIGNyYyA9IGNyYyA+Pj4gOCBeIHg7XG4gICAgaSsrO1xuICB9XG4gIGNyYyA9IGNyYyBeIC0xO1xuICAvL2NvbnZlcnQgdG8gdW5zaWduZWQgMzItYml0IGludCBpZiBuZWVkZWRcbiAgaWYgKGNyYyA8IDApIHtcbiAgICBjcmMgKz0gNDI5NDk2NzI5NjtcbiAgfVxuICByZXR1cm4gY3JjO1xufVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX2NyYzMyID0gKGNyYzMyKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3Nka0FuYWx5dGljcy9zdHJpbmdQYWQuanNcbmZ1bmN0aW9uIHN0cmluZ1BhZCh2YWx1ZSwgdGFyZ2V0TGVuZ3RoLCBwYWRTdHJpbmcpIHtcbiAgdGFyZ2V0TGVuZ3RoID0gdGFyZ2V0TGVuZ3RoID4+IDA7IC8vdHJ1bmNhdGUgaWYgbnVtYmVyIG9yIGNvbnZlcnQgbm9uLW51bWJlciB0byAwO1xuICBwYWRTdHJpbmcgPSBTdHJpbmcodHlwZW9mIHBhZFN0cmluZyAhPT0gJ3VuZGVmaW5lZCcgPyBwYWRTdHJpbmcgOiAnICcpO1xuICBpZiAodmFsdWUubGVuZ3RoID4gdGFyZ2V0TGVuZ3RoKSB7XG4gICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0TGVuZ3RoID0gdGFyZ2V0TGVuZ3RoIC0gdmFsdWUubGVuZ3RoO1xuICAgIGlmICh0YXJnZXRMZW5ndGggPiBwYWRTdHJpbmcubGVuZ3RoKSB7XG4gICAgICBwYWRTdHJpbmcgKz0gcmVwZWF0U3RyaW5nTnVtVGltZXMocGFkU3RyaW5nLCB0YXJnZXRMZW5ndGggLyBwYWRTdHJpbmcubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhZFN0cmluZy5zbGljZSgwLCB0YXJnZXRMZW5ndGgpICsgU3RyaW5nKHZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVwZWF0U3RyaW5nTnVtVGltZXMoc3RyaW5nLCB0aW1lcykge1xuICB2YXIgcmVwZWF0ZWRTdHJpbmcgPSBcIlwiO1xuICB3aGlsZSAodGltZXMgPiAwKSB7XG4gICAgcmVwZWF0ZWRTdHJpbmcgKz0gc3RyaW5nO1xuICAgIHRpbWVzLS07XG4gIH1cbiAgcmV0dXJuIHJlcGVhdGVkU3RyaW5nO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc2RrQW5hbHl0aWNzL2Jhc2U2NE1hcC5qc1xuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KHIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5KHIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHsgaWYgKHIpIHsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7IH0gfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShyKSB7IGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgbnVsbCAhPSByW1N5bWJvbC5pdGVyYXRvcl0gfHwgbnVsbCAhPSByW1wiQEBpdGVyYXRvclwiXSkgcmV0dXJuIEFycmF5LmZyb20ocik7IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB7IGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkocik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHsgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpOyBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTsgcmV0dXJuIG47IH1cblxudmFyIGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xudmFyIGJhc2U2NE1hcF9udW0gPSAwO1xudmFyIG1hcCA9IHt9O1xuX3RvQ29uc3VtYWJsZUFycmF5KGNoYXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChfY2hhcikge1xuICB2YXIga2V5ID0gYmFzZTY0TWFwX251bS50b1N0cmluZygyKTtcbiAga2V5ID0gc3RyaW5nUGFkKGtleSwgNiwgJzAnKTtcbiAgbWFwW2tleV0gPSBfY2hhcjtcbiAgYmFzZTY0TWFwX251bSsrO1xufSk7XG5cbi8qKlxuICogTWFwIG9mIHNpeC1iaXQgYmluYXJ5IGNvZGVzIHRvIEJhc2U2NCBjaGFyYWN0ZXJzXG4gKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGJhc2U2NE1hcCA9IChtYXApO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc2RrQW5hbHl0aWNzL3JldmVyc2VWZXJzaW9uLmpzXG5cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gQSBzZW1WZXIgbGlrZSBzdHJpbmcsIHgueS56IG9yIHgueSBpcyBhbGxvd2VkXG4gKiAgICAgICAgICAgICAgUmV2ZXJzZXMgdGhlIHZlcnNpb24gcG9zaXRpb25zLCB4LnkueiB0dXJucyB0byB6LnkueFxuICogICAgICAgICAgICAgIFBhZHMgZWFjaCBzZWdtZW50IHdpdGggJzAnIHNvIHRoZXkgaGF2ZSBsZW5ndGggb2YgMlxuICogICAgICAgICAgICAgIEV4YW1wbGU6IDEuMi4zIC0+IDAzLjAyLjAxXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VtVmVyIElucHV0IGNhbiBiZSBlaXRoZXIgeC55Lnogb3IgeC55XG4gKiBAcmV0dXJuIHtzdHJpbmd9IGluIHRoZSBmb3JtIG9mIHp6Lnl5Lnh4IChcbiAqL1xuZnVuY3Rpb24gcmV2ZXJzZVZlcnNpb24oc2VtVmVyKSB7XG4gIGlmIChzZW1WZXIuc3BsaXQoJy4nKS5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNlbVZlciwgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byBzZWdtZW50cycpO1xuICB9XG5cbiAgLy8gU3BsaXQgYnkgJy4nLCByZXZlcnNlLCBjcmVhdGUgbmV3IGFycmF5IHdpdGggcGFkZGVkIHZhbHVlcyBhbmQgY29uY2F0IGl0IHRvZ2V0aGVyXG4gIHJldHVybiBzZW1WZXIuc3BsaXQoJy4nKS5yZXZlcnNlKCkubWFwKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgcmV0dXJuIHN0cmluZ1BhZChzZWdtZW50LCAyLCAnMCcpO1xuICB9KS5qb2luKCcuJyk7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zZGtBbmFseXRpY3MvZW5jb2RlVmVyc2lvbi5qc1xuXG5cblxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBFbmNvZGVzIGEgc2VtVmVyLWxpa2UgdmVyc2lvbiBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZW1WZXIgSW5wdXQgY2FuIGJlIGVpdGhlciB4LnkueiBvciB4LnlcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgYnVpbHQgZnJvbSAzIGNoYXJhY3RlcnMgb2YgdGhlIGJhc2U2NCB0YWJsZSB0aGF0IGVuY29kZSB0aGUgc2VtVmVyXG4gKi9cbmZ1bmN0aW9uIGVuY29kZVZlcnNpb24oc2VtVmVyKSB7XG4gIHZhciBzdHJSZXN1bHQgPSAnJztcblxuICAvLyBzdXBwb3J0IHgueSBvciB4LnkueiBieSB1c2luZyAncGFydHMnIGFzIGEgdmFyaWFibGVcbiAgdmFyIHBhcnRzID0gc2VtVmVyLnNwbGl0KCcuJykubGVuZ3RoO1xuICB2YXIgcGFkZGVkU3RyaW5nTGVuZ3RoID0gcGFydHMgKiA2OyAvLyB3ZSBwYWQgdG8gZWl0aGVyIDEyIG9yIDE4IGNoYXJhY3RlcnNcblxuICAvLyByZXZlcnNlIChidXQgZG9uJ3QgbWlycm9yKSB0aGUgdmVyc2lvbi4gMS41LjE1IC0+IDE1LjUuMVxuICAvLyBQYWQgdG8gdHdvIHNwYWNlcywgMTUuNS4xIC0+IDE1LjA1LjAxXG4gIHZhciBwYWRkZWRSZXZlcnNlZFNlbXZlciA9IHJldmVyc2VWZXJzaW9uKHNlbVZlcik7XG5cbiAgLy8gdHVybiAxNS4wNS4wMSB0byBhIHN0cmluZyAnMTUwNTAxJyB0aGVuIHRvIGEgbnVtYmVyIDE1MDUwMVxuICB2YXIgbnVtID0gcGFyc2VJbnQocGFkZGVkUmV2ZXJzZWRTZW12ZXIuc3BsaXQoJy4nKS5qb2luKCcnKSk7XG5cbiAgLy8gUmVwcmVzZW50IGFzIGJpbmFyeSwgYWRkIGxlZnQgcGFkZGluZyB0byAxMiBvciAxOCBjaGFyYWN0ZXJzLlxuICAvLyAxNTAsNTAxIC0+IDEwMDEwMDEwMTExMTEwMDEwMVxuXG4gIHZhciBwYWRkZWRCaW5hcnkgPSBudW0udG9TdHJpbmcoMik7XG4gIHBhZGRlZEJpbmFyeSA9IHN0cmluZ1BhZChwYWRkZWRCaW5hcnksIHBhZGRlZFN0cmluZ0xlbmd0aCwgJzAnKTtcblxuICAvLyBTdG9wIGluIGNhc2UgYW4gaW52YWxpZCB2ZXJzaW9uIG51bWJlciB3YXMgcHJvdmlkZWRcbiAgLy8gcGFkZGVkQmluYXJ5IG11c3QgYmUgYnVpbHQgZnJvbSBzZWN0aW9ucyBvZiA2IGJpdHNcbiAgaWYgKHBhZGRlZEJpbmFyeS5sZW5ndGggJSA2ICE9PSAwKSB7XG4gICAgdGhyb3cgJ1ZlcnNpb24gbXVzdCBiZSBzbWFsbGVyIHRoYW4gNDMuMjEuMjYpJztcbiAgfVxuXG4gIC8vIHR1cm4gZXZlcnkgNiBiaXRzIGludG8gYSBjaGFyYWN0ZXIgdXNpbmcgdGhlIGJhc2U2NE1hcFxuICBwYWRkZWRCaW5hcnkubWF0Y2goLy57MSw2fS9nKS5mb3JFYWNoKGZ1bmN0aW9uIChiaXRTdHJpbmcpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhiaXRTdHJpbmcpO1xuICAgIHN0clJlc3VsdCArPSBiYXNlNjRNYXBbYml0U3RyaW5nXTtcbiAgfSk7XG4gIHJldHVybiBzdHJSZXN1bHQ7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zZGtBbmFseXRpY3MvZ2V0U0RLQW5hbHl0aWNzU2lnbmF0dXJlLmpzXG5cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gR2V0cyB0aGUgU0RLIHNpZ25hdHVyZSBieSBlbmNvZGluZyB0aGUgU0RLIHZlcnNpb24gYW5kIHRlY2ggdmVyc2lvblxuICogQHBhcmFtIHt7XG4gKiAgICBbdGVjaFZlcnNpb25dOnN0cmluZyxcbiAqICAgIFtzZGtTZW12ZXJdOiBzdHJpbmcsXG4gKiAgICBbc2RrQ29kZV06IHN0cmluZyxcbiAqICAgIFtmZWF0dXJlXTogc3RyaW5nXG4gKiB9fSBhbmFseXRpY3NPcHRpb25zXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHNka0FuYWx5dGljc1NpZ25hdHVyZVxuICovXG5mdW5jdGlvbiBnZXRTREtBbmFseXRpY3NTaWduYXR1cmUoKSB7XG4gIHZhciBhbmFseXRpY3NPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdHJ5IHtcbiAgICB2YXIgdHdvUGFydFZlcnNpb24gPSByZW1vdmVQYXRjaEZyb21TZW12ZXIoYW5hbHl0aWNzT3B0aW9ucy50ZWNoVmVyc2lvbik7XG4gICAgdmFyIGVuY29kZWRTREtWZXJzaW9uID0gZW5jb2RlVmVyc2lvbihhbmFseXRpY3NPcHRpb25zLnNka1NlbXZlcik7XG4gICAgdmFyIGVuY29kZWRUZWNoVmVyc2lvbiA9IGVuY29kZVZlcnNpb24odHdvUGFydFZlcnNpb24pO1xuICAgIHZhciBmZWF0dXJlQ29kZSA9IGFuYWx5dGljc09wdGlvbnMuZmVhdHVyZTtcbiAgICB2YXIgU0RLQ29kZSA9IGFuYWx5dGljc09wdGlvbnMuc2RrQ29kZTtcbiAgICB2YXIgYWxnb1ZlcnNpb24gPSAnQSc7IC8vIFRoZSBhbGdvIHZlcnNpb24gaXMgZGV0ZXJtaW5lZCBoZXJlLCBpdCBzaG91bGQgbm90IGJlIGFuIGFyZ3VtZW50XG5cbiAgICByZXR1cm4gXCJcIi5jb25jYXQoYWxnb1ZlcnNpb24pLmNvbmNhdChTREtDb2RlKS5jb25jYXQoZW5jb2RlZFNES1ZlcnNpb24pLmNvbmNhdChlbmNvZGVkVGVjaFZlcnNpb24pLmNvbmNhdChmZWF0dXJlQ29kZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBFaXRoZXIgU0RLIG9yIE5vZGUgdmVyc2lvbnMgd2VyZSB1bnBhcnNhYmxlXG4gICAgcmV0dXJuICdFJztcbiAgfVxufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIHBhdGNoIHZlcnNpb24gZnJvbSB0aGUgc2VtdmVyIGlmIGl0IGV4aXN0c1xuICogICAgICAgICAgICAgIFR1cm5zIHgueS56IE9SIHgueSBpbnRvIHgueVxuICogQHBhcmFtIHsneC55LnonIHx8ICd4LnknIHx8IHN0cmluZ30gc2VtVmVyU3RyXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZVBhdGNoRnJvbVNlbXZlcihzZW1WZXJTdHIpIHtcbiAgdmFyIHBhcnRzID0gc2VtVmVyU3RyLnNwbGl0KCcuJyk7XG4gIHJldHVybiBcIlwiLmNvbmNhdChwYXJ0c1swXSwgXCIuXCIpLmNvbmNhdChwYXJ0c1sxXSk7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zZGtBbmFseXRpY3MvZ2V0QW5hbHl0aWNzT3B0aW9ucy5qc1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gR2V0cyB0aGUgYW5hbHl0aWNzT3B0aW9ucyBmcm9tIG9wdGlvbnMtIHNob3VsZCBpbmNsdWRlIHNka1NlbXZlciwgdGVjaFZlcnNpb24sIHNka0NvZGUsIGFuZCBmZWF0dXJlXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnMge3tzZGtTZW12ZXI6IChzdHJpbmcpLCBzZGtDb2RlLCBmZWF0dXJlOiBzdHJpbmcsIHRlY2hWZXJzaW9uOiAoc3RyaW5nKX0gfHwge319XG4gKi9cbmZ1bmN0aW9uIGdldEFuYWx5dGljc09wdGlvbnMob3B0aW9ucykge1xuICB2YXIgYW5hbHl0aWNzT3B0aW9ucyA9IHtcbiAgICBzZGtTZW12ZXI6IG9wdGlvbnMuc2RrU2VtdmVyLFxuICAgIHRlY2hWZXJzaW9uOiBvcHRpb25zLnRlY2hWZXJzaW9uLFxuICAgIHNka0NvZGU6IG9wdGlvbnMuc2RrQ29kZSxcbiAgICBmZWF0dXJlOiAnMCdcbiAgfTtcbiAgaWYgKG9wdGlvbnMudXJsQW5hbHl0aWNzKSB7XG4gICAgaWYgKG9wdGlvbnMuYWNjZXNzaWJpbGl0eSkge1xuICAgICAgYW5hbHl0aWNzT3B0aW9ucy5mZWF0dXJlID0gJ0QnO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sb2FkaW5nID09PSAnbGF6eScpIHtcbiAgICAgIGFuYWx5dGljc09wdGlvbnMuZmVhdHVyZSA9ICdDJztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgYW5hbHl0aWNzT3B0aW9ucy5mZWF0dXJlID0gJ0EnO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wbGFjZWhvbGRlcikge1xuICAgICAgYW5hbHl0aWNzT3B0aW9ucy5mZWF0dXJlID0gJ0InO1xuICAgIH1cbiAgICByZXR1cm4gYW5hbHl0aWNzT3B0aW9ucztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9hc3NpZ25cIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2Fzc2lnblwiLFwiYW1kXCI6XCJsb2Rhc2gvYXNzaWduXCIsXCJyb290XCI6W1wiX1wiLFwiYXNzaWduXCJdfVxudmFyIGFzc2lnbl9yb290X2Fzc2lnbl8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2Fzc2lnblwiKTtcbnZhciBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oYXNzaWduX3Jvb3RfYXNzaWduXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9jbG9uZURlZXBcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2Nsb25lRGVlcFwiLFwiYW1kXCI6XCJsb2Rhc2gvY2xvbmVEZWVwXCIsXCJyb290XCI6W1wiX1wiLFwiY2xvbmVEZWVwXCJdfVxudmFyIGNsb25lRGVlcF9yb290X2Nsb25lRGVlcF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2Nsb25lRGVlcFwiKTtcbnZhciBjbG9uZURlZXBfcm9vdF9jbG9uZURlZXBfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9jb21wYWN0XCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9jb21wYWN0XCIsXCJhbWRcIjpcImxvZGFzaC9jb21wYWN0XCIsXCJyb290XCI6W1wiX1wiLFwiY29tcGFjdFwiXX1cbnZhciBjb21wYWN0X3Jvb3RfY29tcGFjdF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2NvbXBhY3RcIik7XG52YXIgY29tcGFjdF9yb290X2NvbXBhY3RfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29tcGFjdF9yb290X2NvbXBhY3RfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2RpZmZlcmVuY2VcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2RpZmZlcmVuY2VcIixcImFtZFwiOlwibG9kYXNoL2RpZmZlcmVuY2VcIixcInJvb3RcIjpbXCJfXCIsXCJkaWZmZXJlbmNlXCJdfVxudmFyIGRpZmZlcmVuY2Vfcm9vdF9kaWZmZXJlbmNlXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvZGlmZmVyZW5jZVwiKTtcbnZhciBkaWZmZXJlbmNlX3Jvb3RfZGlmZmVyZW5jZV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihkaWZmZXJlbmNlX3Jvb3RfZGlmZmVyZW5jZV8pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvZnVuY3Rpb25zXCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9mdW5jdGlvbnNcIixcImFtZFwiOlwibG9kYXNoL2Z1bmN0aW9uc1wiLFwicm9vdFwiOltcIl9cIixcImZ1bmN0aW9uc1wiXX1cbnZhciBmdW5jdGlvbnNfcm9vdF9mdW5jdGlvbnNfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC9mdW5jdGlvbnNcIik7XG52YXIgZnVuY3Rpb25zX3Jvb3RfZnVuY3Rpb25zX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGZ1bmN0aW9uc19yb290X2Z1bmN0aW9uc18pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvaWRlbnRpdHlcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2lkZW50aXR5XCIsXCJhbWRcIjpcImxvZGFzaC9pZGVudGl0eVwiLFwicm9vdFwiOltcIl9cIixcImlkZW50aXR5XCJdfVxudmFyIGlkZW50aXR5X3Jvb3RfaWRlbnRpdHlfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC9pZGVudGl0eVwiKTtcbnZhciBpZGVudGl0eV9yb290X2lkZW50aXR5X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGlkZW50aXR5X3Jvb3RfaWRlbnRpdHlfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2luY2x1ZGVzXCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9pbmNsdWRlc1wiLFwiYW1kXCI6XCJsb2Rhc2gvaW5jbHVkZXNcIixcInJvb3RcIjpbXCJfXCIsXCJpbmNsdWRlc1wiXX1cbnZhciBpbmNsdWRlc19yb290X2luY2x1ZGVzXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvaW5jbHVkZXNcIik7XG52YXIgaW5jbHVkZXNfcm9vdF9pbmNsdWRlc19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihpbmNsdWRlc19yb290X2luY2x1ZGVzXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9pc0FycmF5XCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9pc0FycmF5XCIsXCJhbWRcIjpcImxvZGFzaC9pc0FycmF5XCIsXCJyb290XCI6W1wiX1wiLFwiaXNBcnJheVwiXX1cbnZhciBpc0FycmF5X3Jvb3RfaXNBcnJheV8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2lzQXJyYXlcIik7XG52YXIgaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaXNBcnJheV9yb290X2lzQXJyYXlfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2lzUGxhaW5PYmplY3RcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2lzUGxhaW5PYmplY3RcIixcImFtZFwiOlwibG9kYXNoL2lzUGxhaW5PYmplY3RcIixcInJvb3RcIjpbXCJfXCIsXCJpc1BsYWluT2JqZWN0XCJdfVxudmFyIGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0XyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiKTtcbnZhciBpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF8pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvaXNTdHJpbmdcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2lzU3RyaW5nXCIsXCJhbWRcIjpcImxvZGFzaC9pc1N0cmluZ1wiLFwicm9vdFwiOltcIl9cIixcImlzU3RyaW5nXCJdfVxudmFyIGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC9pc1N0cmluZ1wiKTtcbnZhciBpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL21lcmdlXCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9tZXJnZVwiLFwiYW1kXCI6XCJsb2Rhc2gvbWVyZ2VcIixcInJvb3RcIjpbXCJfXCIsXCJtZXJnZVwiXX1cbnZhciBtZXJnZV9yb290X21lcmdlXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvbWVyZ2VcIik7XG52YXIgbWVyZ2Vfcm9vdF9tZXJnZV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihtZXJnZV9yb290X21lcmdlXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9pc0VsZW1lbnRcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2lzRWxlbWVudFwiLFwiYW1kXCI6XCJsb2Rhc2gvaXNFbGVtZW50XCIsXCJyb290XCI6W1wiX1wiLFwiaXNFbGVtZW50XCJdfVxudmFyIGlzRWxlbWVudF9yb290X2lzRWxlbWVudF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2lzRWxlbWVudFwiKTtcbnZhciBpc0VsZW1lbnRfcm9vdF9pc0VsZW1lbnRfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaXNFbGVtZW50X3Jvb3RfaXNFbGVtZW50Xyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9pc0Z1bmN0aW9uXCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9pc0Z1bmN0aW9uXCIsXCJhbWRcIjpcImxvZGFzaC9pc0Z1bmN0aW9uXCIsXCJyb290XCI6W1wiX1wiLFwiaXNGdW5jdGlvblwiXX1cbnZhciBpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2lzRnVuY3Rpb25cIik7XG52YXIgaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL3RyaW1cIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL3RyaW1cIixcImFtZFwiOlwibG9kYXNoL3RyaW1cIixcInJvb3RcIjpbXCJfXCIsXCJ0cmltXCJdfVxudmFyIHRyaW1fcm9vdF90cmltXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvdHJpbVwiKTtcbnZhciB0cmltX3Jvb3RfdHJpbV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih0cmltX3Jvb3RfdHJpbV8pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2xhenlMb2FkLmpzXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG4vKlxuICogSW5jbHVkZXMgdXRpbGl0eSBtZXRob2RzIGZvciBsYXp5IGxvYWRpbmcgbWVkaWFcbiAqL1xuXG4vKipcbiAqIENoZWNrIGlmIEludGVyc2VjdGlvbk9ic2VydmVyIGlzIHN1cHBvcnRlZFxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB3aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaXMgZGVmaW5lZFxuICovXG5mdW5jdGlvbiBpc0ludGVyc2VjdGlvbk9ic2VydmVyU3VwcG9ydGVkKCkge1xuICAvLyBDaGVjayB0aGF0ICdJbnRlcnNlY3Rpb25PYnNlcnZlcicgcHJvcGVydHkgaXMgZGVmaW5lZCBvbiB3aW5kb3dcbiAgcmV0dXJuICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yod2luZG93KSkgPT09IFwib2JqZWN0XCIgJiYgd2luZG93LkludGVyc2VjdGlvbk9ic2VydmVyO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIG5hdGl2ZSBsYXp5IGxvYWRpbmcgaXMgc3VwcG9ydGVkXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmICdsb2FkaW5nJyBwcm9wZXJ0eSBpcyBkZWZpbmVkIGZvciBIVE1MSW1hZ2VFbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGlzTmF0aXZlTGF6eUxvYWRTdXBwb3J0ZWQoKSB7XG4gIHJldHVybiAodHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihIVE1MSW1hZ2VFbGVtZW50KSkgPT09IFwib2JqZWN0XCIgJiYgSFRNTEltYWdlRWxlbWVudC5wcm90b3R5cGUubG9hZGluZztcbn1cblxuLyoqXG4gKiBDYWxscyBvbkludGVyc2VjdCgpIHdoZW4gaW50ZXJzZWN0aW9uIGlzIGRldGVjdGVkLCBvciB3aGVuXG4gKiBubyBuYXRpdmUgbGF6eSBsb2FkaW5nIG9yIHdoZW4gSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaXNuJ3Qgc3VwcG9ydGVkLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCAtIHRoZSBlbGVtZW50IHRvIG9ic2VydmVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uSW50ZXJzZWN0IC0gY2FsbGVkIHdoZW4gdGhlIGdpdmVuIGVsZW1lbnQgaXMgaW4gdmlld1xuICovXG5mdW5jdGlvbiBkZXRlY3RJbnRlcnNlY3Rpb24oZWwsIG9uSW50ZXJzZWN0KSB7XG4gIHRyeSB7XG4gICAgaWYgKGlzTmF0aXZlTGF6eUxvYWRTdXBwb3J0ZWQoKSB8fCAhaXNJbnRlcnNlY3Rpb25PYnNlcnZlclN1cHBvcnRlZCgpKSB7XG4gICAgICAvLyBSZXR1cm4gaWYgdGhlcmUncyBubyBuZWVkIG9yIHBvc3NpYmlsaXR5IHRvIGRldGVjdCBpbnRlcnNlY3Rpb25cbiAgICAgIG9uSW50ZXJzZWN0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGV0ZWN0IGludGVyc2VjdGlvbiB3aXRoIGdpdmVuIGVsZW1lbnQgdXNpbmcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICAgIGVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgaWYgKGVudHJ5LmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgb25JbnRlcnNlY3QoKTtcbiAgICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwge1xuICAgICAgdGhyZXNob2xkOiBbMCwgMC4wMV1cbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGVsKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIG9uSW50ZXJzZWN0KCk7XG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbnN0YW50cy5qc1xudmFyIFZFUlNJT04gPSBcIjIuNS4wXCI7XG52YXIgQ0ZfU0hBUkVEX0NETiA9IFwiZDNqcGw5MXB4ZXZia2guY2xvdWRmcm9udC5uZXRcIjtcbnZhciBPTERfQUtBTUFJX1NIQVJFRF9DRE4gPSBcImNsb3VkaW5hcnktYS5ha2FtYWloZC5uZXRcIjtcbnZhciBBS0FNQUlfU0hBUkVEX0NETiA9IFwicmVzLmNsb3VkaW5hcnkuY29tXCI7XG52YXIgU0hBUkVEX0NETiA9IEFLQU1BSV9TSEFSRURfQ0ROO1xudmFyIERFRkFVTFRfVElNRU9VVF9NUyA9IDEwMDAwO1xudmFyIERFRkFVTFRfUE9TVEVSX09QVElPTlMgPSB7XG4gIGZvcm1hdDogJ2pwZycsXG4gIHJlc291cmNlX3R5cGU6ICd2aWRlbydcbn07XG52YXIgREVGQVVMVF9WSURFT19TT1VSQ0VfVFlQRVMgPSBbJ3dlYm0nLCAnbXA0JywgJ29ndiddO1xudmFyIFNFT19UWVBFUyA9IHtcbiAgXCJpbWFnZS91cGxvYWRcIjogXCJpbWFnZXNcIixcbiAgXCJpbWFnZS9wcml2YXRlXCI6IFwicHJpdmF0ZV9pbWFnZXNcIixcbiAgXCJpbWFnZS9hdXRoZW50aWNhdGVkXCI6IFwiYXV0aGVudGljYXRlZF9pbWFnZXNcIixcbiAgXCJyYXcvdXBsb2FkXCI6IFwiZmlsZXNcIixcbiAgXCJ2aWRlby91cGxvYWRcIjogXCJ2aWRlb3NcIlxufTtcblxuLyoqXG4qIEBjb25zdCB7T2JqZWN0fSBDbG91ZGluYXJ5LkRFRkFVTFRfSU1BR0VfUEFSQU1TXG4qIERlZmF1bHRzIHZhbHVlcyBmb3IgaW1hZ2UgcGFyYW1ldGVycy5cbipcbiogKFByZXZpb3VzbHkgZGVmaW5lZCB1c2luZyBvcHRpb25fY29uc3VtZSgpIClcbiAqL1xudmFyIERFRkFVTFRfSU1BR0VfUEFSQU1TID0ge1xuICByZXNvdXJjZV90eXBlOiBcImltYWdlXCIsXG4gIHRyYW5zZm9ybWF0aW9uOiBbXSxcbiAgdHlwZTogJ3VwbG9hZCdcbn07XG5cbi8qKlxuKiBEZWZhdWx0cyB2YWx1ZXMgZm9yIHZpZGVvIHBhcmFtZXRlcnMuXG4qIEBjb25zdCB7T2JqZWN0fSBDbG91ZGluYXJ5LkRFRkFVTFRfVklERU9fUEFSQU1TXG4qIChQcmV2aW91c2x5IGRlZmluZWQgdXNpbmcgb3B0aW9uX2NvbnN1bWUoKSApXG4gKi9cbnZhciBERUZBVUxUX1ZJREVPX1BBUkFNUyA9IHtcbiAgZmFsbGJhY2tfY29udGVudDogJycsXG4gIHJlc291cmNlX3R5cGU6IFwidmlkZW9cIixcbiAgc291cmNlX3RyYW5zZm9ybWF0aW9uOiB7fSxcbiAgc291cmNlX3R5cGVzOiBERUZBVUxUX1ZJREVPX1NPVVJDRV9UWVBFUyxcbiAgdHJhbnNmb3JtYXRpb246IFtdLFxuICB0eXBlOiAndXBsb2FkJ1xufTtcblxuLyoqXG4gKiBSZWNvbW1lbmRlZCBzb3VyY2VzIGZvciB2aWRlbyB0YWdcbiAqIEBjb25zdCB7T2JqZWN0fSBDbG91ZGluYXJ5LkRFRkFVTFRfVklERU9fU09VUkNFU1xuICovXG52YXIgREVGQVVMVF9WSURFT19TT1VSQ0VTID0gW3tcbiAgdHlwZTogXCJtcDRcIixcbiAgY29kZWNzOiBcImhldjFcIixcbiAgdHJhbnNmb3JtYXRpb25zOiB7XG4gICAgdmlkZW9fY29kZWM6IFwiaDI2NVwiXG4gIH1cbn0sIHtcbiAgdHlwZTogXCJ3ZWJtXCIsXG4gIGNvZGVjczogXCJ2cDlcIixcbiAgdHJhbnNmb3JtYXRpb25zOiB7XG4gICAgdmlkZW9fY29kZWM6IFwidnA5XCJcbiAgfVxufSwge1xuICB0eXBlOiBcIm1wNFwiLFxuICB0cmFuc2Zvcm1hdGlvbnM6IHtcbiAgICB2aWRlb19jb2RlYzogXCJhdXRvXCJcbiAgfVxufSwge1xuICB0eXBlOiBcIndlYm1cIixcbiAgdHJhbnNmb3JtYXRpb25zOiB7XG4gICAgdmlkZW9fY29kZWM6IFwiYXV0b1wiXG4gIH1cbn1dO1xudmFyIERFRkFVTFRfRVhURVJOQUxfTElCUkFSSUVTID0ge1xuICBzZWVUaHJ1OiAnaHR0cHM6Ly91bnBrZy5jb20vc2VldGhydUA0L2Rpc3Qvc2VlVGhydS5taW4uanMnXG59O1xuXG4vKipcbiAqIFByZWRlZmluZWQgcGxhY2Vob2xkZXIgdHJhbnNmb3JtYXRpb25zXG4gKiBAY29uc3Qge09iamVjdH0gQ2xvdWRpbmFyeS5QTEFDRUhPTERFUl9JTUFHRV9NT0RFU1xuICovXG52YXIgUExBQ0VIT0xERVJfSU1BR0VfTU9ERVMgPSB7XG4gICdibHVyJzogW3tcbiAgICBlZmZlY3Q6ICdibHVyOjIwMDAnLFxuICAgIHF1YWxpdHk6IDEsXG4gICAgZmV0Y2hfZm9ybWF0OiAnYXV0bydcbiAgfV0sXG4gIC8vIERlZmF1bHRcbiAgJ3BpeGVsYXRlJzogW3tcbiAgICBlZmZlY3Q6ICdwaXhlbGF0ZScsXG4gICAgcXVhbGl0eTogMSxcbiAgICBmZXRjaF9mb3JtYXQ6ICdhdXRvJ1xuICB9XSxcbiAgLy8gR2VuZXJhdGVzIGEgcGl4ZWwgc2l6ZSBpbWFnZSB3aGljaCBjb2xvciBpcyB0aGUgcHJlZG9taW5hbnQgY29sb3Igb2YgdGhlIG9yaWdpbmFsIGltYWdlLlxuICAncHJlZG9taW5hbnQtY29sb3ItcGl4ZWwnOiBbe1xuICAgIHdpZHRoOiAnaXdfZGl2XzInLFxuICAgIGFzcGVjdF9yYXRpbzogMSxcbiAgICBjcm9wOiAncGFkJyxcbiAgICBiYWNrZ3JvdW5kOiAnYXV0bydcbiAgfSwge1xuICAgIGNyb3A6ICdjcm9wJyxcbiAgICB3aWR0aDogMSxcbiAgICBoZWlnaHQ6IDEsXG4gICAgZ3Jhdml0eTogJ25vcnRoX2Vhc3QnXG4gIH0sIHtcbiAgICBmZXRjaF9mb3JtYXQ6ICdhdXRvJyxcbiAgICBxdWFsaXR5OiAnYXV0bydcbiAgfV0sXG4gIC8vIEdlbmVyYXRlcyBhbiBpbWFnZSB3aGljaCBjb2xvciBpcyB0aGUgcHJlZG9taW5hbnQgY29sb3Igb2YgdGhlIG9yaWdpbmFsIGltYWdlLlxuICAncHJlZG9taW5hbnQtY29sb3InOiBbe1xuICAgIHZhcmlhYmxlczogW1snJGN1cnJXaWR0aCcsICd3J10sIFsnJGN1cnJIZWlnaHQnLCAnaCddXVxuICB9LCB7XG4gICAgd2lkdGg6ICdpd19kaXZfMicsXG4gICAgYXNwZWN0X3JhdGlvOiAxLFxuICAgIGNyb3A6ICdwYWQnLFxuICAgIGJhY2tncm91bmQ6ICdhdXRvJ1xuICB9LCB7XG4gICAgY3JvcDogJ2Nyb3AnLFxuICAgIHdpZHRoOiAxMCxcbiAgICBoZWlnaHQ6IDEwLFxuICAgIGdyYXZpdHk6ICdub3J0aF9lYXN0J1xuICB9LCB7XG4gICAgd2lkdGg6ICckY3VycldpZHRoJyxcbiAgICBoZWlnaHQ6ICckY3VyckhlaWdodCcsXG4gICAgY3JvcDogJ2ZpbGwnXG4gIH0sIHtcbiAgICBmZXRjaF9mb3JtYXQ6ICdhdXRvJyxcbiAgICBxdWFsaXR5OiAnYXV0bydcbiAgfV0sXG4gICd2ZWN0b3JpemUnOiBbe1xuICAgIGVmZmVjdDogJ3ZlY3Rvcml6ZTozOjAuMScsXG4gICAgZmV0Y2hfZm9ybWF0OiAnc3ZnJ1xuICB9XVxufTtcblxuLyoqXG4gKiBQcmVkZWZpbmVkIGFjY2Vzc2liaWxpdHkgdHJhbnNmb3JtYXRpb25zXG4gKiBAY29uc3Qge09iamVjdH0gQ2xvdWRpbmFyeS5BQ0NFU1NJQklMSVRZX01PREVTXG4gKi9cbnZhciBBQ0NFU1NJQklMSVRZX01PREVTID0ge1xuICBkYXJrbW9kZTogJ3RpbnQ6NzU6YmxhY2snLFxuICBicmlnaHRtb2RlOiAndGludDo1MDp3aGl0ZScsXG4gIG1vbm9jaHJvbWU6ICdncmF5c2NhbGUnLFxuICBjb2xvcmJsaW5kOiAnYXNzaXN0X2NvbG9yYmxpbmQnXG59O1xuXG4vKipcbiAqIEEgbGlzdCBvZiBrZXlzIHVzZWQgYnkgdGhlIHVybCgpIGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqL1xudmFyIFVSTF9LRVlTID0gWydhY2Nlc3NpYmlsaXR5JywgJ2FwaV9zZWNyZXQnLCAnYXV0aF90b2tlbicsICdjZG5fc3ViZG9tYWluJywgJ2Nsb3VkX25hbWUnLCAnY25hbWUnLCAnZm9ybWF0JywgJ3BsYWNlaG9sZGVyJywgJ3ByaXZhdGVfY2RuJywgJ3Jlc291cmNlX3R5cGUnLCAnc2VjdXJlJywgJ3NlY3VyZV9jZG5fc3ViZG9tYWluJywgJ3NlY3VyZV9kaXN0cmlidXRpb24nLCAnc2hvcnRlbicsICdzaWduX3VybCcsICdzaWduYXR1cmUnLCAnc3NsX2RldGVjdGVkJywgJ3R5cGUnLCAndXJsX3N1ZmZpeCcsICd1c2Vfcm9vdF9wYXRoJywgJ3ZlcnNpb24nXTtcblxuLyoqXG4gKiBUaGUgcmVzb3VyY2Ugc3RvcmFnZSB0eXBlXG4gKiBAdHlwZWRlZiB0eXBlXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQHByb3BlcnR5ICB7c3RyaW5nfSAndXBsb2FkJyBBIHJlc291cmNlIHVwbG9hZGVkIGRpcmVjdGx5IHRvIENsb3VkaW5hcnlcbiAqIEBwcm9wZXJ0eSAge3N0cmluZ30gJ2ZldGNoJyBBIHJlc291cmNlIGZldGNoZWQgYnkgQ2xvdWRpbmFyeSBmcm9tIGEgM3JkIHBhcnR5IHN0b3JhZ2VcbiAqIEBwcm9wZXJ0eSAge3N0cmluZ30gJ3ByaXZhdGUnXG4gKiBAcHJvcGVydHkgIHtzdHJpbmd9ICdhdXRoZW50aWNhdGVkJ1xuICogQHByb3BlcnR5ICB7c3RyaW5nfSAnc3ByaXRlJ1xuICogQHByb3BlcnR5ICB7c3RyaW5nfSAnZmFjZWJvb2snXG4gKiBAcHJvcGVydHkgIHtzdHJpbmd9ICd0d2l0dGVyJ1xuICogQHByb3BlcnR5ICB7c3RyaW5nfSAneW91dHViZSdcbiAqIEBwcm9wZXJ0eSAge3N0cmluZ30gJ3ZpbWVvJ1xuICpcbiAqL1xuXG4vKipcbiAqIFRoZSByZXNvdXJjZSB0eXBlXG4gKiBAdHlwZWRlZiByZXNvdXJjZVR5cGVcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gJ2ltYWdlJyBBbiBpbWFnZSBmaWxlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gJ3ZpZGVvJyBBIHZpZGVvIGZpbGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAncmF3JyAgIEEgcmF3IGZpbGVcbiAqL1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9iYXNldXRpbC5qc1xuZnVuY3Rpb24gYmFzZXV0aWxfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gYmFzZXV0aWxfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIGJhc2V1dGlsX3R5cGVvZihvKTsgfVxuLypcbiAqIEluY2x1ZGVzIGNvbW1vbiB1dGlsaXR5IG1ldGhvZHMgYW5kIHNoaW1zXG4gKi9cblxuXG5mdW5jdGlvbiBvbWl0KG9iaiwga2V5cykge1xuICBvYmogPSBvYmogfHwge307XG4gIHZhciBzcmNLZXlzID0gT2JqZWN0LmtleXMob2JqKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhaW5jbHVkZXNfcm9vdF9pbmNsdWRlc19kZWZhdWx0KCkoa2V5cywga2V5KTtcbiAgfSk7XG4gIHZhciBmaWx0ZXJlZCA9IHt9O1xuICBzcmNLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBmaWx0ZXJlZFtrZXldID0gb2JqW2tleV07XG4gIH0pO1xuICByZXR1cm4gZmlsdGVyZWQ7XG59XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgYWxsIGl0ZW1zIGluIGxpc3QgYXJlIHN0cmluZ3NcbiAqIEBmdW5jdGlvbiBVdGlsLmFsbFN0cmluZ1xuICogQHBhcmFtIHtBcnJheX0gbGlzdCAtIGFuIGFycmF5IG9mIGl0ZW1zXG4gKi9cbnZhciBiYXNldXRpbF9hbGxTdHJpbmdzID0gZnVuY3Rpb24gYWxsU3RyaW5ncyhsaXN0KSB7XG4gIHJldHVybiBsaXN0Lmxlbmd0aCAmJiBsaXN0LmV2ZXJ5KGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdC5hKTtcbn07XG5cbi8qKlxuKiBDcmVhdGVzIGEgbmV3IGFycmF5IHdpdGhvdXQgdGhlIGdpdmVuIGl0ZW0uXG4qIEBmdW5jdGlvbiBVdGlsLndpdGhvdXRcbiogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBvcmlnaW5hbCBhcnJheVxuKiBAcGFyYW0geyp9IGl0ZW0gLSB0aGUgaXRlbSB0byBleGNsdWRlIGZyb20gdGhlIG5ldyBhcnJheVxuKiBAcmV0dXJuIHtBcnJheX0gYSBuZXcgYXJyYXkgbWFkZSBvZiB0aGUgb3JpZ2luYWwgYXJyYXkncyBpdGVtcyBleGNlcHQgZm9yIGBpdGVtYFxuICovXG52YXIgd2l0aG91dCA9IGZ1bmN0aW9uIHdpdGhvdXQoYXJyYXksIGl0ZW0pIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcihmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2ICE9PSBpdGVtO1xuICB9KTtcbn07XG5cbi8qKlxuKiBSZXR1cm4gdHJ1ZSBpcyB2YWx1ZSBpcyBhIG51bWJlciBvciBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG51bWJlci5cbiogQGZ1bmN0aW9uIFV0aWwuaXNOdW1iZXJMaWtlXG4qIEBwYXJhbSB7Kn0gdmFsdWVcbiogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdmFsdWUgaXMgYSBudW1iZXJcbiogQGV4YW1wbGVcbiogICAgVXRpbC5pc051bWJlcigwKSAvLyB0cnVlXG4qICAgIFV0aWwuaXNOdW1iZXIoXCIxLjNcIikgLy8gdHJ1ZVxuKiAgICBVdGlsLmlzTnVtYmVyKFwiXCIpIC8vIGZhbHNlXG4qICAgIFV0aWwuaXNOdW1iZXIodW5kZWZpbmVkKSAvLyBmYWxzZVxuICovXG52YXIgaXNOdW1iZXJMaWtlID0gZnVuY3Rpb24gaXNOdW1iZXJMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICFpc05hTihwYXJzZUZsb2F0KHZhbHVlKSk7XG59O1xuXG4vKipcbiAqIEVzY2FwZSBhbGwgY2hhcmFjdGVycyBtYXRjaGluZyB1bnNhZmUgaW4gdGhlIGdpdmVuIHN0cmluZ1xuICogQGZ1bmN0aW9uIFV0aWwuc21hcnRFc2NhcGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSBzb3VyY2Ugc3RyaW5nIHRvIGVzY2FwZVxuICogQHBhcmFtIHtSZWdFeHB9IHVuc2FmZSAtIGNoYXJhY3RlcnMgdGhhdCBtdXN0IGJlIGVzY2FwZWRcbiAqIEByZXR1cm4ge3N0cmluZ30gZXNjYXBlZCBzdHJpbmdcbiAqL1xudmFyIHNtYXJ0RXNjYXBlID0gZnVuY3Rpb24gc21hcnRFc2NhcGUoc3RyaW5nKSB7XG4gIHZhciB1bnNhZmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IC8oW15hLXpBLVowLTlfLlxcLVxcLzpdKykvZztcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHVuc2FmZSwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIG1hdGNoLnNwbGl0KFwiXCIpLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIFwiJVwiICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBc3NpZ24gdmFsdWVzIGZyb20gc291cmNlcyBpZiB0aGV5IGFyZSBub3QgZGVmaW5lZCBpbiB0aGUgZGVzdGluYXRpb24uXG4gKiBPbmNlIGEgdmFsdWUgaXMgc2V0IGl0IGRvZXMgbm90IGNoYW5nZVxuICogQGZ1bmN0aW9uIFV0aWwuZGVmYXVsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0aW5hdGlvbiAtIHRoZSBvYmplY3QgdG8gYXNzaWduIGRlZmF1bHRzIHRvXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlIC0gdGhlIHNvdXJjZSBvYmplY3QocykgdG8gYXNzaWduIGRlZmF1bHRzIGZyb21cbiAqIEByZXR1cm4ge09iamVjdH0gZGVzdGluYXRpb24gYWZ0ZXIgaXQgd2FzIG1vZGlmaWVkXG4gKi9cbnZhciBkZWZhdWx0cyA9IGZ1bmN0aW9uIGRlZmF1bHRzKGRlc3RpbmF0aW9uKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzb3VyY2VzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4gc291cmNlcy5yZWR1Y2UoZnVuY3Rpb24gKGRlc3QsIHNvdXJjZSkge1xuICAgIHZhciBrZXksIHZhbHVlO1xuICAgIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgICAgdmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgIGlmIChkZXN0W2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgICBkZXN0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH0sIGRlc3RpbmF0aW9uKTtcbn07XG5cbi8qKioqKioqKioqKiBsb2Rhc2ggZnVuY3Rpb25zICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXG4gKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4jaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiNpc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiNpc09iamVjdCgxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlO1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdHlwZSA9IGJhc2V1dGlsX3R5cGVvZih2YWx1ZSk7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKTtcbn07XG52YXIgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbi8qKlxuKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4qIEBmdW5jdGlvbiBVdGlsLmlzRnVuY3Rpb25cbiogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4qIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4qIEBleGFtcGxlXG4qXG4qIGZ1bmN0aW9uIEZvbygpe307XG4qIGlzRnVuY3Rpb24oRm9vKTtcbiogLy8gPT4gdHJ1ZVxuKlxuKiBpc0Z1bmN0aW9uKC9hYmMvKTtcbiogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaSB3aGljaCByZXR1cm4gJ2Z1bmN0aW9uJyBmb3IgcmVnZXhlc1xuICAvLyBhbmQgU2FmYXJpIDggd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgY29uc3RydWN0b3JzLlxuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBmdW5jVGFnO1xufTtcblxuLyoqKioqKioqKioqIGxvZGFzaCBmdW5jdGlvbnMgKi9cbi8qKiBVc2VkIHRvIG1hdGNoIHdvcmRzIHRvIGNyZWF0ZSBjb21wb3VuZCB3b3Jkcy4gKi9cbnZhciByZVdvcmRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbG93ZXIsIHVwcGVyO1xuICB1cHBlciA9ICdbQS1aXSc7XG4gIGxvd2VyID0gJ1thLXpdKyc7XG4gIHJldHVybiBSZWdFeHAodXBwZXIgKyAnKyg/PScgKyB1cHBlciArIGxvd2VyICsgJyl8JyArIHVwcGVyICsgJz8nICsgbG93ZXIgKyAnfCcgKyB1cHBlciArICcrfFswLTldKycsICdnJyk7XG59KCk7XG5cbi8qKlxuKiBDb252ZXJ0IHN0cmluZyB0byBjYW1lbENhc2VcbiogQGZ1bmN0aW9uIFV0aWwuY2FtZWxDYXNlXG4qIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgLSB0aGUgc3RyaW5nIHRvIGNvbnZlcnRcbiogQHJldHVybiB7c3RyaW5nfSBpbiBjYW1lbENhc2UgZm9ybWF0XG4gKi9cbnZhciBjYW1lbENhc2UgPSBmdW5jdGlvbiBjYW1lbENhc2Uoc291cmNlKSB7XG4gIHZhciB3b3JkcyA9IHNvdXJjZS5tYXRjaChyZVdvcmRzKTtcbiAgd29yZHMgPSB3b3Jkcy5tYXAoZnVuY3Rpb24gKHdvcmQpIHtcbiAgICByZXR1cm4gd29yZC5jaGFyQXQoMCkudG9Mb2NhbGVVcHBlckNhc2UoKSArIHdvcmQuc2xpY2UoMSkudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgfSk7XG4gIHdvcmRzWzBdID0gd29yZHNbMF0udG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgcmV0dXJuIHdvcmRzLmpvaW4oJycpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHN0cmluZyB0byBzbmFrZV9jYXNlXG4gKiBAZnVuY3Rpb24gVXRpbC5zbmFrZUNhc2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgLSB0aGUgc3RyaW5nIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge3N0cmluZ30gaW4gc25ha2VfY2FzZSBmb3JtYXRcbiAqL1xudmFyIHNuYWtlQ2FzZSA9IGZ1bmN0aW9uIHNuYWtlQ2FzZShzb3VyY2UpIHtcbiAgdmFyIHdvcmRzID0gc291cmNlLm1hdGNoKHJlV29yZHMpO1xuICB3b3JkcyA9IHdvcmRzLm1hcChmdW5jdGlvbiAod29yZCkge1xuICAgIHJldHVybiB3b3JkLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gIH0pO1xuICByZXR1cm4gd29yZHMuam9pbignXycpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG9iamVjdCBmcm9tIHNvdXJjZSwgd2l0aCB0aGUga2V5cyB0cmFuc2Zvcm1lZCB1c2luZyB0aGUgY29udmVydGVyLlxuICogQHBhcmFtIHtvYmplY3R9IHNvdXJjZVxuICogQHBhcmFtIHtmdW5jdGlvbnxudWxsfSBjb252ZXJ0ZXJcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbnZhciBjb252ZXJ0S2V5cyA9IGZ1bmN0aW9uIGNvbnZlcnRLZXlzKHNvdXJjZSwgY29udmVydGVyKSB7XG4gIHZhciByZXN1bHQsIHZhbHVlO1xuICByZXN1bHQgPSB7fTtcbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgIHZhbHVlID0gc291cmNlW2tleV07XG4gICAgaWYgKGNvbnZlcnRlcikge1xuICAgICAga2V5ID0gY29udmVydGVyKGtleSk7XG4gICAgfVxuICAgIGlmICghaXNFbXB0eShrZXkpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBjb3B5IG9mIHRoZSBzb3VyY2Ugb2JqZWN0IHdpdGggYWxsIGtleXMgaW4gY2FtZWxDYXNlXG4gKiBAZnVuY3Rpb24gVXRpbC53aXRoQ2FtZWxDYXNlS2V5c1xuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIC0gdGhlIG9iamVjdCB0byBjb3B5XG4gKiBAcmV0dXJuIHtPYmplY3R9IGEgbmV3IG9iamVjdFxuICovXG52YXIgd2l0aENhbWVsQ2FzZUtleXMgPSBmdW5jdGlvbiB3aXRoQ2FtZWxDYXNlS2V5cyhzb3VyY2UpIHtcbiAgcmV0dXJuIGNvbnZlcnRLZXlzKHNvdXJjZSwgY2FtZWxDYXNlKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgY29weSBvZiB0aGUgc291cmNlIG9iamVjdCB3aXRoIGFsbCBrZXlzIGluIHNuYWtlX2Nhc2VcbiAqIEBmdW5jdGlvbiBVdGlsLndpdGhTbmFrZUNhc2VLZXlzXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgLSB0aGUgb2JqZWN0IHRvIGNvcHlcbiAqIEByZXR1cm4ge09iamVjdH0gYSBuZXcgb2JqZWN0XG4gKi9cbnZhciB3aXRoU25ha2VDYXNlS2V5cyA9IGZ1bmN0aW9uIHdpdGhTbmFrZUNhc2VLZXlzKHNvdXJjZSkge1xuICByZXR1cm4gY29udmVydEtleXMoc291cmNlLCBzbmFrZUNhc2UpO1xufTtcblxuLy8gQnJvd3NlclxuLy8gTm9kZS5qc1xudmFyIGJhc2U2NEVuY29kZSA9IHR5cGVvZiBidG9hICE9PSAndW5kZWZpbmVkJyAmJiBpc0Z1bmN0aW9uKGJ0b2EpID8gYnRvYSA6IHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGlzRnVuY3Rpb24oQnVmZmVyKSA/IGZ1bmN0aW9uIChpbnB1dCkge1xuICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICBpbnB1dCA9IG5ldyBCdWZmZXIuZnJvbShTdHJpbmcoaW5wdXQpLCAnYmluYXJ5Jyk7XG4gIH1cbiAgcmV0dXJuIGlucHV0LnRvU3RyaW5nKCdiYXNlNjQnKTtcbn0gOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYmFzZTY0IGVuY29kaW5nIGZ1bmN0aW9uIGZvdW5kXCIpO1xufTtcblxuLyoqXG4qIFJldHVybnMgdGhlIEJhc2U2NC1kZWNvZGVkIHZlcnNpb24gb2YgdXJsLjxicj5cbiogVGhpcyBtZXRob2QgZGVsZWdhdGVzIHRvIGBidG9hYCBpZiBwcmVzZW50LiBPdGhlcndpc2UgaXQgdHJpZXMgYEJ1ZmZlcmAuXG4qIEBmdW5jdGlvbiBVdGlsLmJhc2U2NEVuY29kZVVSTFxuKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gdGhlIHVybCB0byBlbmNvZGUuIHRoZSB2YWx1ZSBpcyBVUklkZWNvZGVkIGFuZCB0aGVuIHJlLWVuY29kZWQgYmVmb3JlIGNvbnZlcnRpbmcgdG8gYmFzZTY0IHJlcHJlc2VudGF0aW9uXG4qIEByZXR1cm4ge3N0cmluZ30gdGhlIGJhc2U2NCByZXByZXNlbnRhdGlvbiBvZiB0aGUgVVJMXG4gKi9cbnZhciBiYXNlNjRFbmNvZGVVUkwgPSBmdW5jdGlvbiBiYXNlNjRFbmNvZGVVUkwodXJsKSB7XG4gIHRyeSB7XG4gICAgdXJsID0gZGVjb2RlVVJJKHVybCk7XG4gIH0gZmluYWxseSB7XG4gICAgdXJsID0gZW5jb2RlVVJJKHVybCk7XG4gIH1cbiAgcmV0dXJuIGJhc2U2NEVuY29kZSh1cmwpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgb2JqZWN0IHdpdGggb25seSBVUkwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgVGhlIHNvdXJjZSBvYmplY3RcbiAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgb25seSBVUkwgcGFyYW1ldGVyc1xuICovXG5mdW5jdGlvbiBleHRyYWN0VXJsUGFyYW1zKG9wdGlvbnMpIHtcbiAgcmV0dXJuIFVSTF9LRVlTLnJlZHVjZShmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICBpZiAob3B0aW9uc1trZXldICE9IG51bGwpIHtcbiAgICAgIG9ialtrZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9LCB7fSk7XG59XG5cbi8qKlxuICogSGFuZGxlIHRoZSBmb3JtYXQgcGFyYW1ldGVyIGZvciBmZXRjaCB1cmxzXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIG9wdGlvbnMgdXJsIGFuZCB0cmFuc2Zvcm1hdGlvbiBvcHRpb25zLiBUaGlzIGFyZ3VtZW50IG1heSBiZSBjaGFuZ2VkIGJ5IHRoZSBmdW5jdGlvbiFcbiAqL1xuZnVuY3Rpb24gcGF0Y2hGZXRjaEZvcm1hdChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgaWYgKG9wdGlvbnMudHlwZSA9PT0gXCJmZXRjaFwiKSB7XG4gICAgaWYgKG9wdGlvbnMuZmV0Y2hfZm9ybWF0ID09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMuZmV0Y2hfZm9ybWF0ID0gb3B0aW9uQ29uc3VtZShvcHRpb25zLCBcImZvcm1hdFwiKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEZWxldGVzIGBvcHRpb25fbmFtZWAgZnJvbSBgb3B0aW9uc2AgYW5kIHJldHVybiB0aGUgdmFsdWUgaWYgcHJlc2VudC5cbiAqIElmIGBvcHRpb25zYCBkb2Vzbid0IGNvbnRhaW4gYG9wdGlvbl9uYW1lYCB0aGUgZGVmYXVsdCB2YWx1ZSBpcyByZXR1cm5lZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIGEgY29sbGVjdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbl9uYW1lIHRoZSBuYW1lIChrZXkpIG9mIHRoZSBkZXNpcmVkIHZhbHVlXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0X3ZhbHVlXSB0aGUgdmFsdWUgdG8gcmV0dXJuIGlzIG9wdGlvbl9uYW1lIGlzIG1pc3NpbmdcbiAqL1xuZnVuY3Rpb24gb3B0aW9uQ29uc3VtZShvcHRpb25zLCBvcHRpb25fbmFtZSwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb3B0aW9uc1tvcHRpb25fbmFtZV07XG4gIGRlbGV0ZSBvcHRpb25zW29wdGlvbl9uYW1lXTtcbiAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGVmYXVsdF92YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBlbXB0eTpcbiAqIDx1bD5cbiAqICAgPGxpPnZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkPC9saT5cbiAqICAgPGxpPnZhbHVlIGlzIGFuIGFycmF5IG9yIHN0cmluZyBvZiBsZW5ndGggMDwvbGk+XG4gKiAgIDxsaT52YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBubyBrZXlzPC9saT5cbiAqIDwvdWw+XG4gKiBAZnVuY3Rpb24gVXRpbC5pc0VtcHR5XG4gKiBAcGFyYW0gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHZhbHVlIGlzIGVtcHR5XG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlLmxlbmd0aCA9PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA9PT0gMDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlLnNpemUgPT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiB2YWx1ZS5zaXplID09PSAwO1xuICB9XG4gIGlmIChiYXNldXRpbF90eXBlb2YodmFsdWUpID09IFwib2JqZWN0XCIpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2Jyb3dzZXIuanNcbi8qKlxuICogQmFzZWQgb24gdmlkZW8uanMgaW1wbGVtZW50YXRpb246XG4gKiBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9ibG9iLzQyMzhmNWMxZDg4ODkwNTQ3MTUzZTdlMWRlN2JkMGQxZDhlMGIyMzYvc3JjL2pzL3V0aWxzL2Jyb3dzZXIuanNcbiAqL1xuXG4vKipcbiogUmV0cmlldmUgZnJvbSB0aGUgbmF2aWdhdG9yIHRoZSB1c2VyIGFnZW50IHByb3BlcnR5LlxuKiBAcmV0dXJucyB1c2VyIGFnZW50IHByb3BlcnR5LlxuKi9cbmZ1bmN0aW9uIGdldFVzZXJBZ2VudCgpIHtcbiAgcmV0dXJuIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xufVxuXG4vKipcbiAqIERldGVjdCBpZiBjdXJyZW50IGJyb3dzZXIgaXMgYW55IEFuZHJvaWRcbiAqIEByZXR1cm5zIHRydWUgaWYgY3VycmVudCBicm93c2VyIGlzIEFuZHJvaWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNBbmRyb2lkKCkge1xuICB2YXIgdXNlckFnZW50ID0gZ2V0VXNlckFnZW50KCk7XG4gIHJldHVybiAvQW5kcm9pZC9pLnRlc3QodXNlckFnZW50KTtcbn1cblxuLyoqXG4gKiBEZXRlY3QgaWYgY3VycmVudCBicm93c2VyIGlzIGFueSBFZGdlXG4gKiBAcmV0dXJucyB0cnVlIGlmIGN1cnJlbnQgYnJvd3NlciBpcyBFZGdlLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzRWRnZSgpIHtcbiAgdmFyIHVzZXJBZ2VudCA9IGdldFVzZXJBZ2VudCgpO1xuICByZXR1cm4gL0VkZy9pLnRlc3QodXNlckFnZW50KTtcbn1cblxuLyoqXG4gKiBEZXRlY3QgaWYgY3VycmVudCBicm93c2VyIGlzIGNocm9tZS5cbiAqIEByZXR1cm5zIHRydWUgaWYgY3VycmVudCBicm93c2VyIGlzIENocm9tZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0Nocm9tZSgpIHtcbiAgdmFyIHVzZXJBZ2VudCA9IGdldFVzZXJBZ2VudCgpO1xuICByZXR1cm4gIWlzRWRnZSgpICYmICgvQ2hyb21lL2kudGVzdCh1c2VyQWdlbnQpIHx8IC9DcmlPUy9pLnRlc3QodXNlckFnZW50KSk7XG59XG5cbi8qKlxuICogRGV0ZWN0IGlmIGN1cnJlbnQgYnJvd3NlciBpcyBTYWZhcmkuXG4gKiBAcmV0dXJucyB0cnVlIGlmIGN1cnJlbnQgYnJvd3NlciBpcyBTYWZhcmksIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNTYWZhcmkoKSB7XG4gIC8vIFVzZXIgYWdlbnRzIGZvciBvdGhlciBicm93c2VycyBtaWdodCBpbmNsdWRlIFwiU2FmYXJpXCIgc28gd2UgbXVzdCBleGNsdWRlIHRoZW0uXG4gIC8vIEZvciBleGFtcGxlIC0gdGhpcyBpcyB0aGUgY2hyb21lIHVzZXIgYWdlbnQgb24gd2luZG93cyAxMDpcbiAgLy8gTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzk2LjAuNDY2NC4xMTAgU2FmYXJpLzUzNy4zNlxuICB2YXIgdXNlckFnZW50ID0gZ2V0VXNlckFnZW50KCk7XG4gIHJldHVybiAvU2FmYXJpL2kudGVzdCh1c2VyQWdlbnQpICYmICFpc0Nocm9tZSgpICYmICFpc0FuZHJvaWQoKSAmJiAhaXNFZGdlKCk7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2xvZGFzaC5qc1xudmFyIG5vZGVDb250YWlucztcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vKlxuICogSW5jbHVkZXMgdXRpbGl0eSBtZXRob2RzIGFuZCBsb2Rhc2ggLyBqUXVlcnkgc2hpbXNcbiAqL1xuLyoqXG4gKiBHZXQgZGF0YSBmcm9tIHRoZSBET00gZWxlbWVudC5cbiAqXG4gKiBUaGlzIG1ldGhvZCB3aWxsIHVzZSBqUXVlcnkncyBgZGF0YSgpYCBtZXRob2QgaWYgaXQgaXMgYXZhaWxhYmxlLCBvdGhlcndpc2UgaXQgd2lsbCBnZXQgdGhlIGBkYXRhLWAgYXR0cmlidXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudCB0byBnZXQgdGhlIGRhdGEgZnJvbVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgZGF0YSBpdGVtXG4gKiBAcmV0dXJucyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBgbmFtZWBcbiAqIEBmdW5jdGlvbiBVdGlsLmdldERhdGFcbiAqL1xudmFyIGxvZGFzaF9nZXREYXRhID0gZnVuY3Rpb24gZ2V0RGF0YShlbGVtZW50LCBuYW1lKSB7XG4gIHN3aXRjaCAoZmFsc2UpIHtcbiAgICBjYXNlICEoZWxlbWVudCA9PSBudWxsKTpcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuZ2V0QXR0cmlidXRlKTpcbiAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtXCIuY29uY2F0KG5hbWUpKTtcbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5nZXRBdHRyKTpcbiAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHIoXCJkYXRhLVwiLmNvbmNhdChuYW1lKSk7XG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuZGF0YSk6XG4gICAgICByZXR1cm4gZWxlbWVudC5kYXRhKG5hbWUpO1xuICAgIGNhc2UgIShpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkodHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZm4gJiYgalF1ZXJ5LmZuLmRhdGEpICYmIGlzRWxlbWVudF9yb290X2lzRWxlbWVudF9kZWZhdWx0KCkoZWxlbWVudCkpOlxuICAgICAgcmV0dXJuIGpRdWVyeShlbGVtZW50KS5kYXRhKG5hbWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCBkYXRhIGluIHRoZSBET00gZWxlbWVudC5cbiAqXG4gKiBUaGlzIG1ldGhvZCB3aWxsIHVzZSBqUXVlcnkncyBgZGF0YSgpYCBtZXRob2QgaWYgaXQgaXMgYXZhaWxhYmxlLCBvdGhlcndpc2UgaXQgd2lsbCBzZXQgdGhlIGBkYXRhLWAgYXR0cmlidXRlXG4gKiBAZnVuY3Rpb24gVXRpbC5zZXREYXRhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGRhdGEgaW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGRhdGEgaXRlbVxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBiZSBzZXRcbiAqXG4gKi9cbnZhciBsb2Rhc2hfc2V0RGF0YSA9IGZ1bmN0aW9uIHNldERhdGEoZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgc3dpdGNoIChmYWxzZSkge1xuICAgIGNhc2UgIShlbGVtZW50ID09IG51bGwpOlxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5zZXRBdHRyaWJ1dGUpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1cIi5jb25jYXQobmFtZSksIHZhbHVlKTtcbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5zZXRBdHRyKTpcbiAgICAgIHJldHVybiBlbGVtZW50LnNldEF0dHIoXCJkYXRhLVwiLmNvbmNhdChuYW1lKSwgdmFsdWUpO1xuICAgIGNhc2UgIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShlbGVtZW50LmRhdGEpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuZGF0YShuYW1lLCB2YWx1ZSk7XG4gICAgY2FzZSAhKGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKSh0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5mbiAmJiBqUXVlcnkuZm4uZGF0YSkgJiYgaXNFbGVtZW50X3Jvb3RfaXNFbGVtZW50X2RlZmF1bHQoKShlbGVtZW50KSk6XG4gICAgICByZXR1cm4galF1ZXJ5KGVsZW1lbnQpLmRhdGEobmFtZSwgdmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBhdHRyaWJ1dGUgZnJvbSB0aGUgRE9NIGVsZW1lbnQuXG4gKlxuICogQGZ1bmN0aW9uIFV0aWwuZ2V0QXR0cmlidXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGF0dHJpYnV0ZSBmb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICogQHJldHVybnMgeyp9IHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlXG4gKlxuICovXG52YXIgbG9kYXNoX2dldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZShlbGVtZW50LCBuYW1lKSB7XG4gIHN3aXRjaCAoZmFsc2UpIHtcbiAgICBjYXNlICEoZWxlbWVudCA9PSBudWxsKTpcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuZ2V0QXR0cmlidXRlKTpcbiAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5hdHRyKTpcbiAgICAgIHJldHVybiBlbGVtZW50LmF0dHIobmFtZSk7XG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuZ2V0QXR0cik6XG4gICAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyKG5hbWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCBhdHRyaWJ1dGUgaW4gdGhlIERPTSBlbGVtZW50LlxuICpcbiAqIEBmdW5jdGlvbiBVdGlsLnNldEF0dHJpYnV0ZVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gdGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBhdHRyaWJ1dGUgZm9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gYmUgc2V0XG4gKi9cbnZhciBsb2Rhc2hfc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gc2V0QXR0cmlidXRlKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gIHN3aXRjaCAoZmFsc2UpIHtcbiAgICBjYXNlICEoZWxlbWVudCA9PSBudWxsKTpcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuc2V0QXR0cmlidXRlKTpcbiAgICAgIHJldHVybiBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuYXR0cik6XG4gICAgICByZXR1cm4gZWxlbWVudC5hdHRyKG5hbWUsIHZhbHVlKTtcbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5zZXRBdHRyKTpcbiAgICAgIHJldHVybiBlbGVtZW50LnNldEF0dHIobmFtZSwgdmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBhdHRyaWJ1dGUgaW4gdGhlIERPTSBlbGVtZW50LlxuICpcbiAqIEBmdW5jdGlvbiBVdGlsLnJlbW92ZUF0dHJpYnV0ZVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gdGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBhdHRyaWJ1dGUgZm9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGVcbiAqL1xudmFyIGxvZGFzaF9yZW1vdmVBdHRyaWJ1dGUgPSBmdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgbmFtZSkge1xuICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgY2FzZSAhKGVsZW1lbnQgPT0gbnVsbCk6XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIGNhc2UgIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSk6XG4gICAgICByZXR1cm4gZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBsb2Rhc2hfc2V0QXR0cmlidXRlKGVsZW1lbnQsIHZvaWQgMCk7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IGEgZ3JvdXAgb2YgYXR0cmlidXRlcyB0byB0aGUgZWxlbWVudFxuICogQGZ1bmN0aW9uIFV0aWwuc2V0QXR0cmlidXRlc1xuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gdGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBhdHRyaWJ1dGVzIGZvclxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBhIGhhc2ggb2YgYXR0cmlidXRlIG5hbWVzIGFuZCB2YWx1ZXNcbiAqL1xudmFyIHNldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcbiAgdmFyIG5hbWUsIHJlc3VsdHMsIHZhbHVlO1xuICByZXN1bHRzID0gW107XG4gIGZvciAobmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXN1bHRzLnB1c2gobG9kYXNoX3NldEF0dHJpYnV0ZShlbGVtZW50LCBuYW1lLCB2YWx1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRzLnB1c2gobG9kYXNoX3JlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCBuYW1lKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgZWxlbWVudCBoYXMgYSBjc3MgY2xhc3NcbiAqIEBmdW5jdGlvbiBVdGlsLmhhc0NsYXNzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudCB0byBjaGVja1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgY2xhc3MgbmFtZVxuIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBlbGVtZW50IGhhcyB0aGUgY2xhc3NcbiAqL1xudmFyIGxvZGFzaF9oYXNDbGFzcyA9IGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIG5hbWUpIHtcbiAgaWYgKGlzRWxlbWVudF9yb290X2lzRWxlbWVudF9kZWZhdWx0KCkoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jbGFzc05hbWUubWF0Y2gobmV3IFJlZ0V4cChcIlxcXFxiXCIuY29uY2F0KG5hbWUsIFwiXFxcXGJcIikpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBZGQgY2xhc3MgdG8gdGhlIGVsZW1lbnRcbiAqIEBmdW5jdGlvbiBVdGlsLmFkZENsYXNzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgY2xhc3MgbmFtZSB0byBhZGRcbiAqL1xudmFyIGxvZGFzaF9hZGRDbGFzcyA9IGZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQsIG5hbWUpIHtcbiAgaWYgKCFlbGVtZW50LmNsYXNzTmFtZS5tYXRjaChuZXcgUmVnRXhwKFwiXFxcXGJcIi5jb25jYXQobmFtZSwgXCJcXFxcYlwiKSkpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NOYW1lID0gdHJpbV9yb290X3RyaW1fZGVmYXVsdCgpKFwiXCIuY29uY2F0KGVsZW1lbnQuY2xhc3NOYW1lLCBcIiBcIikuY29uY2F0KG5hbWUpKTtcbiAgfVxufTtcblxuLy8gVGhlIGZvbGxvd2luZyBjb2RlIGlzIHRha2VuIGZyb20galF1ZXJ5XG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24gZ2V0U3R5bGVzKGVsZW0pIHtcbiAgLy8gU3VwcG9ydDogSUU8PTExKywgRmlyZWZveDw9MzArICgjMTUwOTgsICMxNDE1MClcbiAgLy8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG4gIC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuICBpZiAoZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3Lm9wZW5lcikge1xuICAgIHJldHVybiBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCBudWxsKTtcbiAgfVxuICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbSwgbnVsbCk7XG59O1xudmFyIGNzc0V4cGFuZCA9IFtcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiXTtcbm5vZGVDb250YWlucyA9IGZ1bmN0aW9uIG5vZGVDb250YWlucyhhLCBiKSB7XG4gIHZhciBhZG93biwgYnVwO1xuICBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGE7XG4gIGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuICByZXR1cm4gYSA9PT0gYnVwIHx8ICEhKGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgYWRvd24uY29udGFpbnMoYnVwKSk7XG59O1xuXG4vLyBUcnVuY2F0ZWQgdmVyc2lvbiBvZiBqUXVlcnkuc3R5bGUoZWxlbSwgbmFtZSlcbnZhciBkb21TdHlsZSA9IGZ1bmN0aW9uIGRvbVN0eWxlKGVsZW0sIG5hbWUpIHtcbiAgaWYgKCEoIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlKSkge1xuICAgIHJldHVybiBlbGVtLnN0eWxlW25hbWVdO1xuICB9XG59O1xudmFyIGN1ckNTUyA9IGZ1bmN0aW9uIGN1ckNTUyhlbGVtLCBuYW1lLCBjb21wdXRlZCkge1xuICB2YXIgbWF4V2lkdGgsIG1pbldpZHRoLCByZXQsIHJtYXJnaW4sIHN0eWxlLCB3aWR0aDtcbiAgcm1hcmdpbiA9IC9ebWFyZ2luLztcbiAgd2lkdGggPSB2b2lkIDA7XG4gIG1pbldpZHRoID0gdm9pZCAwO1xuICBtYXhXaWR0aCA9IHZvaWQgMDtcbiAgcmV0ID0gdm9pZCAwO1xuICBzdHlsZSA9IGVsZW0uc3R5bGU7XG4gIGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKGVsZW0pO1xuICBpZiAoY29tcHV0ZWQpIHtcbiAgICAvLyBTdXBwb3J0OiBJRTlcbiAgICAvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG9ubHkgbmVlZGVkIGZvciAuY3NzKCdmaWx0ZXInKSAoIzEyNTM3KVxuICAgIHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUobmFtZSkgfHwgY29tcHV0ZWRbbmFtZV07XG4gIH1cbiAgaWYgKGNvbXB1dGVkKSB7XG4gICAgaWYgKHJldCA9PT0gXCJcIiAmJiAhbm9kZUNvbnRhaW5zKGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSkpIHtcbiAgICAgIHJldCA9IGRvbVN0eWxlKGVsZW0sIG5hbWUpO1xuICAgIH1cbiAgICAvLyBTdXBwb3J0OiBpT1MgPCA2XG4gICAgLy8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuICAgIC8vIGlPUyA8IDYgKGF0IGxlYXN0KSByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIGEgbGFyZ2VyIHNldCBvZiB2YWx1ZXMsIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHNcbiAgICAvLyB0aGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6IGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcbiAgICBpZiAocm51bW5vbnB4LnRlc3QocmV0KSAmJiBybWFyZ2luLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICAgIHdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgICBtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuICAgICAgbWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcbiAgICAgIC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcbiAgICAgIHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcbiAgICAgIHJldCA9IGNvbXB1dGVkLndpZHRoO1xuICAgICAgLy8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuICAgICAgc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgIHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG4gICAgICBzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgIH1cbiAgfVxuICAvLyBTdXBwb3J0OiBJRVxuICAvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmV0ICsgXCJcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmV0O1xuICB9XG59O1xudmFyIGNzc1ZhbHVlID0gZnVuY3Rpb24gY3NzVmFsdWUoZWxlbSwgbmFtZSwgY29udmVydCwgc3R5bGVzKSB7XG4gIHZhciB2YWw7XG4gIHZhbCA9IGN1ckNTUyhlbGVtLCBuYW1lLCBzdHlsZXMpO1xuICBpZiAoY29udmVydCkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxufTtcbnZhciBhdWdtZW50V2lkdGhPckhlaWdodCA9IGZ1bmN0aW9uIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KGVsZW0sIG5hbWUsIGV4dHJhLCBpc0JvcmRlckJveCwgc3R5bGVzKSB7XG4gIHZhciBpLCBsZW4sIHNpZGUsIHNpZGVzLCB2YWw7XG4gIC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxuICAvLyBPdGhlcndpc2UgaW5pdGlhbGl6ZSBmb3IgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBwcm9wZXJ0aWVzXG4gIGlmIChleHRyYSA9PT0gKGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiKSkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHNpZGVzID0gbmFtZSA9PT0gXCJ3aWR0aFwiID8gW1wiUmlnaHRcIiwgXCJMZWZ0XCJdIDogW1wiVG9wXCIsIFwiQm90dG9tXCJdO1xuICAgIHZhbCA9IDA7XG4gICAgZm9yIChpID0gMCwgbGVuID0gc2lkZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNpZGUgPSBzaWRlc1tpXTtcbiAgICAgIGlmIChleHRyYSA9PT0gXCJtYXJnaW5cIikge1xuICAgICAgICAvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW4sIHNvIGFkZCBpdCBpZiB3ZSB3YW50IGl0XG4gICAgICAgIHZhbCArPSBjc3NWYWx1ZShlbGVtLCBleHRyYSArIHNpZGUsIHRydWUsIHN0eWxlcyk7XG4gICAgICB9XG4gICAgICBpZiAoaXNCb3JkZXJCb3gpIHtcbiAgICAgICAgaWYgKGV4dHJhID09PSBcImNvbnRlbnRcIikge1xuICAgICAgICAgIC8vIGJvcmRlci1ib3ggaW5jbHVkZXMgcGFkZGluZywgc28gcmVtb3ZlIGl0IGlmIHdlIHdhbnQgY29udGVudFxuICAgICAgICAgIHZhbCAtPSBjc3NWYWx1ZShlbGVtLCBcInBhZGRpbmdcIi5jb25jYXQoc2lkZSksIHRydWUsIHN0eWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dHJhICE9PSBcIm1hcmdpblwiKSB7XG4gICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgYm9yZGVyIG5vciBtYXJnaW4sIHNvIHJlbW92ZSBib3JkZXJcbiAgICAgICAgICB2YWwgLT0gY3NzVmFsdWUoZWxlbSwgXCJib3JkZXJcIi5jb25jYXQoc2lkZSwgXCJXaWR0aFwiKSwgdHJ1ZSwgc3R5bGVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCwgc28gYWRkIHBhZGRpbmdcbiAgICAgICAgdmFsICs9IGNzc1ZhbHVlKGVsZW0sIFwicGFkZGluZ1wiLmNvbmNhdChzaWRlKSwgdHJ1ZSwgc3R5bGVzKTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSBcInBhZGRpbmdcIikge1xuICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQgbm9yIHBhZGRpbmcsIHNvIGFkZCBib3JkZXJcbiAgICAgICAgICB2YWwgKz0gY3NzVmFsdWUoZWxlbSwgXCJib3JkZXJcIi5jb25jYXQoc2lkZSwgXCJXaWR0aFwiKSwgdHJ1ZSwgc3R5bGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9XG59O1xudmFyIHBudW0gPSAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLy5zb3VyY2U7XG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cChcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIpO1xudmFyIGdldFdpZHRoT3JIZWlnaHQgPSBmdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KGVsZW0sIG5hbWUsIGV4dHJhKSB7XG4gIHZhciBpc0JvcmRlckJveCwgc3R5bGVzLCB2YWwsIHZhbHVlSXNCb3JkZXJCb3g7XG4gIC8vIFN0YXJ0IHdpdGggb2Zmc2V0IHByb3BlcnR5LCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBib3JkZXItYm94IHZhbHVlXG4gIHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlO1xuICB2YWwgPSBuYW1lID09PSBcIndpZHRoXCIgPyBlbGVtLm9mZnNldFdpZHRoIDogZWxlbS5vZmZzZXRIZWlnaHQ7XG4gIHN0eWxlcyA9IGdldFN0eWxlcyhlbGVtKTtcbiAgaXNCb3JkZXJCb3ggPSBjc3NWYWx1ZShlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzKSA9PT0gXCJib3JkZXItYm94XCI7XG4gIC8vIFNvbWUgbm9uLWh0bWwgZWxlbWVudHMgcmV0dXJuIHVuZGVmaW5lZCBmb3Igb2Zmc2V0V2lkdGgsIHNvIGNoZWNrIGZvciBudWxsL3VuZGVmaW5lZFxuICAvLyBzdmcgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02NDkyODVcbiAgLy8gTWF0aE1MIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDkxNjY4XG4gIGlmICh2YWwgPD0gMCB8fCB2YWwgPT0gbnVsbCkge1xuICAgIC8vIEZhbGwgYmFjayB0byBjb21wdXRlZCB0aGVuIHVuY29tcHV0ZWQgY3NzIGlmIG5lY2Vzc2FyeVxuICAgIHZhbCA9IGN1ckNTUyhlbGVtLCBuYW1lLCBzdHlsZXMpO1xuICAgIGlmICh2YWwgPCAwIHx8IHZhbCA9PSBudWxsKSB7XG4gICAgICB2YWwgPSBlbGVtLnN0eWxlW25hbWVdO1xuICAgIH1cbiAgICBpZiAocm51bW5vbnB4LnRlc3QodmFsKSkge1xuICAgICAgLy8gQ29tcHV0ZWQgdW5pdCBpcyBub3QgcGl4ZWxzLiBTdG9wIGhlcmUgYW5kIHJldHVybi5cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIC8vIENoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG4gICAgLy8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuICAgIC8vICAgIHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCBhbmQgKHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSBvciB2YWwgaXMgZWxlbS5zdHlsZVtuYW1lXSlcbiAgICB2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3ggJiYgdmFsID09PSBlbGVtLnN0eWxlW25hbWVdO1xuICAgIC8vIE5vcm1hbGl6ZSBcIlwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcbiAgICB2YWwgPSBwYXJzZUZsb2F0KHZhbCkgfHwgMDtcbiAgfVxuICAvLyBVc2UgdGhlIGFjdGl2ZSBib3gtc2l6aW5nIG1vZGVsIHRvIGFkZC9zdWJ0cmFjdCBpcnJlbGV2YW50IHN0eWxlc1xuICByZXR1cm4gdmFsICsgYXVnbWVudFdpZHRoT3JIZWlnaHQoZWxlbSwgbmFtZSwgZXh0cmEgfHwgKGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiKSwgdmFsdWVJc0JvcmRlckJveCwgc3R5bGVzKTtcbn07XG52YXIgbG9kYXNoX3dpZHRoID0gZnVuY3Rpb24gd2lkdGgoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2lkdGhPckhlaWdodChlbGVtZW50LCBcIndpZHRoXCIsIFwiY29udGVudFwiKTtcbn07XG5cbi8qKlxuICogQGNsYXNzIFV0aWxcbiAqL1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgaXRlbSBpcyBhIHN0cmluZ1xuICogQGZ1bmN0aW9uIFV0aWwuaXNTdHJpbmdcbiAqIEBwYXJhbSBpdGVtXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBpdGVtIGlzIGEgc3RyaW5nXG4gKi9cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGl0ZW0gaXMgZW1wdHk6XG4gKiA8dWw+XG4gKiAgIDxsaT5pdGVtIGlzIG51bGwgb3IgdW5kZWZpbmVkPC9saT5cbiAqICAgPGxpPml0ZW0gaXMgYW4gYXJyYXkgb3Igc3RyaW5nIG9mIGxlbmd0aCAwPC9saT5cbiAqICAgPGxpPml0ZW0gaXMgYW4gb2JqZWN0IHdpdGggbm8ga2V5czwvbGk+XG4gKiA8L3VsPlxuICogQGZ1bmN0aW9uIFV0aWwuaXNFbXB0eVxuICogQHBhcmFtIGl0ZW1cbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGl0ZW0gaXMgZW1wdHlcbiAqL1xuLyoqXG4gKiBBc3NpZ24gc291cmNlIHByb3BlcnRpZXMgdG8gZGVzdGluYXRpb24uXG4gKiBJZiB0aGUgcHJvcGVydHkgaXMgYW4gb2JqZWN0IGl0IGlzIGFzc2lnbmVkIGFzIGEgd2hvbGUsIG92ZXJyaWRpbmcgdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBmdW5jdGlvbiBVdGlsLmFzc2lnblxuICogQHBhcmFtIHtPYmplY3R9IGRlc3RpbmF0aW9uIC0gdGhlIG9iamVjdCB0byBhc3NpZ24gdG9cbiAqL1xuLyoqXG4gKiBSZWN1cnNpdmVseSBhc3NpZ24gc291cmNlIHByb3BlcnRpZXMgdG8gZGVzdGluYXRpb25cbiAqIEBmdW5jdGlvbiBVdGlsLm1lcmdlXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdGluYXRpb24gLSB0aGUgb2JqZWN0IHRvIGFzc2lnbiB0b1xuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKi9cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGNvcHkgb2YgdGhlIGdpdmVuIG9iamVjdCwgaW5jbHVkaW5nIGFsbCBpbnRlcm5hbCBvYmplY3RzLlxuICogQGZ1bmN0aW9uIFV0aWwuY2xvbmVEZWVwXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgLSB0aGUgb2JqZWN0IHRvIGNsb25lXG4gKiBAcmV0dXJuIHtPYmplY3R9IGEgbmV3IGRlZXAgY29weSBvZiB0aGUgb2JqZWN0XG4gKi9cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBhcnJheSBmcm9tIHRoZSBwYXJhbWV0ZXIgd2l0aCBcImZhbHNleVwiIHZhbHVlcyByZW1vdmVkXG4gKiBAZnVuY3Rpb24gVXRpbC5jb21wYWN0XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIHRoZSBhcnJheSB0byByZW1vdmUgdmFsdWVzIGZyb21cbiAqIEByZXR1cm4ge0FycmF5fSBhIG5ldyBhcnJheSB3aXRob3V0IGZhbHNleSB2YWx1ZXNcbiAqL1xuLyoqXG4gKiBDaGVjayBpZiBhIGdpdmVuIGl0ZW0gaXMgaW5jbHVkZWQgaW4gdGhlIGdpdmVuIGFycmF5XG4gKiBAZnVuY3Rpb24gVXRpbC5jb250YWluc1xuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSB0aGUgYXJyYXkgdG8gc2VhcmNoIGluXG4gKiBAcGFyYW0geyp9IGl0ZW0gLSB0aGUgaXRlbSB0byBzZWFyY2ggZm9yXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBpdGVtIGlzIGluY2x1ZGVkIGluIHRoZSBhcnJheVxuICovXG4vKipcbiAqIFJldHVybnMgdmFsdWVzIGluIHRoZSBnaXZlbiBhcnJheSB0aGF0IGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIG90aGVyIGFycmF5XG4gKiBAZnVuY3Rpb24gVXRpbC5kaWZmZXJlbmNlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIgLSB0aGUgYXJyYXkgdG8gc2VsZWN0IGZyb21cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyAtIHZhbHVlcyB0byBmaWx0ZXIgZnJvbSBhcnJcbiAqIEByZXR1cm4ge0FycmF5fSB0aGUgZmlsdGVyZWQgdmFsdWVzXG4gKi9cbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIHRoZSBmdW5jdGlvbiBuYW1lcyBpbiBvYmpcbiAqIEBmdW5jdGlvbiBVdGlsLmZ1bmN0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIHRoZSBvYmplY3QgdG8gaW5zcGVjdFxuICogQHJldHVybiB7QXJyYXl9IGEgbGlzdCBvZiBmdW5jdGlvbnMgb2Ygb2JqZWN0XG4gKi9cbi8qKlxuICogUmV0dXJucyB0aGUgcHJvdmlkZWQgdmFsdWUuIFRoaXMgZnVuY3Rpb25zIGlzIHVzZWQgYXMgYSBkZWZhdWx0IHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAqIEBmdW5jdGlvbiBVdGlsLmlkZW50aXR5XG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHsqfSB0aGUgcHJvdmlkZWQgdmFsdWVcbiAqL1xuLyoqXG4gKiBSZW1vdmUgbGVhZGluZyBvciB0cmFpbGluZyBzcGFjZXMgZnJvbSB0ZXh0XG4gKiBAZnVuY3Rpb24gVXRpbC50cmltXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgYHRleHRgIHdpdGhvdXQgbGVhZGluZyBvciB0cmFpbGluZyBzcGFjZXNcbiAqL1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZXhwcmVzc2lvbi5qc1xuZnVuY3Rpb24gZXhwcmVzc2lvbl90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBleHByZXNzaW9uX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBleHByZXNzaW9uX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7IGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykgeyB2YXIgbyA9IHJbdF07IG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBleHByZXNzaW9uX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gZXhwcmVzc2lvbl90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gZXhwcmVzc2lvbl90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdHJhbnNmb3JtYXRpb24gZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uU3RyIC0gQW4gZXhwcmVzc2lvbiBpbiBzdHJpbmcgZm9ybWF0LlxuICogQGNsYXNzIEV4cHJlc3Npb25cbiAqIE5vcm1hbGx5IHRoaXMgY2xhc3MgaXMgbm90IGluc3RhbnRpYXRlZCBkaXJlY3RseVxuICovXG52YXIgRXhwcmVzc2lvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV4cHJlc3Npb24oZXhwcmVzc2lvblN0cikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFeHByZXNzaW9uKTtcbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGlubmVyIEV4cHJlc3Npb24tZXhwcmVzc2lvbnNcbiAgICAgKi9cbiAgICB0aGlzLmV4cHJlc3Npb25zID0gW107XG4gICAgaWYgKGV4cHJlc3Npb25TdHIgIT0gbnVsbCkge1xuICAgICAgdGhpcy5leHByZXNzaW9ucy5wdXNoKEV4cHJlc3Npb24ubm9ybWFsaXplKGV4cHJlc3Npb25TdHIpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udmVuaWVuY2UgY29uc3RydWN0b3IgbWV0aG9kXG4gICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLm5ld1xuICAgKi9cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFeHByZXNzaW9uLCBbe1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhlIGV4cHJlc3Npb25cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBleHByZXNzaW9uIGFzIGEgc3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgcmV0dXJuIEV4cHJlc3Npb24ubm9ybWFsaXplKHRoaXMuZXhwcmVzc2lvbnMuam9pbihcIl9cIikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcGFyZW50IHRyYW5zZm9ybWF0aW9uIG9mIHRoaXMgZXhwcmVzc2lvblxuICAgICAqIEByZXR1cm4gVHJhbnNmb3JtYXRpb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRQYXJlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGFyZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcGFyZW50IHRyYW5zZm9ybWF0aW9uIG9mIHRoaXMgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7VHJhbnNmb3JtYXRpb259IHRoZSBwYXJlbnQgdHJhbnNmb3JtYXRpb25cbiAgICAgKiBAcmV0dXJuIHtFeHByZXNzaW9ufSB0aGlzIGV4cHJlc3Npb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRQYXJlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UGFyZW50KHBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBleHByZXNzaW9uXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24jcHJlZGljYXRlXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicHJlZGljYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZWRpY2F0ZShuYW1lLCBvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIGlmIChFeHByZXNzaW9uLk9QRVJBVE9SU1tvcGVyYXRvcl0gIT0gbnVsbCkge1xuICAgICAgICBvcGVyYXRvciA9IEV4cHJlc3Npb24uT1BFUkFUT1JTW29wZXJhdG9yXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhwcmVzc2lvbnMucHVzaChcIlwiLmNvbmNhdChuYW1lLCBcIl9cIikuY29uY2F0KG9wZXJhdG9yLCBcIl9cIikuY29uY2F0KHZhbHVlKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbiNhbmRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5kKCkge1xuICAgICAgdGhpcy5leHByZXNzaW9ucy5wdXNoKFwiYW5kXCIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24jb3JcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcigpIHtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbnMucHVzaChcIm9yXCIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uY2x1ZGUgZXhwcmVzc2lvblxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uI3RoZW5cbiAgICAgKiBAcmV0dXJuIHtUcmFuc2Zvcm1hdGlvbn0gdGhlIHRyYW5zZm9ybWF0aW9uIHRoaXMgZXhwcmVzc2lvbiBpcyBkZWZpbmVkIGZvclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInRoZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGhlbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFBhcmVudCgpW1wiaWZcIl0odGhpcy50b1N0cmluZygpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbiNoZWlnaHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtFeHByZXNzaW9ufSB0aGlzIGV4cHJlc3Npb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJoZWlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGVpZ2h0KG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwiaFwiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uI3dpZHRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAgICogQHJldHVybiB7RXhwcmVzc2lvbn0gdGhpcyBleHByZXNzaW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwid2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2lkdGgob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJ3XCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24jYXNwZWN0UmF0aW9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtFeHByZXNzaW9ufSB0aGlzIGV4cHJlc3Npb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhc3BlY3RSYXRpb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhc3BlY3RSYXRpbyhvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcImFyXCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24jcGFnZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtFeHByZXNzaW9ufSB0aGlzIGV4cHJlc3Npb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwYWdlQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFnZUNvdW50KG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwicGNcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbiNmYWNlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciB0aGUgY29tcGFyaXNvbiBvcGVyYXRvciAoZS5nLiBcIjxcIiwgXCJsdFwiKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHJpZ2h0IGhhbmQgc2lkZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0V4cHJlc3Npb259IHRoaXMgZXhwcmVzc2lvblxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImZhY2VDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmYWNlQ291bnQob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJmY1wiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShfdmFsdWUpIHtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbnMucHVzaChfdmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICovXG4gIH1dLCBbe1xuICAgIGtleTogXCJuZXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX25ldyhleHByZXNzaW9uU3RyKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoZXhwcmVzc2lvblN0cik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIGEgc3RyaW5nIGV4cHJlc3Npb25cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNub3JtYWxpemVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBhIGV4cHJlc3Npb24sIGUuZy4gXCJ3IGd0IDEwMFwiLCBcIndpZHRoX2d0XzEwMFwiLCBcIndpZHRoID4gMTAwXCJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBub3JtYWxpemVkIGZvcm0gb2YgdGhlIHZhbHVlIGV4cHJlc3Npb24sIGUuZy4gXCJ3X2d0XzEwMFwiXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwibm9ybWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vcm1hbGl6ZShleHByZXNzaW9uKSB7XG4gICAgICBpZiAoZXhwcmVzc2lvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgICAgfVxuICAgICAgZXhwcmVzc2lvbiA9IFN0cmluZyhleHByZXNzaW9uKTtcbiAgICAgIHZhciBvcGVyYXRvcnMgPSBcIlxcXFx8XFxcXHx8Pj18PD18JiZ8IT18Pnw9fDx8L3wtfFxcXFwrfFxcXFwqfFxcXFxeXCI7XG5cbiAgICAgIC8vIG9wZXJhdG9yc1xuICAgICAgdmFyIG9wZXJhdG9yc1BhdHRlcm4gPSBcIigoXCIgKyBvcGVyYXRvcnMgKyBcIikoPz1bIF9dKSlcIjtcbiAgICAgIHZhciBvcGVyYXRvcnNSZXBsYWNlUkUgPSBuZXcgUmVnRXhwKG9wZXJhdG9yc1BhdHRlcm4sIFwiZ1wiKTtcbiAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLnJlcGxhY2Uob3BlcmF0b3JzUmVwbGFjZVJFLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIEV4cHJlc3Npb24uT1BFUkFUT1JTW21hdGNoXTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBwcmVkZWZpbmVkIHZhcmlhYmxlc1xuICAgICAgLy8gVGhlIDoke3Z9IHBhcnQgaXMgdG8gcHJldmVudCBub3JtYWxpemF0aW9uIG9mIHZhcnMgd2l0aCBhIHByZWNlZGluZyBjb2xvbiAoc3VjaCBhcyA6ZHVyYXRpb24pLFxuICAgICAgLy8gSXQgd29uJ3QgYmUgZm91bmQgaW4gUFJFREVGSU5FRF9WQVJTIGFuZCBzbyB3b24ndCBiZSBub3JtYWxpemVkLlxuICAgICAgLy8gSXQgaXMgZG9uZSBsaWtlIHRoaXMgYmVjYXVzZSBpZTExIGRvZXMgbm90IHN1cHBvcnQgcmVnZXggbG9va2JlaGluZFxuICAgICAgdmFyIHByZWRlZmluZWRWYXJzUGF0dGVybiA9IFwiKFwiICsgT2JqZWN0LmtleXMoRXhwcmVzc2lvbi5QUkVERUZJTkVEX1ZBUlMpLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gXCI6XCIuY29uY2F0KHYsIFwifFwiKS5jb25jYXQodik7XG4gICAgICB9KS5qb2luKFwifFwiKSArIFwiKVwiO1xuICAgICAgdmFyIHVzZXJWYXJpYWJsZVBhdHRlcm4gPSAnKFxcXFwkXypbXl8gXSspJztcbiAgICAgIHZhciB2YXJpYWJsZXNSZXBsYWNlUkUgPSBuZXcgUmVnRXhwKFwiXCIuY29uY2F0KHVzZXJWYXJpYWJsZVBhdHRlcm4sIFwifFwiKS5jb25jYXQocHJlZGVmaW5lZFZhcnNQYXR0ZXJuKSwgXCJnXCIpO1xuICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24ucmVwbGFjZSh2YXJpYWJsZXNSZXBsYWNlUkUsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICByZXR1cm4gRXhwcmVzc2lvbi5QUkVERUZJTkVEX1ZBUlNbbWF0Y2hdIHx8IG1hdGNoO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZXhwcmVzc2lvbi5yZXBsYWNlKC9bIF9dKy9nLCAnXycpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YXJpYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YXJpYWJsZShuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKG5hbWUpLnZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBFeHByZXNzaW9uIGEgbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcIndpZHRoXCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi53aWR0aFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIndpZHRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpZHRoKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwid2lkdGhcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJoZWlnaHRcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLmhlaWdodFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImhlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoZWlnaHQoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJoZWlnaHRcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJpbml0aWFsV2lkdGhcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLmluaXRpYWxXaWR0aFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImluaXRpYWxXaWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsV2lkdGgoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJpbml0aWFsV2lkdGhcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJpbml0aWFsSGVpZ2h0XCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5pbml0aWFsSGVpZ2h0XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdGlhbEhlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsSGVpZ2h0KCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwiaW5pdGlhbEhlaWdodFwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBFeHByZXNzaW9uIGEgbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcImFzcGVjdFJhdGlvXCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5hc3BlY3RSYXRpb1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFzcGVjdFJhdGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFzcGVjdFJhdGlvKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwiYXNwZWN0UmF0aW9cIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJpbml0aWFsQXNwZWN0UmF0aW9cIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLmluaXRpYWxBc3BlY3RSYXRpb1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImluaXRpYWxBc3BlY3RSYXRpb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsQXNwZWN0UmF0aW8oKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJpbml0aWFsQXNwZWN0UmF0aW9cIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJwYWdlQ291bnRcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLnBhZ2VDb3VudFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInBhZ2VDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYWdlQ291bnQoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJwYWdlQ291bnRcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBuZXcgZXhwcmVzc2lvbiB3aXRoIHRoZSBwcmVkZWZpbmVkIHZhcmlhYmxlIFwiZmFjZUNvdW50XCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5mYWNlQ291bnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJmYWNlQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFjZUNvdW50KCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwiZmFjZUNvdW50XCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEV4cHJlc3Npb24gYSBuZXcgZXhwcmVzc2lvbiB3aXRoIHRoZSBwcmVkZWZpbmVkIHZhcmlhYmxlIFwiY3VycmVudFBhZ2VcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLmN1cnJlbnRQYWdlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY3VycmVudFBhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3VycmVudFBhZ2UoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJjdXJyZW50UGFnZVwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBFeHByZXNzaW9uIGEgbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcInRhZ3NcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLnRhZ3NcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ0YWdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRhZ3MoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJ0YWdzXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEV4cHJlc3Npb24gYSBuZXcgZXhwcmVzc2lvbiB3aXRoIHRoZSBwcmVkZWZpbmVkIHZhcmlhYmxlIFwicGFnZVhcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLnBhZ2VYXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicGFnZVhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFnZVgoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJwYWdlWFwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBFeHByZXNzaW9uIGEgbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcInBhZ2VZXCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5wYWdlWVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInBhZ2VZXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhZ2VZKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwicGFnZVlcIik7XG4gICAgfVxuICB9XSk7XG59KCk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5FeHByZXNzaW9uLk9QRVJBVE9SUyA9IHtcbiAgXCI9XCI6ICdlcScsXG4gIFwiIT1cIjogJ25lJyxcbiAgXCI8XCI6ICdsdCcsXG4gIFwiPlwiOiAnZ3QnLFxuICBcIjw9XCI6ICdsdGUnLFxuICBcIj49XCI6ICdndGUnLFxuICBcIiYmXCI6ICdhbmQnLFxuICBcInx8XCI6ICdvcicsXG4gIFwiKlwiOiBcIm11bFwiLFxuICBcIi9cIjogXCJkaXZcIixcbiAgXCIrXCI6IFwiYWRkXCIsXG4gIFwiLVwiOiBcInN1YlwiLFxuICBcIl5cIjogXCJwb3dcIlxufTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuRXhwcmVzc2lvbi5QUkVERUZJTkVEX1ZBUlMgPSB7XG4gIFwiYXNwZWN0X3JhdGlvXCI6IFwiYXJcIixcbiAgXCJhc3BlY3RSYXRpb1wiOiBcImFyXCIsXG4gIFwiY3VycmVudF9wYWdlXCI6IFwiY3BcIixcbiAgXCJjdXJyZW50UGFnZVwiOiBcImNwXCIsXG4gIFwiZHVyYXRpb25cIjogXCJkdVwiLFxuICBcImZhY2VfY291bnRcIjogXCJmY1wiLFxuICBcImZhY2VDb3VudFwiOiBcImZjXCIsXG4gIFwiaGVpZ2h0XCI6IFwiaFwiLFxuICBcImluaXRpYWxfYXNwZWN0X3JhdGlvXCI6IFwiaWFyXCIsXG4gIFwiaW5pdGlhbF9kdXJhdGlvblwiOiBcImlkdVwiLFxuICBcImluaXRpYWxfaGVpZ2h0XCI6IFwiaWhcIixcbiAgXCJpbml0aWFsX3dpZHRoXCI6IFwiaXdcIixcbiAgXCJpbml0aWFsQXNwZWN0UmF0aW9cIjogXCJpYXJcIixcbiAgXCJpbml0aWFsRHVyYXRpb25cIjogXCJpZHVcIixcbiAgXCJpbml0aWFsSGVpZ2h0XCI6IFwiaWhcIixcbiAgXCJpbml0aWFsV2lkdGhcIjogXCJpd1wiLFxuICBcInBhZ2VfY291bnRcIjogXCJwY1wiLFxuICBcInBhZ2VfeFwiOiBcInB4XCIsXG4gIFwicGFnZV95XCI6IFwicHlcIixcbiAgXCJwYWdlQ291bnRcIjogXCJwY1wiLFxuICBcInBhZ2VYXCI6IFwicHhcIixcbiAgXCJwYWdlWVwiOiBcInB5XCIsXG4gIFwidGFnc1wiOiBcInRhZ3NcIixcbiAgXCJ3aWR0aFwiOiBcIndcIlxufTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuRXhwcmVzc2lvbi5CT1VORFJZID0gXCJbIF9dK1wiO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZXhwcmVzc2lvbiA9IChFeHByZXNzaW9uKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbmRpdGlvbi5qc1xuZnVuY3Rpb24gY29uZGl0aW9uX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIGNvbmRpdGlvbl90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgY29uZGl0aW9uX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gY29uZGl0aW9uX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiBjb25kaXRpb25fZGVmaW5lUHJvcGVydGllcyhlLCByKSB7IGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykgeyB2YXIgbyA9IHJbdF07IG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBjb25kaXRpb25fdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIGNvbmRpdGlvbl9jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIGNvbmRpdGlvbl9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBjb25kaXRpb25fZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBjb25kaXRpb25fdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gY29uZGl0aW9uX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBjb25kaXRpb25fdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBjb25kaXRpb25fdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBjb25kaXRpb25fdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IGNvbmRpdGlvbl90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIGUpIHsgaWYgKGUgJiYgKFwib2JqZWN0XCIgPT0gY29uZGl0aW9uX3R5cGVvZihlKSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUpKSByZXR1cm4gZTsgaWYgKHZvaWQgMCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZCh0KTsgfVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChlKSB7IGlmICh2b2lkIDAgPT09IGUpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKHQpIHsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpOyB9LCBfZ2V0UHJvdG90eXBlT2YodCk7IH1cbmZ1bmN0aW9uIF9pbmhlcml0cyh0LCBlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUgJiYgbnVsbCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogdCwgd3JpdGFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0gfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZSAmJiBfc2V0UHJvdG90eXBlT2YodCwgZSk7IH1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZih0LCBlKSB7IHJldHVybiBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQsIGUpIHsgcmV0dXJuIHQuX19wcm90b19fID0gZSwgdDsgfSwgX3NldFByb3RvdHlwZU9mKHQsIGUpOyB9XG5cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdHJhbnNmb3JtYXRpb24gY29uZGl0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbmRpdGlvblN0ciAtIGEgY29uZGl0aW9uIGluIHN0cmluZyBmb3JtYXRcbiAqIEBjbGFzcyBDb25kaXRpb25cbiAqIEBleGFtcGxlXG4gKiAvLyBub3JtYWxseSB0aGlzIGNsYXNzIGlzIG5vdCBpbnN0YW50aWF0ZWQgZGlyZWN0bHlcbiAqIHZhciB0ciA9IGNsb3VkaW5hcnkuVHJhbnNmb3JtYXRpb24ubmV3KClcbiAqICAgIC5pZigpLndpZHRoKCBcIj5cIiwgMTAwMCkuYW5kKCkuYXNwZWN0UmF0aW8oXCI8XCIsIFwiMzo0XCIpLnRoZW4oKVxuICogICAgICAud2lkdGgoMTAwMClcbiAqICAgICAgLmNyb3AoXCJzY2FsZVwiKVxuICogICAgLmVsc2UoKVxuICogICAgICAud2lkdGgoNTAwKVxuICogICAgICAuY3JvcChcInNjYWxlXCIpXG4gKlxuICogdmFyIHRyID0gY2xvdWRpbmFyeS5UcmFuc2Zvcm1hdGlvbi5uZXcoKVxuICogICAgLmlmKFwidyA+IDEwMDAgYW5kIGFzcGVjdFJhdGlvIDwgMzo0XCIpXG4gKiAgICAgIC53aWR0aCgxMDAwKVxuICogICAgICAuY3JvcChcInNjYWxlXCIpXG4gKiAgICAuZWxzZSgpXG4gKiAgICAgIC53aWR0aCg1MDApXG4gKiAgICAgIC5jcm9wKFwic2NhbGVcIilcbiAqXG4gKi9cbnZhciBDb25kaXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FeHByZXNzaW9uKSB7XG4gIGZ1bmN0aW9uIENvbmRpdGlvbihjb25kaXRpb25TdHIpIHtcbiAgICBjb25kaXRpb25fY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29uZGl0aW9uKTtcbiAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBDb25kaXRpb24sIFtjb25kaXRpb25TdHJdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb24gQ29uZGl0aW9uI2hlaWdodFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAqIEByZXR1cm4ge0NvbmRpdGlvbn0gdGhpcyBjb25kaXRpb25cbiAgICovXG4gIF9pbmhlcml0cyhDb25kaXRpb24sIF9FeHByZXNzaW9uKTtcbiAgcmV0dXJuIGNvbmRpdGlvbl9jcmVhdGVDbGFzcyhDb25kaXRpb24sIFt7XG4gICAga2V5OiBcImhlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoZWlnaHQob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJoXCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIENvbmRpdGlvbiN3aWR0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciB0aGUgY29tcGFyaXNvbiBvcGVyYXRvciAoZS5nLiBcIjxcIiwgXCJsdFwiKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHJpZ2h0IGhhbmQgc2lkZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0NvbmRpdGlvbn0gdGhpcyBjb25kaXRpb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ3aWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aWR0aChvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcIndcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQ29uZGl0aW9uI2FzcGVjdFJhdGlvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAgICogQHJldHVybiB7Q29uZGl0aW9ufSB0aGlzIGNvbmRpdGlvblxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFzcGVjdFJhdGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFzcGVjdFJhdGlvKG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwiYXJcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQ29uZGl0aW9uI3BhZ2VzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAgICogQHJldHVybiB7Q29uZGl0aW9ufSB0aGlzIGNvbmRpdGlvblxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInBhZ2VDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYWdlQ291bnQob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJwY1wiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBDb25kaXRpb24jZmFjZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtDb25kaXRpb259IHRoaXMgY29uZGl0aW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZmFjZUNvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZhY2VDb3VudChvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcImZjXCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIENvbmRpdGlvbiNkdXJhdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciB0aGUgY29tcGFyaXNvbiBvcGVyYXRvciAoZS5nLiBcIjxcIiwgXCJsdFwiKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHJpZ2h0IGhhbmQgc2lkZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0NvbmRpdGlvbn0gdGhpcyBjb25kaXRpb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkdXJhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkdXJhdGlvbihvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcImR1XCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIENvbmRpdGlvbiNpbml0aWFsRHVyYXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtDb25kaXRpb259IHRoaXMgY29uZGl0aW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdGlhbER1cmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxEdXJhdGlvbihvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcImlkdVwiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cbiAgfV0pO1xufShleHByZXNzaW9uKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbmRpdGlvbiA9IChDb25kaXRpb24pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29uZmlndXJhdGlvbi5qc1xuZnVuY3Rpb24gY29uZmlndXJhdGlvbl90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBjb25maWd1cmF0aW9uX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBjb25maWd1cmF0aW9uX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkociwgZSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBlKSB8fCBjb25maWd1cmF0aW9uX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGUpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gY29uZmlndXJhdGlvbl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7IGlmIChyKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gY29uZmlndXJhdGlvbl9hcnJheUxpa2VUb0FycmF5KHIsIGEpOyB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpOyByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBjb25maWd1cmF0aW9uX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7IH0gfVxuZnVuY3Rpb24gY29uZmlndXJhdGlvbl9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHsgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpOyBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTsgcmV0dXJuIG47IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKHIpIHsgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByOyB9XG5mdW5jdGlvbiBjb25maWd1cmF0aW9uX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiBjb25maWd1cmF0aW9uX2RlZmluZVByb3BlcnRpZXMoZSwgcikgeyBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHsgdmFyIG8gPSByW3RdOyBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgY29uZmlndXJhdGlvbl90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7IH0gfVxuZnVuY3Rpb24gY29uZmlndXJhdGlvbl9jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIGNvbmZpZ3VyYXRpb25fZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgY29uZmlndXJhdGlvbl9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7IH1cbmZ1bmN0aW9uIGNvbmZpZ3VyYXRpb25fdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gY29uZmlndXJhdGlvbl90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gY29uZmlndXJhdGlvbl90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIGNvbmZpZ3VyYXRpb25fdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBjb25maWd1cmF0aW9uX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBjb25maWd1cmF0aW9uX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG4vKipcbiAqIENsYXNzIGZvciBkZWZpbmluZyBhY2NvdW50IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqIERlcGVuZHMgb24gJ3V0aWxzJ1xuICovXG5cblxuXG4vKipcbiAqIENsYXNzIGZvciBkZWZpbmluZyBhY2NvdW50IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqIEBjb25zdHJ1Y3RvciBDb25maWd1cmF0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBhY2NvdW50IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyB0byBzZXQuXG4gKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc29sdXRpb25fb3ZlcnZpZXcjY29uZmlndXJhdGlvbl9wYXJhbWV0ZXJzXCJcbiAqICB0YXJnZXQ9XCJfbmV3XCI+QXZhaWxhYmxlIGNvbmZpZ3VyYXRpb24gb3B0aW9uczwvYT5cbiAqL1xudmFyIGNvbmZpZ3VyYXRpb25fQ29uZmlndXJhdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbmZpZ3VyYXRpb24ob3B0aW9ucykge1xuICAgIGNvbmZpZ3VyYXRpb25fY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29uZmlndXJhdGlvbik7XG4gICAgdGhpcy5jb25maWd1cmF0aW9uID0gb3B0aW9ucyA9PSBudWxsID8ge30gOiBjbG9uZURlZXBfcm9vdF9jbG9uZURlZXBfZGVmYXVsdCgpKG9wdGlvbnMpO1xuICAgIGRlZmF1bHRzKHRoaXMuY29uZmlndXJhdGlvbiwgREVGQVVMVF9DT05GSUdVUkFUSU9OX1BBUkFNUyk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbmZpZ3VyYXRpb24uIFRoaXMgbWV0aG9kIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIHRoYXQgaW52b2tlcyBib3RoXG4gICAqICB7QGxpbmsgQ29uZmlndXJhdGlvbiNmcm9tRW52aXJvbm1lbnR8ZnJvbUVudmlyb25tZW50KCl9IChOb2RlLmpzIGVudmlyb25tZW50IG9ubHkpXG4gICAqICBhbmQge0BsaW5rIENvbmZpZ3VyYXRpb24jZnJvbURvY3VtZW50fGZyb21Eb2N1bWVudCgpfS5cbiAgICogIEl0IGZpcnN0IHRyaWVzIHRvIHJldHJpZXZlIHRoZSBjb25maWd1cmF0aW9uIGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICAgKiAgSWYgbm90IGF2YWlsYWJsZSwgaXQgdHJpZXMgZnJvbSB0aGUgZG9jdW1lbnQgbWV0YSB0YWdzLlxuICAgKiBAZnVuY3Rpb24gQ29uZmlndXJhdGlvbiNpbml0XG4gICAqIEByZXR1cm4ge0NvbmZpZ3VyYXRpb259IHJldHVybnMgYHRoaXNgIGZvciBjaGFpbmluZ1xuICAgKiBAc2VlIGZyb21Eb2N1bWVudFxuICAgKiBAc2VlIGZyb21FbnZpcm9ubWVudFxuICAgKi9cbiAgcmV0dXJuIGNvbmZpZ3VyYXRpb25fY3JlYXRlQ2xhc3MoQ29uZmlndXJhdGlvbiwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5mcm9tRW52aXJvbm1lbnQoKTtcbiAgICAgIHRoaXMuZnJvbURvY3VtZW50KCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBuZXcgY29uZmlndXJhdGlvbiBpdGVtXG4gICAgICogQGZ1bmN0aW9uIENvbmZpZ3VyYXRpb24jc2V0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgaXRlbSB0byBzZXRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIGJlIHNldFxuICAgICAqIEByZXR1cm4ge0NvbmZpZ3VyYXRpb259XG4gICAgICpcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLmNvbmZpZ3VyYXRpb25bbmFtZV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgb2YgYSBjb25maWd1cmF0aW9uIGl0ZW1cbiAgICAgKiBAZnVuY3Rpb24gQ29uZmlndXJhdGlvbiNnZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBpdGVtIHRvIHNldFxuICAgICAqIEByZXR1cm4geyp9IHRoZSBjb25maWd1cmF0aW9uIGl0ZW1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb25bbmFtZV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1lcmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lcmdlKGNvbmZpZykge1xuICAgICAgYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh0aGlzLmNvbmZpZ3VyYXRpb24sIGNsb25lRGVlcF9yb290X2Nsb25lRGVlcF9kZWZhdWx0KCkoY29uZmlnKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIENsb3VkaW5hcnkgZnJvbSBIVE1MIG1ldGEgdGFncy5cbiAgICAgKiBAZnVuY3Rpb24gQ29uZmlndXJhdGlvbiNmcm9tRG9jdW1lbnRcbiAgICAgKiBAcmV0dXJuIHtDb25maWd1cmF0aW9ufVxuICAgICAqIEBleGFtcGxlIDxtZXRhIG5hbWU9XCJjbG91ZGluYXJ5X2Nsb3VkX25hbWVcIiBjb250ZW50PVwibXljbG91ZFwiPlxuICAgICAqXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbURvY3VtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21Eb2N1bWVudCgpIHtcbiAgICAgIHZhciBlbCwgaSwgbGVuLCBtZXRhX2VsZW1lbnRzO1xuICAgICAgbWV0YV9lbGVtZW50cyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudCAhPT0gbnVsbCA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ21ldGFbbmFtZV49XCJjbG91ZGluYXJ5X1wiXScpIDogdm9pZCAwO1xuICAgICAgaWYgKG1ldGFfZWxlbWVudHMpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbWV0YV9lbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGVsID0gbWV0YV9lbGVtZW50c1tpXTtcbiAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25bZWwuZ2V0QXR0cmlidXRlKCduYW1lJykucmVwbGFjZSgnY2xvdWRpbmFyeV8nLCAnJyldID0gZWwuZ2V0QXR0cmlidXRlKCdjb250ZW50Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgQ2xvdWRpbmFyeSBmcm9tIHRoZSBgQ0xPVURJTkFSWV9VUkxgIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIG9ubHkgcnVuIHVuZGVyIE5vZGUuanMgZW52aXJvbm1lbnQuXG4gICAgICogQGZ1bmN0aW9uIENvbmZpZ3VyYXRpb24jZnJvbUVudmlyb25tZW50XG4gICAgICogQHJlcXVpcmVzIE5vZGUuanNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJmcm9tRW52aXJvbm1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUVudmlyb25tZW50KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBjbG91ZGluYXJ5X3VybCwgcXVlcnksIHVyaSwgdXJpUmVnZXg7XG4gICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2VzcyAhPT0gbnVsbCAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5DTE9VRElOQVJZX1VSTCkge1xuICAgICAgICBjbG91ZGluYXJ5X3VybCA9IHByb2Nlc3MuZW52LkNMT1VESU5BUllfVVJMO1xuICAgICAgICB1cmlSZWdleCA9IC9jbG91ZGluYXJ5OlxcL1xcLyg/OihcXHcrKSg/OlxcOihbXFx3LV0rKSk/QCk/KFtcXHdcXC4tXSspKD86XFwvKFteP10qKSk/KD86XFw/KC4rKSk/LztcbiAgICAgICAgdXJpID0gdXJpUmVnZXguZXhlYyhjbG91ZGluYXJ5X3VybCk7XG4gICAgICAgIGlmICh1cmkpIHtcbiAgICAgICAgICBpZiAodXJpWzNdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvblsnY2xvdWRfbmFtZSddID0gdXJpWzNdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodXJpWzFdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvblsnYXBpX2tleSddID0gdXJpWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodXJpWzJdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvblsnYXBpX3NlY3JldCddID0gdXJpWzJdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodXJpWzRdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvblsncHJpdmF0ZV9jZG4nXSA9IHVyaVs0XSAhPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodXJpWzRdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvblsnc2VjdXJlX2Rpc3RyaWJ1dGlvbiddID0gdXJpWzRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBxdWVyeSA9IHVyaVs1XTtcbiAgICAgICAgICBpZiAocXVlcnkgIT0gbnVsbCkge1xuICAgICAgICAgICAgcXVlcnkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICB2YXIgX3ZhbHVlJHNwbGl0ID0gdmFsdWUuc3BsaXQoJz0nKSxcbiAgICAgICAgICAgICAgICBfdmFsdWUkc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX3ZhbHVlJHNwbGl0LCAyKSxcbiAgICAgICAgICAgICAgICBrID0gX3ZhbHVlJHNwbGl0MlswXSxcbiAgICAgICAgICAgICAgICB2ID0gX3ZhbHVlJHNwbGl0MlsxXTtcbiAgICAgICAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHYgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF90aGlzLmNvbmZpZ3VyYXRpb25ba10gPSB2O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgb3IgbW9kaWZ5IHRoZSBDbG91ZGluYXJ5IGNsaWVudCBjb25maWd1cmF0aW9uXG4gICAgICpcbiAgICAgKiBXYXJuaW5nOiBgY29uZmlnKClgIHJldHVybnMgdGhlIGFjdHVhbCBpbnRlcm5hbCBjb25maWd1cmF0aW9uIG9iamVjdC4gbW9kaWZ5aW5nIGl0IHdpbGwgY2hhbmdlIHRoZSBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgbWV0aG9kLiBGb3IgbmV3IGNvZGUsIHVzZSBnZXQoKSwgbWVyZ2UoKSBldGMuXG4gICAgICogQGZ1bmN0aW9uIENvbmZpZ3VyYXRpb24jY29uZmlnXG4gICAgICogQHBhcmFtIHtoYXNofHN0cmluZ3xib29sZWFufSBuZXdfY29uZmlnXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld192YWx1ZVxuICAgICAqIEByZXR1cm5zIHsqfSBjb25maWd1cmF0aW9uLCBvciB2YWx1ZVxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgZnJvbUVudmlyb25tZW50fSBmb3IgaW5pdGlhbGl6YXRpb24gdXNpbmcgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAgICogQHNlZSB7QGxpbmsgZnJvbURvY3VtZW50fSBmb3IgaW5pdGlhbGl6YXRpb24gdXNpbmcgSFRNTCBtZXRhIHRhZ3NcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjb25maWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uZmlnKG5ld19jb25maWcsIG5ld192YWx1ZSkge1xuICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICBjYXNlIG5ld192YWx1ZSA9PT0gdm9pZCAwOlxuICAgICAgICAgIHRoaXMuc2V0KG5ld19jb25maWcsIG5ld192YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbjtcbiAgICAgICAgY2FzZSAhaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkobmV3X2NvbmZpZyk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KG5ld19jb25maWcpO1xuICAgICAgICBjYXNlICFpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkobmV3X2NvbmZpZyk6XG4gICAgICAgICAgdGhpcy5tZXJnZShuZXdfY29uZmlnKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHkgLSByZXR1cm4gdGhlIGludGVybmFsIG9iamVjdFxuICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICAgICAqIEBmdW5jdGlvbiBDb25maWd1cmF0aW9uI3RvT3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGEga2V5OnZhbHVlIGNvbGxlY3Rpb24gb2YgdGhlIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInRvT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b09wdGlvbnMoKSB7XG4gICAgICByZXR1cm4gY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwX2RlZmF1bHQoKSh0aGlzLmNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbiAgfV0pO1xufSgpO1xudmFyIERFRkFVTFRfQ09ORklHVVJBVElPTl9QQVJBTVMgPSB7XG4gIHJlc3BvbnNpdmVfY2xhc3M6ICdjbGQtcmVzcG9uc2l2ZScsXG4gIHJlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzOiB0cnVlLFxuICByb3VuZF9kcHI6IHRydWUsXG4gIHNlY3VyZTogKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93ICE9PSBudWxsID8gd2luZG93LmxvY2F0aW9uID8gd2luZG93LmxvY2F0aW9uLnByb3RvY29sIDogdm9pZCAwIDogdm9pZCAwKSA9PT0gJ2h0dHBzOidcbn07XG5jb25maWd1cmF0aW9uX0NvbmZpZ3VyYXRpb24uQ09ORklHX1BBUkFNUyA9IFtcImFwaV9rZXlcIiwgXCJhcGlfc2VjcmV0XCIsIFwiY2FsbGJhY2tcIiwgXCJjZG5fc3ViZG9tYWluXCIsIFwiY2xvdWRfbmFtZVwiLCBcImNuYW1lXCIsIFwicHJpdmF0ZV9jZG5cIiwgXCJwcm90b2NvbFwiLCBcInJlc291cmNlX3R5cGVcIiwgXCJyZXNwb25zaXZlXCIsIFwicmVzcG9uc2l2ZV9jbGFzc1wiLCBcInJlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzXCIsIFwicmVzcG9uc2l2ZV93aWR0aFwiLCBcInJvdW5kX2RwclwiLCBcInNlY3VyZVwiLCBcInNlY3VyZV9jZG5fc3ViZG9tYWluXCIsIFwic2VjdXJlX2Rpc3RyaWJ1dGlvblwiLCBcInNob3J0ZW5cIiwgXCJ0eXBlXCIsIFwidXBsb2FkX3ByZXNldFwiLCBcInVybF9zdWZmaXhcIiwgXCJ1c2Vfcm9vdF9wYXRoXCIsIFwidmVyc2lvblwiLCBcImV4dGVybmFsTGlicmFyaWVzXCIsIFwibWF4X3RpbWVvdXRfbXNcIl07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfY29uZmlndXJhdGlvbiA9IChjb25maWd1cmF0aW9uX0NvbmZpZ3VyYXRpb24pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbGF5ZXIvbGF5ZXIuanNcbmZ1bmN0aW9uIGxheWVyX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIGxheWVyX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBsYXllcl90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIGxheWVyX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiBsYXllcl9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIGxheWVyX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTsgfSB9XG5mdW5jdGlvbiBsYXllcl9jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIGxheWVyX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIGxheWVyX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTsgfVxuZnVuY3Rpb24gbGF5ZXJfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gbGF5ZXJfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IGxheWVyX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gbGF5ZXJfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBsYXllcl90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gbGF5ZXJfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cblxudmFyIGxheWVyX0xheWVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIExheWVyXG4gICAqIEBjb25zdHJ1Y3RvciBMYXllclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGxheWVyIHBhcmFtZXRlcnNcbiAgICovXG4gIGZ1bmN0aW9uIExheWVyKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGxheWVyX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExheWVyKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICBbXCJyZXNvdXJjZVR5cGVcIiwgXCJ0eXBlXCIsIFwicHVibGljSWRcIiwgXCJmb3JtYXRcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIHJldHVybiBfdGhpcy5vcHRpb25zW2tleV0gPSAocmVmID0gb3B0aW9uc1trZXldKSAhPSBudWxsID8gcmVmIDogb3B0aW9uc1tzbmFrZUNhc2Uoa2V5KV07XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxheWVyX2NyZWF0ZUNsYXNzKExheWVyLCBbe1xuICAgIGtleTogXCJyZXNvdXJjZVR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb3VyY2VUeXBlKHZhbHVlKSB7XG4gICAgICB0aGlzLm9wdGlvbnMucmVzb3VyY2VUeXBlID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0eXBlKHZhbHVlKSB7XG4gICAgICB0aGlzLm9wdGlvbnMudHlwZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInB1YmxpY0lkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1YmxpY0lkKHZhbHVlKSB7XG4gICAgICB0aGlzLm9wdGlvbnMucHVibGljSWQgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcHVibGljIElELCBmb3JtYXR0ZWQgZm9yIGxheWVyIHBhcmFtZXRlclxuICAgICAqIEBmdW5jdGlvbiBMYXllciNnZXRQdWJsaWNJZFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gcHVibGljIElEXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UHVibGljSWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHVibGljSWQoKSB7XG4gICAgICB2YXIgcmVmO1xuICAgICAgcmV0dXJuIChyZWYgPSB0aGlzLm9wdGlvbnMucHVibGljSWQpICE9IG51bGwgPyByZWYucmVwbGFjZSgvXFwvL2csIFwiOlwiKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHB1YmxpYyBJRCwgd2l0aCBmb3JtYXQgaWYgcHJlc2VudFxuICAgICAqIEBmdW5jdGlvbiBMYXllciNnZXRGdWxsUHVibGljSWRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHB1YmxpYyBJRFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEZ1bGxQdWJsaWNJZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGdWxsUHVibGljSWQoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFB1YmxpY0lkKCkgKyBcIi5cIiArIHRoaXMub3B0aW9ucy5mb3JtYXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQdWJsaWNJZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KHZhbHVlKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZm9ybWF0ID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZSB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsYXllclxuICAgICAqIEBmdW5jdGlvbiBMYXllciN0b1N0cmluZ1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIGNvbXBvbmVudHM7XG4gICAgICBjb21wb25lbnRzID0gW107XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnB1YmxpY0lkID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgXCJNdXN0IHN1cHBseSBwdWJsaWNJZFwiO1xuICAgICAgfVxuICAgICAgaWYgKCEodGhpcy5vcHRpb25zLnJlc291cmNlVHlwZSA9PT0gXCJpbWFnZVwiKSkge1xuICAgICAgICBjb21wb25lbnRzLnB1c2godGhpcy5vcHRpb25zLnJlc291cmNlVHlwZSk7XG4gICAgICB9XG4gICAgICBpZiAoISh0aGlzLm9wdGlvbnMudHlwZSA9PT0gXCJ1cGxvYWRcIikpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKHRoaXMub3B0aW9ucy50eXBlKTtcbiAgICAgIH1cbiAgICAgIGNvbXBvbmVudHMucHVzaCh0aGlzLmdldEZ1bGxQdWJsaWNJZCgpKTtcbiAgICAgIHJldHVybiBjb21wYWN0X3Jvb3RfY29tcGFjdF9kZWZhdWx0KCkoY29tcG9uZW50cykuam9pbihcIjpcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICB9XSk7XG59KCk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBsYXllcl9sYXllciA9IChsYXllcl9MYXllcik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9sYXllci90ZXh0bGF5ZXIuanNcbmZ1bmN0aW9uIHRleHRsYXllcl90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiB0ZXh0bGF5ZXJfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIHRleHRsYXllcl90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIHRleHRsYXllcl9jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxuZnVuY3Rpb24gdGV4dGxheWVyX2RlZmluZVByb3BlcnRpZXMoZSwgcikgeyBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHsgdmFyIG8gPSByW3RdOyBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgdGV4dGxheWVyX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTsgfSB9XG5mdW5jdGlvbiB0ZXh0bGF5ZXJfY3JlYXRlQ2xhc3MoZSwgciwgdCkgeyByZXR1cm4gciAmJiB0ZXh0bGF5ZXJfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgdGV4dGxheWVyX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTsgfVxuZnVuY3Rpb24gdGV4dGxheWVyX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IHRleHRsYXllcl90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gdGV4dGxheWVyX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gdGV4dGxheWVyX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gdGV4dGxheWVyX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSB0ZXh0bGF5ZXJfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbmZ1bmN0aW9uIHRleHRsYXllcl9jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IHRleHRsYXllcl9nZXRQcm90b3R5cGVPZihvKSwgdGV4dGxheWVyX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgdGV4dGxheWVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgdGV4dGxheWVyX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG5mdW5jdGlvbiB0ZXh0bGF5ZXJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBlKSB7IGlmIChlICYmIChcIm9iamVjdFwiID09IHRleHRsYXllcl90eXBlb2YoZSkgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlKSkgcmV0dXJuIGU7IGlmICh2b2lkIDAgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgcmV0dXJuIHRleHRsYXllcl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQodCk7IH1cbmZ1bmN0aW9uIHRleHRsYXllcl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoZSkgeyBpZiAodm9pZCAwID09PSBlKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IHJldHVybiBlOyB9XG5mdW5jdGlvbiB0ZXh0bGF5ZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAodGV4dGxheWVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbmZ1bmN0aW9uIHRleHRsYXllcl9nZXRQcm90b3R5cGVPZih0KSB7IHJldHVybiB0ZXh0bGF5ZXJfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZih0KTsgfSwgdGV4dGxheWVyX2dldFByb3RvdHlwZU9mKHQpOyB9XG5mdW5jdGlvbiB0ZXh0bGF5ZXJfaW5oZXJpdHModCwgZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlICYmIG51bGwgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHQsIHdyaXRhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCB9IH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGUgJiYgdGV4dGxheWVyX3NldFByb3RvdHlwZU9mKHQsIGUpOyB9XG5mdW5jdGlvbiB0ZXh0bGF5ZXJfc2V0UHJvdG90eXBlT2YodCwgZSkgeyByZXR1cm4gdGV4dGxheWVyX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0LCBlKSB7IHJldHVybiB0Ll9fcHJvdG9fXyA9IGUsIHQ7IH0sIHRleHRsYXllcl9zZXRQcm90b3R5cGVPZih0LCBlKTsgfVxuXG5cbnZhciB0ZXh0bGF5ZXJfVGV4dExheWVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTGF5ZXIpIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBUZXh0TGF5ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBsYXllciBwYXJhbWV0ZXJzXG4gICAqL1xuICBmdW5jdGlvbiBUZXh0TGF5ZXIob3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcbiAgICB0ZXh0bGF5ZXJfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dExheWVyKTtcbiAgICB2YXIga2V5cztcbiAgICBfdGhpcyA9IHRleHRsYXllcl9jYWxsU3VwZXIodGhpcywgVGV4dExheWVyLCBbb3B0aW9uc10pO1xuICAgIGtleXMgPSBbXCJyZXNvdXJjZVR5cGVcIiwgXCJyZXNvdXJjZVR5cGVcIiwgXCJmb250RmFtaWx5XCIsIFwiZm9udFNpemVcIiwgXCJmb250V2VpZ2h0XCIsIFwiZm9udFN0eWxlXCIsIFwidGV4dERlY29yYXRpb25cIiwgXCJ0ZXh0QWxpZ25cIiwgXCJzdHJva2VcIiwgXCJsZXR0ZXJTcGFjaW5nXCIsIFwibGluZVNwYWNpbmdcIiwgXCJmb250SGludGluZ1wiLCBcImZvbnRBbnRpYWxpYXNpbmdcIiwgXCJ0ZXh0XCIsIFwidGV4dFN0eWxlXCJdO1xuICAgIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIHJldHVybiBfdGhpcy5vcHRpb25zW2tleV0gPSAocmVmID0gb3B0aW9uc1trZXldKSAhPSBudWxsID8gcmVmIDogb3B0aW9uc1tzbmFrZUNhc2Uoa2V5KV07XG4gICAgICB9KTtcbiAgICB9XG4gICAgX3RoaXMub3B0aW9ucy5yZXNvdXJjZVR5cGUgPSBcInRleHRcIjtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdGV4dGxheWVyX2luaGVyaXRzKFRleHRMYXllciwgX0xheWVyKTtcbiAgcmV0dXJuIHRleHRsYXllcl9jcmVhdGVDbGFzcyhUZXh0TGF5ZXIsIFt7XG4gICAga2V5OiBcInJlc291cmNlVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvdXJjZVR5cGUoX3Jlc291cmNlVHlwZSkge1xuICAgICAgdGhyb3cgXCJDYW5ub3QgbW9kaWZ5IHJlc291cmNlVHlwZSBmb3IgdGV4dCBsYXllcnNcIjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0eXBlKF90eXBlKSB7XG4gICAgICB0aHJvdyBcIkNhbm5vdCBtb2RpZnkgdHlwZSBmb3IgdGV4dCBsYXllcnNcIjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChfZm9ybWF0KSB7XG4gICAgICB0aHJvdyBcIkNhbm5vdCBtb2RpZnkgZm9ybWF0IGZvciB0ZXh0IGxheWVyc1wiO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb250RmFtaWx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvbnRGYW1pbHkoX2ZvbnRGYW1pbHkpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5mb250RmFtaWx5ID0gX2ZvbnRGYW1pbHk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9udFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9udFNpemUoX2ZvbnRTaXplKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZm9udFNpemUgPSBfZm9udFNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9udFdlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb250V2VpZ2h0KF9mb250V2VpZ2h0KSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZm9udFdlaWdodCA9IF9mb250V2VpZ2h0O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvbnRTdHlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb250U3R5bGUoX2ZvbnRTdHlsZSkge1xuICAgICAgdGhpcy5vcHRpb25zLmZvbnRTdHlsZSA9IF9mb250U3R5bGU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGV4dERlY29yYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGV4dERlY29yYXRpb24oX3RleHREZWNvcmF0aW9uKSB7XG4gICAgICB0aGlzLm9wdGlvbnMudGV4dERlY29yYXRpb24gPSBfdGV4dERlY29yYXRpb247XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGV4dEFsaWduXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRleHRBbGlnbihfdGV4dEFsaWduKSB7XG4gICAgICB0aGlzLm9wdGlvbnMudGV4dEFsaWduID0gX3RleHRBbGlnbjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdHJva2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3Ryb2tlKF9zdHJva2UpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5zdHJva2UgPSBfc3Ryb2tlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxldHRlclNwYWNpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGV0dGVyU3BhY2luZyhfbGV0dGVyU3BhY2luZykge1xuICAgICAgdGhpcy5vcHRpb25zLmxldHRlclNwYWNpbmcgPSBfbGV0dGVyU3BhY2luZztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsaW5lU3BhY2luZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaW5lU3BhY2luZyhfbGluZVNwYWNpbmcpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5saW5lU3BhY2luZyA9IF9saW5lU3BhY2luZztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb250SGludGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb250SGludGluZyhfZm9udEhpbnRpbmcpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5mb250SGludGluZyA9IF9mb250SGludGluZztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb250QW50aWFsaWFzaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvbnRBbnRpYWxpYXNpbmcoX2ZvbnRBbnRpYWxpYXNpbmcpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5mb250QW50aWFsaWFzaW5nID0gX2ZvbnRBbnRpYWxpYXNpbmc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXh0KF90ZXh0KSB7XG4gICAgICB0aGlzLm9wdGlvbnMudGV4dCA9IF90ZXh0O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHRTdHlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXh0U3R5bGUoX3RleHRTdHlsZSkge1xuICAgICAgdGhpcy5vcHRpb25zLnRleHRTdHlsZSA9IF90ZXh0U3R5bGU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZSB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsYXllclxuICAgICAqIEBmdW5jdGlvbiBUZXh0TGF5ZXIjdG9TdHJpbmdcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgY29tcG9uZW50cywgaGFzUHVibGljSWQsIGhhc1N0eWxlLCBwdWJsaWNJZCwgcmUsIHJlcywgc3RhcnQsIHN0eWxlLCB0ZXh0LCB0ZXh0U291cmNlO1xuICAgICAgc3R5bGUgPSB0aGlzLnRleHRTdHlsZUlkZW50aWZpZXIoKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucHVibGljSWQgIT0gbnVsbCkge1xuICAgICAgICBwdWJsaWNJZCA9IHRoaXMuZ2V0RnVsbFB1YmxpY0lkKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRleHQgIT0gbnVsbCkge1xuICAgICAgICBoYXNQdWJsaWNJZCA9ICFpc0VtcHR5KHB1YmxpY0lkKTtcbiAgICAgICAgaGFzU3R5bGUgPSAhaXNFbXB0eShzdHlsZSk7XG4gICAgICAgIGlmIChoYXNQdWJsaWNJZCAmJiBoYXNTdHlsZSB8fCAhaGFzUHVibGljSWQgJiYgIWhhc1N0eWxlKSB7XG4gICAgICAgICAgdGhyb3cgXCJNdXN0IHN1cHBseSBlaXRoZXIgc3R5bGUgcGFyYW1ldGVycyBvciBhIHB1YmxpY19pZCB3aGVuIHByb3ZpZGluZyB0ZXh0IHBhcmFtZXRlciBpbiBhIHRleHQgb3ZlcmxheS91bmRlcmxheSwgYnV0IG5vdCBib3RoIVwiO1xuICAgICAgICB9XG4gICAgICAgIHJlID0gL1xcJFxcKFthLXpBLVpdXFx3KlxcKS9nO1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIC8vICAgICAgICB0ZXh0U291cmNlID0gdGV4dC5yZXBsYWNlKG5ldyBSZWdFeHAoXCJbLC9dXCIsICdnJyksIChjKS0+IFwiJSN7Yy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpfVwiKVxuICAgICAgICB0ZXh0U291cmNlID0gc21hcnRFc2NhcGUodGhpcy5vcHRpb25zLnRleHQsIC9bLFxcL10vZyk7XG4gICAgICAgIHRleHQgPSBcIlwiO1xuICAgICAgICB3aGlsZSAocmVzID0gcmUuZXhlYyh0ZXh0U291cmNlKSkge1xuICAgICAgICAgIHRleHQgKz0gc21hcnRFc2NhcGUodGV4dFNvdXJjZS5zbGljZShzdGFydCwgcmVzLmluZGV4KSk7XG4gICAgICAgICAgdGV4dCArPSByZXNbMF07XG4gICAgICAgICAgc3RhcnQgPSByZXMuaW5kZXggKyByZXNbMF0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgKz0gc21hcnRFc2NhcGUodGV4dFNvdXJjZS5zbGljZShzdGFydCkpO1xuICAgICAgfVxuICAgICAgY29tcG9uZW50cyA9IFt0aGlzLm9wdGlvbnMucmVzb3VyY2VUeXBlLCBzdHlsZSwgcHVibGljSWQsIHRleHRdO1xuICAgICAgcmV0dXJuIGNvbXBhY3Rfcm9vdF9jb21wYWN0X2RlZmF1bHQoKShjb21wb25lbnRzKS5qb2luKFwiOlwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGV4dFN0eWxlSWRlbnRpZmllclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXh0U3R5bGVJZGVudGlmaWVyKCkge1xuICAgICAgLy8gTm90ZTogaWYgYSB0ZXh0LXN0eWxlIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGFzIGEgd2hvbGUsIGl0IG92ZXJyaWRlcyBldmVyeXRoaW5nIGVsc2UsIG5vIG1peCBhbmQgbWF0Y2guXG4gICAgICBpZiAoIWlzRW1wdHkodGhpcy5vcHRpb25zLnRleHRTdHlsZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy50ZXh0U3R5bGU7XG4gICAgICB9XG4gICAgICB2YXIgY29tcG9uZW50cztcbiAgICAgIGNvbXBvbmVudHMgPSBbXTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZm9udFdlaWdodCAhPT0gXCJub3JtYWxcIikge1xuICAgICAgICBjb21wb25lbnRzLnB1c2godGhpcy5vcHRpb25zLmZvbnRXZWlnaHQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5mb250U3R5bGUgIT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKHRoaXMub3B0aW9ucy5mb250U3R5bGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy50ZXh0RGVjb3JhdGlvbiAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKHRoaXMub3B0aW9ucy50ZXh0RGVjb3JhdGlvbik7XG4gICAgICB9XG4gICAgICBjb21wb25lbnRzLnB1c2godGhpcy5vcHRpb25zLnRleHRBbGlnbik7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN0cm9rZSAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKHRoaXMub3B0aW9ucy5zdHJva2UpO1xuICAgICAgfVxuICAgICAgaWYgKCEoaXNFbXB0eSh0aGlzLm9wdGlvbnMubGV0dGVyU3BhY2luZykgJiYgIWlzTnVtYmVyTGlrZSh0aGlzLm9wdGlvbnMubGV0dGVyU3BhY2luZykpKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChcImxldHRlcl9zcGFjaW5nX1wiICsgdGhpcy5vcHRpb25zLmxldHRlclNwYWNpbmcpO1xuICAgICAgfVxuICAgICAgaWYgKCEoaXNFbXB0eSh0aGlzLm9wdGlvbnMubGluZVNwYWNpbmcpICYmICFpc051bWJlckxpa2UodGhpcy5vcHRpb25zLmxpbmVTcGFjaW5nKSkpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKFwibGluZV9zcGFjaW5nX1wiICsgdGhpcy5vcHRpb25zLmxpbmVTcGFjaW5nKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNFbXB0eSh0aGlzLm9wdGlvbnMuZm9udEFudGlhbGlhc2luZykpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKFwiYW50aWFsaWFzX1wiICsgdGhpcy5vcHRpb25zLmZvbnRBbnRpYWxpYXNpbmcpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0VtcHR5KHRoaXMub3B0aW9ucy5mb250SGludGluZykpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKFwiaGludGluZ19cIiArIHRoaXMub3B0aW9ucy5mb250SGludGluZyk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzRW1wdHkoY29tcGFjdF9yb290X2NvbXBhY3RfZGVmYXVsdCgpKGNvbXBvbmVudHMpKSkge1xuICAgICAgICBpZiAoaXNFbXB0eSh0aGlzLm9wdGlvbnMuZm9udEZhbWlseSkpIHtcbiAgICAgICAgICB0aHJvdyBcIk11c3Qgc3VwcGx5IGZvbnRGYW1pbHkuIFwiLmNvbmNhdChjb21wb25lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNFbXB0eSh0aGlzLm9wdGlvbnMuZm9udFNpemUpICYmICFpc051bWJlckxpa2UodGhpcy5vcHRpb25zLmZvbnRTaXplKSkge1xuICAgICAgICAgIHRocm93IFwiTXVzdCBzdXBwbHkgZm9udFNpemUuXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbXBvbmVudHMudW5zaGlmdCh0aGlzLm9wdGlvbnMuZm9udEZhbWlseSwgdGhpcy5vcHRpb25zLmZvbnRTaXplKTtcbiAgICAgIGNvbXBvbmVudHMgPSBjb21wYWN0X3Jvb3RfY29tcGFjdF9kZWZhdWx0KCkoY29tcG9uZW50cykuam9pbihcIl9cIik7XG4gICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9XG4gIH1dKTtcbn0obGF5ZXJfbGF5ZXIpO1xuO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdGV4dGxheWVyID0gKHRleHRsYXllcl9UZXh0TGF5ZXIpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbGF5ZXIvc3VidGl0bGVzbGF5ZXIuanNcbmZ1bmN0aW9uIHN1YnRpdGxlc2xheWVyX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIHN1YnRpdGxlc2xheWVyX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBzdWJ0aXRsZXNsYXllcl90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIHN1YnRpdGxlc2xheWVyX2RlZmluZVByb3BlcnRpZXMoZSwgcikgeyBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHsgdmFyIG8gPSByW3RdOyBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgc3VidGl0bGVzbGF5ZXJfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIHN1YnRpdGxlc2xheWVyX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHsgcmV0dXJuIHIgJiYgc3VidGl0bGVzbGF5ZXJfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgc3VidGl0bGVzbGF5ZXJfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBzdWJ0aXRsZXNsYXllcl90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gc3VidGl0bGVzbGF5ZXJfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IHN1YnRpdGxlc2xheWVyX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBzdWJ0aXRsZXNsYXllcl90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfY2xhc3NDYWxsQ2hlY2soYSwgbikgeyBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH1cbmZ1bmN0aW9uIHN1YnRpdGxlc2xheWVyX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gc3VidGl0bGVzbGF5ZXJfZ2V0UHJvdG90eXBlT2YobyksIHN1YnRpdGxlc2xheWVyX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgc3VidGl0bGVzbGF5ZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBzdWJ0aXRsZXNsYXllcl9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBlKSB7IGlmIChlICYmIChcIm9iamVjdFwiID09IHN1YnRpdGxlc2xheWVyX3R5cGVvZihlKSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUpKSByZXR1cm4gZTsgaWYgKHZvaWQgMCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyByZXR1cm4gc3VidGl0bGVzbGF5ZXJfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHQpOyB9XG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoZSkgeyBpZiAodm9pZCAwID09PSBlKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IHJldHVybiBlOyB9XG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChzdWJ0aXRsZXNsYXllcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl9nZXRQcm90b3R5cGVPZih0KSB7IHJldHVybiBzdWJ0aXRsZXNsYXllcl9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpOyB9LCBzdWJ0aXRsZXNsYXllcl9nZXRQcm90b3R5cGVPZih0KTsgfVxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfaW5oZXJpdHModCwgZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlICYmIG51bGwgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHQsIHdyaXRhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCB9IH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGUgJiYgc3VidGl0bGVzbGF5ZXJfc2V0UHJvdG90eXBlT2YodCwgZSk7IH1cbmZ1bmN0aW9uIHN1YnRpdGxlc2xheWVyX3NldFByb3RvdHlwZU9mKHQsIGUpIHsgcmV0dXJuIHN1YnRpdGxlc2xheWVyX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0LCBlKSB7IHJldHVybiB0Ll9fcHJvdG9fXyA9IGUsIHQ7IH0sIHN1YnRpdGxlc2xheWVyX3NldFByb3RvdHlwZU9mKHQsIGUpOyB9XG5cbnZhciBTdWJ0aXRsZXNMYXllciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RleHRMYXllcikge1xuICAvKipcbiAgICogUmVwcmVzZW50IGEgc3VidGl0bGVzIGxheWVyXG4gICAqIEBjb25zdHJ1Y3RvciBTdWJ0aXRsZXNMYXllclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGxheWVyIHBhcmFtZXRlcnNcbiAgICovXG4gIGZ1bmN0aW9uIFN1YnRpdGxlc0xheWVyKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgc3VidGl0bGVzbGF5ZXJfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3VidGl0bGVzTGF5ZXIpO1xuICAgIF90aGlzID0gc3VidGl0bGVzbGF5ZXJfY2FsbFN1cGVyKHRoaXMsIFN1YnRpdGxlc0xheWVyLCBbb3B0aW9uc10pO1xuICAgIF90aGlzLm9wdGlvbnMucmVzb3VyY2VUeXBlID0gXCJzdWJ0aXRsZXNcIjtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgc3VidGl0bGVzbGF5ZXJfaW5oZXJpdHMoU3VidGl0bGVzTGF5ZXIsIF9UZXh0TGF5ZXIpO1xuICByZXR1cm4gc3VidGl0bGVzbGF5ZXJfY3JlYXRlQ2xhc3MoU3VidGl0bGVzTGF5ZXIpO1xufSh0ZXh0bGF5ZXIpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3VidGl0bGVzbGF5ZXIgPSAoU3VidGl0bGVzTGF5ZXIpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbGF5ZXIvZmV0Y2hsYXllci5qc1xuZnVuY3Rpb24gZmV0Y2hsYXllcl90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBmZXRjaGxheWVyX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBmZXRjaGxheWVyX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gZmV0Y2hsYXllcl9jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxuZnVuY3Rpb24gZmV0Y2hsYXllcl9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIGZldGNobGF5ZXJfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIGZldGNobGF5ZXJfY3JlYXRlQ2xhc3MoZSwgciwgdCkgeyByZXR1cm4gciAmJiBmZXRjaGxheWVyX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIGZldGNobGF5ZXJfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBmZXRjaGxheWVyX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IGZldGNobGF5ZXJfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IGZldGNobGF5ZXJfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBmZXRjaGxheWVyX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gZmV0Y2hsYXllcl90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gZmV0Y2hsYXllcl90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gZmV0Y2hsYXllcl9jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IGZldGNobGF5ZXJfZ2V0UHJvdG90eXBlT2YobyksIGZldGNobGF5ZXJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBmZXRjaGxheWVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgZmV0Y2hsYXllcl9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuZnVuY3Rpb24gZmV0Y2hsYXllcl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIGUpIHsgaWYgKGUgJiYgKFwib2JqZWN0XCIgPT0gZmV0Y2hsYXllcl90eXBlb2YoZSkgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlKSkgcmV0dXJuIGU7IGlmICh2b2lkIDAgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgcmV0dXJuIGZldGNobGF5ZXJfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHQpOyB9XG5mdW5jdGlvbiBmZXRjaGxheWVyX2Fzc2VydFRoaXNJbml0aWFsaXplZChlKSB7IGlmICh2b2lkIDAgPT09IGUpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIGZldGNobGF5ZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoZmV0Y2hsYXllcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG5mdW5jdGlvbiBmZXRjaGxheWVyX2dldFByb3RvdHlwZU9mKHQpIHsgcmV0dXJuIGZldGNobGF5ZXJfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZih0KTsgfSwgZmV0Y2hsYXllcl9nZXRQcm90b3R5cGVPZih0KTsgfVxuZnVuY3Rpb24gZmV0Y2hsYXllcl9pbmhlcml0cyh0LCBlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUgJiYgbnVsbCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogdCwgd3JpdGFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0gfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZSAmJiBmZXRjaGxheWVyX3NldFByb3RvdHlwZU9mKHQsIGUpOyB9XG5mdW5jdGlvbiBmZXRjaGxheWVyX3NldFByb3RvdHlwZU9mKHQsIGUpIHsgcmV0dXJuIGZldGNobGF5ZXJfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQsIGUpIHsgcmV0dXJuIHQuX19wcm90b19fID0gZSwgdDsgfSwgZmV0Y2hsYXllcl9zZXRQcm90b3R5cGVPZih0LCBlKTsgfVxuXG5cbnZhciBmZXRjaGxheWVyX0ZldGNoTGF5ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9MYXllcikge1xuICAvKipcbiAgICogQGNsYXNzIEZldGNoTGF5ZXJcbiAgICogQGNsYXNzZGVzYyBDcmVhdGVzIGFuIGltYWdlIGxheWVyIHVzaW5nIGEgcmVtb3RlIFVSTC5cbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBvcHRpb25zIC0gbGF5ZXIgcGFyYW1ldGVycyBvciBhIHVybFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy51cmwgdGhlIHVybCBvZiB0aGUgaW1hZ2UgdG8gZmV0Y2hcbiAgICovXG4gIGZ1bmN0aW9uIEZldGNoTGF5ZXIob3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcbiAgICBmZXRjaGxheWVyX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZldGNoTGF5ZXIpO1xuICAgIF90aGlzID0gZmV0Y2hsYXllcl9jYWxsU3VwZXIodGhpcywgRmV0Y2hMYXllciwgW29wdGlvbnNdKTtcbiAgICBpZiAoaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkob3B0aW9ucykpIHtcbiAgICAgIF90aGlzLm9wdGlvbnMudXJsID0gb3B0aW9ucztcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMudXJsIDogdm9pZCAwKSB7XG4gICAgICBfdGhpcy5vcHRpb25zLnVybCA9IG9wdGlvbnMudXJsO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgZmV0Y2hsYXllcl9pbmhlcml0cyhGZXRjaExheWVyLCBfTGF5ZXIpO1xuICByZXR1cm4gZmV0Y2hsYXllcl9jcmVhdGVDbGFzcyhGZXRjaExheWVyLCBbe1xuICAgIGtleTogXCJ1cmxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXJsKF91cmwpIHtcbiAgICAgIHRoaXMub3B0aW9ucy51cmwgPSBfdXJsO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2VuZXJhdGUgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbGF5ZXJcbiAgICAgKiBAZnVuY3Rpb24gRmV0Y2hMYXllciN0b1N0cmluZ1xuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcImZldGNoOlwiLmNvbmNhdChiYXNlNjRFbmNvZGVVUkwodGhpcy5vcHRpb25zLnVybCkpO1xuICAgIH1cbiAgfV0pO1xufShsYXllcl9sYXllcik7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBmZXRjaGxheWVyID0gKGZldGNobGF5ZXJfRmV0Y2hMYXllcik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9wYXJhbWV0ZXJzLmpzXG5mdW5jdGlvbiBwYXJhbWV0ZXJzX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gcGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZihvKSwgcGFyYW1ldGVyc19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIHBhcmFtZXRlcnNfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG5mdW5jdGlvbiBwYXJhbWV0ZXJzX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgZSkgeyBpZiAoZSAmJiAoXCJvYmplY3RcIiA9PSBwYXJhbWV0ZXJzX3R5cGVvZihlKSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUpKSByZXR1cm4gZTsgaWYgKHZvaWQgMCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyByZXR1cm4gcGFyYW1ldGVyc19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQodCk7IH1cbmZ1bmN0aW9uIHBhcmFtZXRlcnNfYXNzZXJ0VGhpc0luaXRpYWxpemVkKGUpIHsgaWYgKHZvaWQgMCA9PT0gZSkgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyByZXR1cm4gZTsgfVxuZnVuY3Rpb24gcGFyYW1ldGVyc19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChwYXJhbWV0ZXJzX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbmZ1bmN0aW9uIF9zdXBlclByb3BHZXQodCwgbywgZSwgcikgeyB2YXIgcCA9IF9nZXQocGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZigxICYgciA/IHQucHJvdG90eXBlIDogdCksIG8sIGUpOyByZXR1cm4gMiAmIHIgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBwID8gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHAuYXBwbHkoZSwgdCk7IH0gOiBwOyB9XG5mdW5jdGlvbiBfZ2V0KCkgeyByZXR1cm4gX2dldCA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFJlZmxlY3QgJiYgUmVmbGVjdC5nZXQgPyBSZWZsZWN0LmdldC5iaW5kKCkgOiBmdW5jdGlvbiAoZSwgdCwgcikgeyB2YXIgcCA9IF9zdXBlclByb3BCYXNlKGUsIHQpOyBpZiAocCkgeyB2YXIgbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocCwgdCk7IHJldHVybiBuLmdldCA/IG4uZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBlIDogcikgOiBuLnZhbHVlOyB9IH0sIF9nZXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2UodCwgbykgeyBmb3IgKDsgIXt9Lmhhc093blByb3BlcnR5LmNhbGwodCwgbykgJiYgbnVsbCAhPT0gKHQgPSBwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mKHQpKTspOyByZXR1cm4gdDsgfVxuZnVuY3Rpb24gcGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZih0KSB7IHJldHVybiBwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7IH0sIHBhcmFtZXRlcnNfZ2V0UHJvdG90eXBlT2YodCk7IH1cbmZ1bmN0aW9uIHBhcmFtZXRlcnNfaW5oZXJpdHModCwgZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlICYmIG51bGwgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHQsIHdyaXRhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCB9IH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGUgJiYgcGFyYW1ldGVyc19zZXRQcm90b3R5cGVPZih0LCBlKTsgfVxuZnVuY3Rpb24gcGFyYW1ldGVyc19zZXRQcm90b3R5cGVPZih0LCBlKSB7IHJldHVybiBwYXJhbWV0ZXJzX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0LCBlKSB7IHJldHVybiB0Ll9fcHJvdG9fXyA9IGUsIHQ7IH0sIHBhcmFtZXRlcnNfc2V0UHJvdG90eXBlT2YodCwgZSk7IH1cbmZ1bmN0aW9uIHBhcmFtZXRlcnNfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gcGFyYW1ldGVyc190eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgcGFyYW1ldGVyc190eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIHBhcmFtZXRlcnNfY2xhc3NDYWxsQ2hlY2soYSwgbikgeyBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH1cbmZ1bmN0aW9uIHBhcmFtZXRlcnNfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7IGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykgeyB2YXIgbyA9IHJbdF07IG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBwYXJhbWV0ZXJzX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTsgfSB9XG5mdW5jdGlvbiBwYXJhbWV0ZXJzX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHsgcmV0dXJuIHIgJiYgcGFyYW1ldGVyc19kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBwYXJhbWV0ZXJzX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTsgfVxuZnVuY3Rpb24gcGFyYW1ldGVyc190b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBwYXJhbWV0ZXJzX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBwYXJhbWV0ZXJzX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gcGFyYW1ldGVyc190b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IHBhcmFtZXRlcnNfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IHBhcmFtZXRlcnNfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cblxuXG5cblxuXG5cblxuXG4vKipcbiAqIFRyYW5zZm9ybWF0aW9uIHBhcmFtZXRlcnNcbiAqIERlcGVuZHMgb24gJ3V0aWwnLCAndHJhbnNmb3JtYXRpb24nXG4gKi9cbnZhciBwYXJhbWV0ZXJzX1BhcmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBzaW5nbGUgcGFyYW1ldGVyLlxuICAgKiBAY2xhc3MgUGFyYW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyIGluIHNuYWtlX2Nhc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNob3J0TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzZXJpYWxpemVkIGZvcm0gb2YgdGhlIHBhcmFtZXRlci5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgSWYgYSB2YWx1ZSBpcyBub3QgcHJvdmlkZWQsIHRoZSBwYXJhbWV0ZXIgd2lsbCBub3QgYmUgc2VyaWFsaXplZC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW3Byb2Nlc3M9VXRpbC5pZGVudGl0eSBdIC0gTWFuaXB1bGF0ZSBvcmlnVmFsdWUgd2hlbiB2YWx1ZSBpcyBjYWxsZWRcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZnVuY3Rpb24gUGFyYW0obmFtZSwgc2hvcnROYW1lKSB7XG4gICAgdmFyIHByb2Nlc3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGlkZW50aXR5X3Jvb3RfaWRlbnRpdHlfZGVmYXVsdC5hO1xuICAgIHBhcmFtZXRlcnNfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFyYW0pO1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIgaW4gc25ha2VfY2FzZVxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gUGFyYW0jbmFtZVxuICAgICAqL1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgcGFyYW1ldGVyXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBQYXJhbSNzaG9ydE5hbWVcbiAgICAgKi9cbiAgICB0aGlzLnNob3J0TmFtZSA9IHNob3J0TmFtZTtcbiAgICAvKipcbiAgICAgKiBNYW5pcHVsYXRlIG9yaWdWYWx1ZSB3aGVuIHZhbHVlIGlzIGNhbGxlZFxuICAgICAqIEBtZW1iZXIge2Z1bmN0aW9ufSBQYXJhbSNwcm9jZXNzXG4gICAgICovXG4gICAgdGhpcy5wcm9jZXNzID0gcHJvY2VzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSAodW5wcm9jZXNzZWQpIHZhbHVlIGZvciB0aGlzIHBhcmFtZXRlclxuICAgKiBAZnVuY3Rpb24gUGFyYW0jc2V0XG4gICAqIEBwYXJhbSB7Kn0gb3JpZ1ZhbHVlIC0gdGhlIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICogQHJldHVybiB7UGFyYW19IHNlbGYgZm9yIGNoYWluaW5nXG4gICAqL1xuICByZXR1cm4gcGFyYW1ldGVyc19jcmVhdGVDbGFzcyhQYXJhbSwgW3tcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChvcmlnVmFsdWUpIHtcbiAgICAgIHRoaXMub3JpZ1ZhbHVlID0gb3JpZ1ZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgcGFyYW1ldGVyXG4gICAgICogQGZ1bmN0aW9uIFBhcmFtI3NlcmlhbGl6ZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgcGFyYW1ldGVyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHZhciB2YWwsIHZhbGlkO1xuICAgICAgdmFsID0gdGhpcy52YWx1ZSgpO1xuICAgICAgdmFsaWQgPSBpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkodmFsKSB8fCBpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkodmFsKSB8fCBpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQoKSh2YWwpID8gIWlzRW1wdHkodmFsKSA6IHZhbCAhPSBudWxsO1xuICAgICAgaWYgKHRoaXMuc2hvcnROYW1lICE9IG51bGwgJiYgdmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMuc2hvcnROYW1lLCBcIl9cIikuY29uY2F0KHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBwcm9jZXNzZWQgdmFsdWUgb2YgdGhlIHBhcmFtZXRlclxuICAgICAqIEBmdW5jdGlvbiBQYXJhbSN2YWx1ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzcyh0aGlzLm9yaWdWYWx1ZSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwibm9ybV9jb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3JtX2NvbG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IHZhbHVlLnJlcGxhY2UoL14jLywgJ3JnYjonKSA6IHZvaWQgMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYnVpbGRfYXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRfYXJyYXkoYXJnKSB7XG4gICAgICBpZiAoYXJnID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkoYXJnKSkge1xuICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFthcmddO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICogQ292ZXJ0IHZhbHVlIHRvIHZpZGVvIGNvZGVjIHN0cmluZy5cbiAgICAqXG4gICAgKiBJZiB0aGUgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCxcbiAgICAqIEBwYXJhbSB7KHN0cmluZ3xPYmplY3QpfSBwYXJhbSAtIHRoZSB2aWRlbyBjb2RlYyBhcyBlaXRoZXIgYSBTdHJpbmcgb3IgYSBIYXNoXG4gICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSB2aWRlbyBjb2RlYyBzdHJpbmcgaW4gdGhlIGZvcm1hdCBjb2RlYzpwcm9maWxlOmxldmVsOmJfZnJhbWVzXG4gICAgKiBAZXhhbXBsZVxuICAgICogdmNfWyA6cHJvZmlsZSA6IFtsZXZlbCA6IFtiX2ZyYW1lc11dXVxuICAgICogb3JcbiAgICAgIHsgY29kZWM6ICdoMjY0JywgcHJvZmlsZTogJ2Jhc2ljJywgbGV2ZWw6ICczLjEnLCBiX2ZyYW1lczogZmFsc2UgfVxuICAgICogQGlnbm9yZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInByb2Nlc3NfdmlkZW9fcGFyYW1zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NfdmlkZW9fcGFyYW1zKHBhcmFtKSB7XG4gICAgICB2YXIgdmlkZW87XG4gICAgICBzd2l0Y2ggKHBhcmFtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNhc2UgT2JqZWN0OlxuICAgICAgICAgIHZpZGVvID0gXCJcIjtcbiAgICAgICAgICBpZiAoJ2NvZGVjJyBpbiBwYXJhbSkge1xuICAgICAgICAgICAgdmlkZW8gPSBwYXJhbS5jb2RlYztcbiAgICAgICAgICAgIGlmICgncHJvZmlsZScgaW4gcGFyYW0pIHtcbiAgICAgICAgICAgICAgdmlkZW8gKz0gXCI6XCIgKyBwYXJhbS5wcm9maWxlO1xuICAgICAgICAgICAgICBpZiAoJ2xldmVsJyBpbiBwYXJhbSkge1xuICAgICAgICAgICAgICAgIHZpZGVvICs9IFwiOlwiICsgcGFyYW0ubGV2ZWw7XG4gICAgICAgICAgICAgICAgaWYgKCdiX2ZyYW1lcycgaW4gcGFyYW0gJiYgcGFyYW0uYl9mcmFtZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICB2aWRlbyArPSBcIjpiZnJhbWVzX25vXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2aWRlbztcbiAgICAgICAgY2FzZSBTdHJpbmc6XG4gICAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xufSgpO1xudmFyIHBhcmFtZXRlcnNfQXJyYXlQYXJhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1BhcmFtKSB7XG4gIC8qKlxuICAgKiBBIHBhcmFtZXRlciB0aGF0IHJlcHJlc2VudHMgYW4gYXJyYXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciBpbiBzbmFrZV9jYXNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2hvcnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgcGFyYW1ldGVyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIElmIGEgdmFsdWUgaXMgbm90IHByb3ZpZGVkLCB0aGUgcGFyYW1ldGVyIHdpbGwgbm90IGJlIHNlcmlhbGl6ZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc2VwPScuJ10gLSBUaGUgc2VwYXJhdG9yIHRvIHVzZSB3aGVuIGpvaW5pbmcgdGhlIGFycmF5IGVsZW1lbnRzIHRvZ2V0aGVyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwcm9jZXNzPVV0aWwuaWRlbnRpdHkgXSAtIE1hbmlwdWxhdGUgb3JpZ1ZhbHVlIHdoZW4gdmFsdWUgaXMgY2FsbGVkXG4gICAqIEBjbGFzcyBBcnJheVBhcmFtXG4gICAqIEBleHRlbmRzIFBhcmFtXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIEFycmF5UGFyYW0obmFtZSwgc2hvcnROYW1lKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIHZhciBzZXAgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICcuJztcbiAgICB2YXIgcHJvY2VzcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICAgIHBhcmFtZXRlcnNfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXJyYXlQYXJhbSk7XG4gICAgX3RoaXMgPSBwYXJhbWV0ZXJzX2NhbGxTdXBlcih0aGlzLCBBcnJheVBhcmFtLCBbbmFtZSwgc2hvcnROYW1lLCBwcm9jZXNzXSk7XG4gICAgX3RoaXMuc2VwID0gc2VwO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBwYXJhbWV0ZXJzX2luaGVyaXRzKEFycmF5UGFyYW0sIF9QYXJhbSk7XG4gIHJldHVybiBwYXJhbWV0ZXJzX2NyZWF0ZUNsYXNzKEFycmF5UGFyYW0sIFt7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICBpZiAodGhpcy5zaG9ydE5hbWUgIT0gbnVsbCkge1xuICAgICAgICB2YXIgYXJyYXlWYWx1ZSA9IHRoaXMudmFsdWUoKTtcbiAgICAgICAgaWYgKGlzRW1wdHkoYXJyYXlWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkoYXJyYXlWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5zaG9ydE5hbWUsIFwiX1wiKS5jb25jYXQoYXJyYXlWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZsYXQgPSBhcnJheVZhbHVlLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKSh0LnNlcmlhbGl6ZSkgPyB0LnNlcmlhbGl6ZSgpIDogdDtcbiAgICAgICAgICB9KS5qb2luKHRoaXMuc2VwKTtcbiAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5zaG9ydE5hbWUsIFwiX1wiKS5jb25jYXQoZmxhdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIGlmIChpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkodGhpcy5vcmlnVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdWYWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLnByb2Nlc3Modik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzcyh0aGlzLm9yaWdWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQob3JpZ1ZhbHVlKSB7XG4gICAgICBpZiAob3JpZ1ZhbHVlID09IG51bGwgfHwgaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKG9yaWdWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlclByb3BHZXQoQXJyYXlQYXJhbSwgXCJzZXRcIiwgdGhpcywgMykoW29yaWdWYWx1ZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlclByb3BHZXQoQXJyYXlQYXJhbSwgXCJzZXRcIiwgdGhpcywgMykoW1tvcmlnVmFsdWVdXSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG59KHBhcmFtZXRlcnNfUGFyYW0pO1xudmFyIHBhcmFtZXRlcnNfVHJhbnNmb3JtYXRpb25QYXJhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1BhcmFtMikge1xuICAvKipcbiAgICogQSBwYXJhbWV0ZXIgdGhhdCByZXByZXNlbnRzIGEgdHJhbnNmb3JtYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyIGluIHNuYWtlX2Nhc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzaG9ydE5hbWU9J3QnXSAtIFRoZSBuYW1lIG9mIHRoZSBzZXJpYWxpemVkIGZvcm0gb2YgdGhlIHBhcmFtZXRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3NlcD0nLiddIC0gVGhlIHNlcGFyYXRvciB0byB1c2Ugd2hlbiBqb2luaW5nIHRoZSBhcnJheSBlbGVtZW50cyB0b2dldGhlclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcHJvY2Vzcz1VdGlsLmlkZW50aXR5IF0gLSBNYW5pcHVsYXRlIG9yaWdWYWx1ZSB3aGVuIHZhbHVlIGlzIGNhbGxlZFxuICAgKiBAY2xhc3MgVHJhbnNmb3JtYXRpb25QYXJhbVxuICAgKiBAZXh0ZW5kcyBQYXJhbVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvblBhcmFtKG5hbWUpIHtcbiAgICB2YXIgX3RoaXMzO1xuICAgIHZhciBzaG9ydE5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwidFwiO1xuICAgIHZhciBzZXAgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICcuJztcbiAgICB2YXIgcHJvY2VzcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICAgIHBhcmFtZXRlcnNfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhbnNmb3JtYXRpb25QYXJhbSk7XG4gICAgX3RoaXMzID0gcGFyYW1ldGVyc19jYWxsU3VwZXIodGhpcywgVHJhbnNmb3JtYXRpb25QYXJhbSwgW25hbWUsIHNob3J0TmFtZSwgcHJvY2Vzc10pO1xuICAgIF90aGlzMy5zZXAgPSBzZXA7XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBzdHJpbmcgcmVwcmVzZW50YXRpb25zIG9mIHRoZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgZWl0aGVyIHRoZSB0cmFuc2Zvcm1hdGlvbiBhcyBhIHN0cmluZywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5nIHJlcHJlc2VudGF0aW9ucy5cbiAgICovXG4gIHBhcmFtZXRlcnNfaW5oZXJpdHMoVHJhbnNmb3JtYXRpb25QYXJhbSwgX1BhcmFtMik7XG4gIHJldHVybiBwYXJhbWV0ZXJzX2NyZWF0ZUNsYXNzKFRyYW5zZm9ybWF0aW9uUGFyYW0sIFt7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgIHZhciB2YWwgPSB0aGlzLnZhbHVlKCk7XG4gICAgICBpZiAoaXNFbXB0eSh2YWwpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIC8vIHZhbCBpcyBhbiBhcnJheSBvZiBzdHJpbmdzIHNvIGpvaW4gdGhlbVxuICAgICAgaWYgKGJhc2V1dGlsX2FsbFN0cmluZ3ModmFsKSkge1xuICAgICAgICB2YXIgam9pbmVkID0gdmFsLmpvaW4odGhpcy5zZXApOyAvLyBjcmVhdGVzIHQxLnQyLnQzIGluIGNhc2UgbXVsdGlwbGUgbmFtZWQgdHJhbnNmb3JtYXRpb25zIHdlcmUgY29uZmlndXJlZFxuICAgICAgICBpZiAoIWlzRW1wdHkoam9pbmVkKSkge1xuICAgICAgICAgIC8vIGluIGNhc2Ugb3B0aW9ucy50cmFuc2Zvcm1hdGlvbiB3YXMgbm90IHNldCB3aXRoIGFuIGVtcHR5IHN0cmluZyAodmFsICE9IFsnJ10pO1xuICAgICAgICAgIHJlc3VsdCA9IFwiXCIuY29uY2F0KHRoaXMuc2hvcnROYW1lLCBcIl9cIikuY29uY2F0KGpvaW5lZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENvbnZlcnQgdmFsIHRvIGFuIGFycmF5IG9mIHN0cmluZ3NcbiAgICAgICAgcmVzdWx0ID0gdmFsLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGlmIChpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQoKSh0KSAmJiAhaXNFbXB0eSh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KF90aGlzNC5zaG9ydE5hbWUsIFwiX1wiKS5jb25jYXQodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkodC5zZXJpYWxpemUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdC5zZXJpYWxpemUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQoKSh0KSAmJiAhaXNFbXB0eSh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBzcmNfdHJhbnNmb3JtYXRpb24odCkuc2VyaWFsaXplKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQob3JpZ1ZhbHVlMSkge1xuICAgICAgdGhpcy5vcmlnVmFsdWUgPSBvcmlnVmFsdWUxO1xuICAgICAgaWYgKGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKSh0aGlzLm9yaWdWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlclByb3BHZXQoVHJhbnNmb3JtYXRpb25QYXJhbSwgXCJzZXRcIiwgdGhpcywgMykoW3RoaXMub3JpZ1ZhbHVlXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX3N1cGVyUHJvcEdldChUcmFuc2Zvcm1hdGlvblBhcmFtLCBcInNldFwiLCB0aGlzLCAzKShbW3RoaXMub3JpZ1ZhbHVlXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xufShwYXJhbWV0ZXJzX1BhcmFtKTtcbnZhciBudW1iZXJfcGF0dGVybiA9IFwiKFswLTldKilcXFxcLihbMC05XSspfChbMC05XSspXCI7XG52YXIgb2Zmc2V0X2FueV9wYXR0ZXJuID0gXCIoXCIgKyBudW1iZXJfcGF0dGVybiArIFwiKShbJXBQXSk/XCI7XG52YXIgcGFyYW1ldGVyc19SYW5nZVBhcmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUGFyYW0zKSB7XG4gIC8qKlxuICAgKiBBIHBhcmFtZXRlciB0aGF0IHJlcHJlc2VudHMgYSByYW5nZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIgaW4gc25ha2VfY2FzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2hvcnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgcGFyYW1ldGVyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIElmIGEgdmFsdWUgaXMgbm90IHByb3ZpZGVkLCB0aGUgcGFyYW1ldGVyIHdpbGwgbm90IGJlIHNlcmlhbGl6ZWQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwcm9jZXNzPW5vcm1fcmFuZ2VfdmFsdWUgXSAtIE1hbmlwdWxhdGUgb3JpZ1ZhbHVlIHdoZW4gdmFsdWUgaXMgY2FsbGVkXG4gICAqIEBjbGFzcyBSYW5nZVBhcmFtXG4gICAqIEBleHRlbmRzIFBhcmFtXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIFJhbmdlUGFyYW0obmFtZSwgc2hvcnROYW1lKSB7XG4gICAgdmFyIHByb2Nlc3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFJhbmdlUGFyYW0ubm9ybV9yYW5nZV92YWx1ZTtcbiAgICBwYXJhbWV0ZXJzX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhbmdlUGFyYW0pO1xuICAgIHJldHVybiBwYXJhbWV0ZXJzX2NhbGxTdXBlcih0aGlzLCBSYW5nZVBhcmFtLCBbbmFtZSwgc2hvcnROYW1lLCBwcm9jZXNzXSk7XG4gIH1cbiAgcGFyYW1ldGVyc19pbmhlcml0cyhSYW5nZVBhcmFtLCBfUGFyYW0zKTtcbiAgcmV0dXJuIHBhcmFtZXRlcnNfY3JlYXRlQ2xhc3MoUmFuZ2VQYXJhbSwgbnVsbCwgW3tcbiAgICBrZXk6IFwibm9ybV9yYW5nZV92YWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3JtX3JhbmdlX3ZhbHVlKHZhbHVlKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gU3RyaW5nKHZhbHVlKS5tYXRjaChuZXcgUmVnRXhwKCdeJyArIG9mZnNldF9hbnlfcGF0dGVybiArICckJykpO1xuICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICB2YXIgbW9kaWZpZXIgPSBvZmZzZXRbNV0gIT0gbnVsbCA/ICdwJyA6ICcnO1xuICAgICAgICB2YWx1ZSA9IChvZmZzZXRbMV0gfHwgb2Zmc2V0WzRdKSArIG1vZGlmaWVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4cHJlc3Npb24ubm9ybWFsaXplKHZhbHVlKTtcbiAgICB9XG4gIH1dKTtcbn0ocGFyYW1ldGVyc19QYXJhbSk7XG52YXIgcGFyYW1ldGVyc19SYXdQYXJhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1BhcmFtNCkge1xuICBmdW5jdGlvbiBSYXdQYXJhbShuYW1lLCBzaG9ydE5hbWUpIHtcbiAgICB2YXIgcHJvY2VzcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogaWRlbnRpdHlfcm9vdF9pZGVudGl0eV9kZWZhdWx0LmE7XG4gICAgcGFyYW1ldGVyc19jbGFzc0NhbGxDaGVjayh0aGlzLCBSYXdQYXJhbSk7XG4gICAgcmV0dXJuIHBhcmFtZXRlcnNfY2FsbFN1cGVyKHRoaXMsIFJhd1BhcmFtLCBbbmFtZSwgc2hvcnROYW1lLCBwcm9jZXNzXSk7XG4gIH1cbiAgcGFyYW1ldGVyc19pbmhlcml0cyhSYXdQYXJhbSwgX1BhcmFtNCk7XG4gIHJldHVybiBwYXJhbWV0ZXJzX2NyZWF0ZUNsYXNzKFJhd1BhcmFtLCBbe1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUoKTtcbiAgICB9XG4gIH1dKTtcbn0ocGFyYW1ldGVyc19QYXJhbSk7XG52YXIgcGFyYW1ldGVyc19MYXllclBhcmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUGFyYW01KSB7XG4gIGZ1bmN0aW9uIExheWVyUGFyYW0oKSB7XG4gICAgcGFyYW1ldGVyc19jbGFzc0NhbGxDaGVjayh0aGlzLCBMYXllclBhcmFtKTtcbiAgICByZXR1cm4gcGFyYW1ldGVyc19jYWxsU3VwZXIodGhpcywgTGF5ZXJQYXJhbSwgYXJndW1lbnRzKTtcbiAgfVxuICBwYXJhbWV0ZXJzX2luaGVyaXRzKExheWVyUGFyYW0sIF9QYXJhbTUpO1xuICByZXR1cm4gcGFyYW1ldGVyc19jcmVhdGVDbGFzcyhMYXllclBhcmFtLCBbe1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIHZhbHVlOlxuICAgIC8vIFBhcnNlIGxheWVyIG9wdGlvbnNcbiAgICAvLyBAcmV0dXJuIFtzdHJpbmddIGxheWVyIHRyYW5zZm9ybWF0aW9uIHN0cmluZ1xuICAgIC8vIEBwcml2YXRlXG4gICAgZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICBpZiAodGhpcy5vcmlnVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgaWYgKHRoaXMub3JpZ1ZhbHVlIGluc3RhbmNlb2YgbGF5ZXJfbGF5ZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5vcmlnVmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQoKSh0aGlzLm9yaWdWYWx1ZSkpIHtcbiAgICAgICAgdmFyIGxheWVyT3B0aW9ucyA9IHdpdGhDYW1lbENhc2VLZXlzKHRoaXMub3JpZ1ZhbHVlKTtcbiAgICAgICAgaWYgKGxheWVyT3B0aW9ucy5yZXNvdXJjZVR5cGUgPT09IFwidGV4dFwiIHx8IGxheWVyT3B0aW9ucy50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQgPSBuZXcgdGV4dGxheWVyKGxheWVyT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAobGF5ZXJPcHRpb25zLnJlc291cmNlVHlwZSA9PT0gXCJzdWJ0aXRsZXNcIikge1xuICAgICAgICAgIHJlc3VsdCA9IG5ldyBzdWJ0aXRsZXNsYXllcihsYXllck9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKGxheWVyT3B0aW9ucy5yZXNvdXJjZVR5cGUgPT09IFwiZmV0Y2hcIiB8fCBsYXllck9wdGlvbnMudXJsICE9IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQgPSBuZXcgZmV0Y2hsYXllcihsYXllck9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IG5ldyBsYXllcl9sYXllcihsYXllck9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKHRoaXMub3JpZ1ZhbHVlKSkge1xuICAgICAgICBpZiAoL15mZXRjaDouKy8udGVzdCh0aGlzLm9yaWdWYWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQgPSBuZXcgZmV0Y2hsYXllcih0aGlzLm9yaWdWYWx1ZS5zdWJzdHIoNikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IHRoaXMub3JpZ1ZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJ0ZXh0U3R5bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGV4dFN0eWxlKGxheWVyKSB7XG4gICAgICByZXR1cm4gbmV3IHRleHRsYXllcihsYXllcikudGV4dFN0eWxlSWRlbnRpZmllcigpO1xuICAgIH1cbiAgfV0pO1xufShwYXJhbWV0ZXJzX1BhcmFtKTtcbnZhciBwYXJhbWV0ZXJzX0V4cHJlc3Npb25QYXJhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1BhcmFtNikge1xuICBmdW5jdGlvbiBFeHByZXNzaW9uUGFyYW0oKSB7XG4gICAgcGFyYW1ldGVyc19jbGFzc0NhbGxDaGVjayh0aGlzLCBFeHByZXNzaW9uUGFyYW0pO1xuICAgIHJldHVybiBwYXJhbWV0ZXJzX2NhbGxTdXBlcih0aGlzLCBFeHByZXNzaW9uUGFyYW0sIGFyZ3VtZW50cyk7XG4gIH1cbiAgcGFyYW1ldGVyc19pbmhlcml0cyhFeHByZXNzaW9uUGFyYW0sIF9QYXJhbTYpO1xuICByZXR1cm4gcGFyYW1ldGVyc19jcmVhdGVDbGFzcyhFeHByZXNzaW9uUGFyYW0sIFt7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICByZXR1cm4gZXhwcmVzc2lvbi5ub3JtYWxpemUoX3N1cGVyUHJvcEdldChFeHByZXNzaW9uUGFyYW0sIFwic2VyaWFsaXplXCIsIHRoaXMsIDMpKFtdKSk7XG4gICAgfVxuICB9XSk7XG59KHBhcmFtZXRlcnNfUGFyYW0pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy90cmFuc2Zvcm1hdGlvbi5qc1xuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSB0cmFuc2Zvcm1hdGlvbl9nZXRQcm90b3R5cGVPZihvKSwgdHJhbnNmb3JtYXRpb25fcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCB0cmFuc2Zvcm1hdGlvbl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIHRyYW5zZm9ybWF0aW9uX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIGUpIHsgaWYgKGUgJiYgKFwib2JqZWN0XCIgPT0gdHJhbnNmb3JtYXRpb25fdHlwZW9mKGUpIHx8IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSkpIHJldHVybiBlOyBpZiAodm9pZCAwICE9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IHJldHVybiB0cmFuc2Zvcm1hdGlvbl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQodCk7IH1cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX2Fzc2VydFRoaXNJbml0aWFsaXplZChlKSB7IGlmICh2b2lkIDAgPT09IGUpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKHRyYW5zZm9ybWF0aW9uX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX2dldFByb3RvdHlwZU9mKHQpIHsgcmV0dXJuIHRyYW5zZm9ybWF0aW9uX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7IH0sIHRyYW5zZm9ybWF0aW9uX2dldFByb3RvdHlwZU9mKHQpOyB9XG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9pbmhlcml0cyh0LCBlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUgJiYgbnVsbCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogdCwgd3JpdGFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0gfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZSAmJiB0cmFuc2Zvcm1hdGlvbl9zZXRQcm90b3R5cGVPZih0LCBlKTsgfVxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fc2V0UHJvdG90eXBlT2YodCwgZSkgeyByZXR1cm4gdHJhbnNmb3JtYXRpb25fc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQsIGUpIHsgcmV0dXJuIHQuX19wcm90b19fID0gZSwgdDsgfSwgdHJhbnNmb3JtYXRpb25fc2V0UHJvdG90eXBlT2YodCwgZSk7IH1cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX3NsaWNlZFRvQXJyYXkociwgZSkgeyByZXR1cm4gdHJhbnNmb3JtYXRpb25fYXJyYXlXaXRoSG9sZXMocikgfHwgdHJhbnNmb3JtYXRpb25faXRlcmFibGVUb0FycmF5TGltaXQociwgZSkgfHwgdHJhbnNmb3JtYXRpb25fdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgZSkgfHwgdHJhbnNmb3JtYXRpb25fbm9uSXRlcmFibGVSZXN0KCk7IH1cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgYSkgeyBpZiAocikgeyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIHRyYW5zZm9ybWF0aW9uX2FycmF5TGlrZVRvQXJyYXkociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IHRyYW5zZm9ybWF0aW9uX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7IH0gfVxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7IChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTsgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07IHJldHVybiBuOyB9XG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fYXJyYXlXaXRoSG9sZXMocikgeyBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIHI7IH1cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIHRyYW5zZm9ybWF0aW9uX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCB0cmFuc2Zvcm1hdGlvbl90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHRyYW5zZm9ybWF0aW9uX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTsgfSB9XG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIHRyYW5zZm9ybWF0aW9uX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIHRyYW5zZm9ybWF0aW9uX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTsgfVxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gdHJhbnNmb3JtYXRpb25fdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IHRyYW5zZm9ybWF0aW9uX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSB0cmFuc2Zvcm1hdGlvbl90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gdHJhbnNmb3JtYXRpb25fdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cblxuXG5cblxuXG5cblxuLyoqXG4gKiBBc3NpZ24ga2V5LCB2YWx1ZSB0byB0YXJnZXQsIHdoZW4gdmFsdWUgaXMgbm90IG51bGwuPGJyPlxuICogICBUaGlzIGZ1bmN0aW9uIG11dGF0ZXMgdGhlIHRhcmdldCFcbiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgdGhlIG9iamVjdCB0byBhc3NpZ24gdGhlIHZhbHVlcyB0b1xuICogQHBhcmFtIHtvYmplY3R9IHNvdXJjZXMgb25lIG9yIG1vcmUgb2JqZWN0cyB0byBnZXQgdmFsdWVzIGZyb21cbiAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSB0YXJnZXQgYWZ0ZXIgdGhlIGFzc2lnbm1lbnRcbiAqL1xuZnVuY3Rpb24gYXNzaWduTm90TnVsbCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNvdXJjZXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHNvdXJjZXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChzb3VyY2Vba2V5XSAhPSBudWxsKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybWF0aW9uQmFzZVxuICogRGVwZW5kcyBvbiAnY29uZmlndXJhdGlvbicsICdwYXJhbWV0ZXJzJywndXRpbCdcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgdHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb25CYXNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIFRoZSBiYXNlIGNsYXNzIGZvciB0cmFuc2Zvcm1hdGlvbnMuXG4gICAqIE1lbWJlcnMgb2YgdGhpcyBjbGFzcyBhcmUgZG9jdW1lbnRlZCBhcyBiZWxvbmdpbmcgdG8gdGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gY2xhc3MgZm9yIGNvbnZlbmllbmNlLlxuICAgKiBAY2xhc3MgVHJhbnNmb3JtYXRpb25CYXNlXG4gICAqL1xuICBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbkJhc2Uob3B0aW9ucykge1xuICAgIHRyYW5zZm9ybWF0aW9uX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zZm9ybWF0aW9uQmFzZSk7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdmFyIHBhcmVudCwgdHJhbnM7XG4gICAgcGFyZW50ID0gdm9pZCAwO1xuICAgIHRyYW5zID0ge307XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIG9wdGlvbnMgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGFuIGlkZW50aWNhbCBUcmFuc2Zvcm1hdGlvblxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiN0b09wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYSBwbGFpbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoaXMgdHJhbnNmb3JtYXRpb25cbiAgICAgKi9cbiAgICB0aGlzLnRvT3B0aW9ucyA9IGZ1bmN0aW9uICh3aXRoQ2hhaW4pIHtcbiAgICAgIHZhciBvcHQgPSB7fTtcbiAgICAgIGlmICh3aXRoQ2hhaW4gPT0gbnVsbCkge1xuICAgICAgICB3aXRoQ2hhaW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmtleXModHJhbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gb3B0W2tleV0gPSB0cmFuc1trZXldLm9yaWdWYWx1ZTtcbiAgICAgIH0pO1xuICAgICAgYXNzaWduTm90TnVsbChvcHQsIHRoaXMub3RoZXJPcHRpb25zKTtcbiAgICAgIGlmICh3aXRoQ2hhaW4gJiYgIWlzRW1wdHkodGhpcy5jaGFpbmVkKSkge1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuY2hhaW5lZC5tYXAoZnVuY3Rpb24gKHRyKSB7XG4gICAgICAgICAgcmV0dXJuIHRyLnRvT3B0aW9ucygpO1xuICAgICAgICB9KTtcbiAgICAgICAgbGlzdC5wdXNoKG9wdCk7XG4gICAgICAgIG9wdCA9IHt9O1xuICAgICAgICBhc3NpZ25Ob3ROdWxsKG9wdCwgdGhpcy5vdGhlck9wdGlvbnMpO1xuICAgICAgICBvcHQudHJhbnNmb3JtYXRpb24gPSBsaXN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBhIHBhcmVudCBmb3IgdGhpcyBvYmplY3QgZm9yIGNoYWluaW5nIHB1cnBvc2VzLlxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uI3NldFBhcmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSB0aGUgcGFyZW50IHRvIGJlIGFzc2lnbmVkIHRvXG4gICAgICogQHJldHVybnMge1RyYW5zZm9ybWF0aW9ufSBSZXR1cm5zIHRoaXMgaW5zdGFuY2UgZm9yIGNoYWluaW5nIHB1cnBvc2VzLlxuICAgICAqL1xuICAgIHRoaXMuc2V0UGFyZW50ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgcGFyZW50ID0gb2JqZWN0O1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZnJvbU9wdGlvbnModHlwZW9mIG9iamVjdC50b09wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiA/IG9iamVjdC50b09wdGlvbnMoKSA6IHZvaWQgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBhcmVudCBvZiB0aGlzIG9iamVjdCBpbiB0aGUgY2hhaW5cbiAgICAgKiBAZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24jZ2V0UGFyZW50XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgcGFyZW50IG9mIHRoaXMgb2JqZWN0IGlmIHRoZXJlIGlzIGFueVxuICAgICAqL1xuICAgIHRoaXMuZ2V0UGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9O1xuXG4gICAgLy8gSGVscGVyIG1ldGhvZHMgdG8gY3JlYXRlIHBhcmFtZXRlciBtZXRob2RzXG4gICAgLy8gVGhlc2UgbWV0aG9kcyBhcmUgZGVmaW5lZCBoZXJlIGJlY2F1c2UgdGhleSBhY2Nlc3MgYHRyYW5zYCB3aGljaCBpc1xuICAgIC8vIGEgcHJpdmF0ZSBtZW1iZXIgb2YgYFRyYW5zZm9ybWF0aW9uQmFzZWBcblxuICAgIC8qKiBAcHJvdGVjdGVkICovXG4gICAgdGhpcy5wYXJhbSA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgYWJiciwgZGVmYXVsdFZhbHVlLCBwcm9jZXNzKSB7XG4gICAgICBpZiAocHJvY2VzcyA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZGVmYXVsdFZhbHVlKSkge1xuICAgICAgICAgIHByb2Nlc3MgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvY2VzcyA9IGlkZW50aXR5X3Jvb3RfaWRlbnRpdHlfZGVmYXVsdC5hO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cmFuc1tuYW1lXSA9IG5ldyBwYXJhbWV0ZXJzX1BhcmFtKG5hbWUsIGFiYnIsIHByb2Nlc3MpLnNldCh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBAcHJvdGVjdGVkICovXG4gICAgdGhpcy5yYXdQYXJhbSA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgYWJiciwgZGVmYXVsdFZhbHVlLCBwcm9jZXNzKSB7XG4gICAgICBwcm9jZXNzID0gbGFzdEFyZ0NhbGxiYWNrKGFyZ3VtZW50cyk7XG4gICAgICB0cmFuc1tuYW1lXSA9IG5ldyBwYXJhbWV0ZXJzX1Jhd1BhcmFtKG5hbWUsIGFiYnIsIHByb2Nlc3MpLnNldCh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBAcHJvdGVjdGVkICovXG4gICAgdGhpcy5yYW5nZVBhcmFtID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lLCBhYmJyLCBkZWZhdWx0VmFsdWUsIHByb2Nlc3MpIHtcbiAgICAgIHByb2Nlc3MgPSBsYXN0QXJnQ2FsbGJhY2soYXJndW1lbnRzKTtcbiAgICAgIHRyYW5zW25hbWVdID0gbmV3IHBhcmFtZXRlcnNfUmFuZ2VQYXJhbShuYW1lLCBhYmJyLCBwcm9jZXNzKS5zZXQodmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogQHByb3RlY3RlZCAqL1xuICAgIHRoaXMuYXJyYXlQYXJhbSA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgYWJicikge1xuICAgICAgdmFyIHNlcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogXCI6XCI7XG4gICAgICB2YXIgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBbXTtcbiAgICAgIHZhciBwcm9jZXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB1bmRlZmluZWQ7XG4gICAgICBwcm9jZXNzID0gbGFzdEFyZ0NhbGxiYWNrKGFyZ3VtZW50cyk7XG4gICAgICB0cmFuc1tuYW1lXSA9IG5ldyBwYXJhbWV0ZXJzX0FycmF5UGFyYW0obmFtZSwgYWJiciwgc2VwLCBwcm9jZXNzKS5zZXQodmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogQHByb3RlY3RlZCAqL1xuICAgIHRoaXMudHJhbnNmb3JtYXRpb25QYXJhbSA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgYWJicikge1xuICAgICAgdmFyIHNlcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogXCIuXCI7XG4gICAgICB2YXIgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgcHJvY2VzcyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogdW5kZWZpbmVkO1xuICAgICAgcHJvY2VzcyA9IGxhc3RBcmdDYWxsYmFjayhhcmd1bWVudHMpO1xuICAgICAgdHJhbnNbbmFtZV0gPSBuZXcgcGFyYW1ldGVyc19UcmFuc2Zvcm1hdGlvblBhcmFtKG5hbWUsIGFiYnIsIHNlcCwgcHJvY2Vzcykuc2V0KHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgdGhpcy5sYXllclBhcmFtID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lLCBhYmJyKSB7XG4gICAgICB0cmFuc1tuYW1lXSA9IG5ldyBwYXJhbWV0ZXJzX0xheWVyUGFyYW0obmFtZSwgYWJicikuc2V0KHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvLyBFbmQgSGVscGVyIG1ldGhvZHNcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiNnZXRWYWx1ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlclxuICAgICAqIEByZXR1cm4geyp9IHRoZSBwcm9jZXNzZWQgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAgICogQGRlc2NyaXB0aW9uIFVzZSB7QGxpbmsgZ2V0fS5vcmlnVmFsdWUgZm9yIHRoZSB2YWx1ZSBvcmlnaW5hbGx5IHByb3ZpZGVkIGZvciB0aGUgcGFyYW1ldGVyXG4gICAgICovXG4gICAgdGhpcy5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0cmFuc1tuYW1lXSAmJiB0cmFuc1tuYW1lXS52YWx1ZSgpO1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHRoaXMub3RoZXJPcHRpb25zW25hbWVdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwYXJhbWV0ZXIgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVyIG5hbWVcbiAgICAgKiBAZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24jZ2V0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIHRyYW5zZm9ybWF0aW9uIHBhcmFtZXRlclxuICAgICAqIEByZXR1cm5zIHtQYXJhbX0gdGhlIHBhcmFtIG9iamVjdCBmb3IgdGhlIGdpdmVuIG5hbWUsIG9yIHVuZGVmaW5lZFxuICAgICAqL1xuICAgIHRoaXMuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiB0cmFuc1tuYW1lXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHRyYW5zZm9ybWF0aW9uIG9wdGlvbiBmcm9tIHRoZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgKiBAZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24jcmVtb3ZlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgb3B0aW9uIHRvIHJlbW92ZVxuICAgICAqIEByZXR1cm4geyp9IFJldHVybnMgdGhlIG9wdGlvbiB0aGF0IHdhcyByZW1vdmVkIG9yIG51bGwgaWYgbm8gb3B0aW9uIGJ5IHRoYXQgbmFtZSB3YXMgZm91bmQuIFRoZSB0eXBlIG9mIHRoZVxuICAgICAqICAgICAgICAgICAgICByZXR1cm5lZCB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB2YWx1ZS5cbiAgICAgKi9cbiAgICB0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgdGVtcDtcbiAgICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgICAgY2FzZSB0cmFuc1tuYW1lXSA9PSBudWxsOlxuICAgICAgICAgIHRlbXAgPSB0cmFuc1tuYW1lXTtcbiAgICAgICAgICBkZWxldGUgdHJhbnNbbmFtZV07XG4gICAgICAgICAgcmV0dXJuIHRlbXAub3JpZ1ZhbHVlO1xuICAgICAgICBjYXNlIHRoaXMub3RoZXJPcHRpb25zW25hbWVdID09IG51bGw6XG4gICAgICAgICAgdGVtcCA9IHRoaXMub3RoZXJPcHRpb25zW25hbWVdO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLm90aGVyT3B0aW9uc1tuYW1lXTtcbiAgICAgICAgICByZXR1cm4gdGVtcDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiBhbGwgdGhlIGtleXMgKG9wdGlvbiBuYW1lcykgaW4gdGhlIHRyYW5zZm9ybWF0aW9uLlxuICAgICAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59IHRoZSBrZXlzIGluIHNuYWtlQ2FzZSBmb3JtYXRcbiAgICAgKi9cbiAgICB0aGlzLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIga2V5O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdHM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChrZXkgaW4gdHJhbnMpIHtcbiAgICAgICAgICBpZiAoa2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChrZXkubWF0Y2goVkFSX05BTUVfUkUpID8ga2V5IDogc25ha2VDYXNlKGtleSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH0oKS5zb3J0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0cmFuc2Zvcm1hdGlvbi4gVmFsdWVzIGFyZSBwcm9jZXNzZWQuXG4gICAgICogQGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uI3RvUGxhaW5PYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSB0cmFuc2Zvcm1hdGlvbiBvcHRpb25zIGFzIHBsYWluIG9iamVjdFxuICAgICAqL1xuICAgIHRoaXMudG9QbGFpbk9iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBoYXNoLCBrZXksIGxpc3Q7XG4gICAgICBoYXNoID0ge307XG4gICAgICBmb3IgKGtleSBpbiB0cmFucykge1xuICAgICAgICBoYXNoW2tleV0gPSB0cmFuc1trZXldLnZhbHVlKCk7XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkoaGFzaFtrZXldKSkge1xuICAgICAgICAgIGhhc2hba2V5XSA9IGNsb25lRGVlcF9yb290X2Nsb25lRGVlcF9kZWZhdWx0KCkoaGFzaFtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpc0VtcHR5KHRoaXMuY2hhaW5lZCkpIHtcbiAgICAgICAgbGlzdCA9IHRoaXMuY2hhaW5lZC5tYXAoZnVuY3Rpb24gKHRyKSB7XG4gICAgICAgICAgcmV0dXJuIHRyLnRvUGxhaW5PYmplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxpc3QucHVzaChoYXNoKTtcbiAgICAgICAgaGFzaCA9IHtcbiAgICAgICAgICB0cmFuc2Zvcm1hdGlvbjogbGlzdFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wbGV0ZSB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBhbmQgY2hhaW4gdG8gYSBuZXcgb25lLlxuICAgICAqIEluIHRoZSBVUkwsIHRyYW5zZm9ybWF0aW9ucyBhcmUgY2hhaW5lZCB0b2dldGhlciBieSBzbGFzaGVzLlxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiNjaGFpblxuICAgICAqIEByZXR1cm4ge1RyYW5zZm9ybWF0aW9ufSBSZXR1cm5zIHRoaXMgdHJhbnNmb3JtYXRpb24gZm9yIGNoYWluaW5nXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgdHIgPSBjbG91ZGluYXJ5LlRyYW5zZm9ybWF0aW9uLm5ldygpO1xuICAgICAqIHRyLndpZHRoKDEwKS5jcm9wKCdmaXQnKS5jaGFpbigpLmFuZ2xlKDE1KS5zZXJpYWxpemUoKVxuICAgICAqIC8vIHByb2R1Y2VzIFwiY19maXQsd18xMC9hXzE1XCJcbiAgICAgKi9cbiAgICB0aGlzLmNoYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5hbWVzLCB0cjtcbiAgICAgIG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModHJhbnMpO1xuICAgICAgaWYgKG5hbWVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICB0ciA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMudG9PcHRpb25zKGZhbHNlKSk7XG4gICAgICAgIHRoaXMucmVzZXRUcmFuc2Zvcm1hdGlvbnMoKTtcbiAgICAgICAgdGhpcy5jaGFpbmVkLnB1c2godHIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICB0aGlzLnJlc2V0VHJhbnNmb3JtYXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgdHJhbnMgPSB7fTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgdGhpcy5vdGhlck9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmNoYWluZWQgPSBbXTtcbiAgICB0aGlzLmZyb21PcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIHRoZSBwcm92aWRlZCBvcHRpb25zIHdpdGggb3duJ3Mgb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIGtleS12YWx1ZSBsaXN0IG9mIG9wdGlvbnNcbiAgICogQHJldHVybnMge1RyYW5zZm9ybWF0aW9ufSBSZXR1cm5zIHRoaXMgaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAqL1xuICByZXR1cm4gdHJhbnNmb3JtYXRpb25fY3JlYXRlQ2xhc3MoVHJhbnNmb3JtYXRpb25CYXNlLCBbe1xuICAgIGtleTogXCJmcm9tT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tT3B0aW9ucygpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIGlmIChvcHRpb25zIGluc3RhbmNlb2YgVHJhbnNmb3JtYXRpb25CYXNlKSB7XG4gICAgICAgIHRoaXMuZnJvbVRyYW5zZm9ybWF0aW9uKG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKG9wdGlvbnMpIHx8IGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKShvcHRpb25zKSkge1xuICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbjogb3B0aW9uc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IGNsb25lRGVlcF9yb290X2Nsb25lRGVlcF9kZWZhdWx0KCkob3B0aW9ucywgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVHJhbnNmb3JtYXRpb25CYXNlIHx8IHZhbHVlIGluc3RhbmNlb2YgTGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdmFsdWUuY2xvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBIYW5kbGluZyBvZiBcImlmXCIgc3RhdGVtZW50cyBwcmVjZWRlcyBvdGhlciBvcHRpb25zIGFzIGl0IGNyZWF0ZXMgYSBjaGFpbmVkIHRyYW5zZm9ybWF0aW9uXG4gICAgICAgIGlmIChvcHRpb25zW1wiaWZcIl0pIHtcbiAgICAgICAgICB0aGlzLnNldChcImlmXCIsIG9wdGlvbnNbXCJpZlwiXSk7XG4gICAgICAgICAgZGVsZXRlIG9wdGlvbnNbXCJpZlwiXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgIHZhciBvcHQgPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgaWYgKG9wdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoa2V5Lm1hdGNoKFZBUl9OQU1FX1JFKSkge1xuICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnJGF0dHInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoJ3ZhcmlhYmxlJywga2V5LCBvcHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnNldChrZXksIG9wdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbVRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21UcmFuc2Zvcm1hdGlvbihvdGhlcikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFRyYW5zZm9ybWF0aW9uQmFzZSkge1xuICAgICAgICBvdGhlci5rZXlzKCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnNldChrZXksIG90aGVyLmdldChrZXkpLm9yaWdWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGEgcGFyYW1ldGVyLlxuICAgICAqIFRoZSBwYXJhbWV0ZXIgbmFtZSBga2V5YCBpcyBjb252ZXJ0ZWQgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVzIC0gdGhlIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNmb3JtYXRpb259IFJldHVybnMgdGhpcyBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGtleSkge1xuICAgICAgdmFyIGNhbWVsS2V5O1xuICAgICAgY2FtZWxLZXkgPSBjYW1lbENhc2Uoa2V5KTtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgdmFsdWVzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuICAgICAgaWYgKGluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfZGVmYXVsdCgpKHRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uLm1ldGhvZHMsIGNhbWVsS2V5KSkge1xuICAgICAgICB0aGlzW2NhbWVsS2V5XS5hcHBseSh0aGlzLCB2YWx1ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vdGhlck9wdGlvbnNba2V5XSA9IHZhbHVlc1swXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNMYXllclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNMYXllcigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlKFwib3ZlcmxheVwiKSB8fCB0aGlzLmdldFZhbHVlKFwidW5kZXJsYXlcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyYW5zZm9ybWF0aW9uLlxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiNzZXJpYWxpemVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyYW5zZm9ybWF0aW9uIGFzIGEgc3RyaW5nXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHZhciBpZlBhcmFtLCBqLCBsZW4sIHBhcmFtTGlzdCwgcmVmLCByZWYxLCByZWYyLCByZWYzLCByZWY0LCByZXN1bHRBcnJheSwgdCwgdHJhbnNmb3JtYXRpb25MaXN0LCB0cmFuc2Zvcm1hdGlvblN0cmluZywgdHJhbnNmb3JtYXRpb25zLCB2YWx1ZSwgdmFyaWFibGVzLCB2YXJzO1xuICAgICAgcmVzdWx0QXJyYXkgPSB0aGlzLmNoYWluZWQubWFwKGZ1bmN0aW9uICh0cikge1xuICAgICAgICByZXR1cm4gdHIuc2VyaWFsaXplKCk7XG4gICAgICB9KTtcbiAgICAgIHBhcmFtTGlzdCA9IHRoaXMua2V5cygpO1xuICAgICAgdHJhbnNmb3JtYXRpb25zID0gKHJlZiA9IHRoaXMuZ2V0KFwidHJhbnNmb3JtYXRpb25cIikpICE9IG51bGwgPyByZWYuc2VyaWFsaXplKCkgOiB2b2lkIDA7XG4gICAgICBpZlBhcmFtID0gKHJlZjEgPSB0aGlzLmdldChcImlmXCIpKSAhPSBudWxsID8gcmVmMS5zZXJpYWxpemUoKSA6IHZvaWQgMDtcbiAgICAgIHZhcmlhYmxlcyA9IHByb2Nlc3NWYXIoKHJlZjIgPSB0aGlzLmdldChcInZhcmlhYmxlc1wiKSkgIT0gbnVsbCA/IHJlZjIudmFsdWUoKSA6IHZvaWQgMCk7XG4gICAgICBwYXJhbUxpc3QgPSBkaWZmZXJlbmNlX3Jvb3RfZGlmZmVyZW5jZV9kZWZhdWx0KCkocGFyYW1MaXN0LCBbXCJ0cmFuc2Zvcm1hdGlvblwiLCBcImlmXCIsIFwidmFyaWFibGVzXCJdKTtcbiAgICAgIHZhcnMgPSBbXTtcbiAgICAgIHRyYW5zZm9ybWF0aW9uTGlzdCA9IFtdO1xuICAgICAgZm9yIChqID0gMCwgbGVuID0gcGFyYW1MaXN0Lmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIHQgPSBwYXJhbUxpc3Rbal07XG4gICAgICAgIGlmICh0Lm1hdGNoKFZBUl9OQU1FX1JFKSkge1xuICAgICAgICAgIHZhcnMucHVzaCh0ICsgXCJfXCIgKyBleHByZXNzaW9uLm5vcm1hbGl6ZSgocmVmMyA9IHRoaXMuZ2V0KHQpKSAhPSBudWxsID8gcmVmMy52YWx1ZSgpIDogdm9pZCAwKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJhbnNmb3JtYXRpb25MaXN0LnB1c2goKHJlZjQgPSB0aGlzLmdldCh0KSkgIT0gbnVsbCA/IHJlZjQuc2VyaWFsaXplKCkgOiB2b2lkIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgIGNhc2UgIWlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKHRyYW5zZm9ybWF0aW9ucyk6XG4gICAgICAgICAgdHJhbnNmb3JtYXRpb25MaXN0LnB1c2godHJhbnNmb3JtYXRpb25zKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAhaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHRyYW5zZm9ybWF0aW9ucyk6XG4gICAgICAgICAgcmVzdWx0QXJyYXkgPSByZXN1bHRBcnJheS5jb25jYXQodHJhbnNmb3JtYXRpb25zKTtcbiAgICAgIH1cbiAgICAgIHRyYW5zZm9ybWF0aW9uTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGssIGxlbjEsIHJlc3VsdHM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChrID0gMCwgbGVuMSA9IHRyYW5zZm9ybWF0aW9uTGlzdC5sZW5ndGg7IGsgPCBsZW4xOyBrKyspIHtcbiAgICAgICAgICB2YWx1ZSA9IHRyYW5zZm9ybWF0aW9uTGlzdFtrXTtcbiAgICAgICAgICBpZiAoaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHZhbHVlKSAmJiAhaXNFbXB0eSh2YWx1ZSkgfHwgIWlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKSh2YWx1ZSkgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfSgpO1xuICAgICAgdHJhbnNmb3JtYXRpb25MaXN0ID0gdmFycy5zb3J0KCkuY29uY2F0KHZhcmlhYmxlcykuY29uY2F0KHRyYW5zZm9ybWF0aW9uTGlzdC5zb3J0KCkpO1xuICAgICAgaWYgKGlmUGFyYW0gPT09IFwiaWZfZW5kXCIpIHtcbiAgICAgICAgdHJhbnNmb3JtYXRpb25MaXN0LnB1c2goaWZQYXJhbSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VtcHR5KGlmUGFyYW0pKSB7XG4gICAgICAgIHRyYW5zZm9ybWF0aW9uTGlzdC51bnNoaWZ0KGlmUGFyYW0pO1xuICAgICAgfVxuICAgICAgdHJhbnNmb3JtYXRpb25TdHJpbmcgPSBjb21wYWN0X3Jvb3RfY29tcGFjdF9kZWZhdWx0KCkodHJhbnNmb3JtYXRpb25MaXN0KS5qb2luKHRoaXMucGFyYW1fc2VwYXJhdG9yKTtcbiAgICAgIGlmICghaXNFbXB0eSh0cmFuc2Zvcm1hdGlvblN0cmluZykpIHtcbiAgICAgICAgcmVzdWx0QXJyYXkucHVzaCh0cmFuc2Zvcm1hdGlvblN0cmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tcGFjdF9yb290X2NvbXBhY3RfZGVmYXVsdCgpKHJlc3VsdEFycmF5KS5qb2luKHRoaXMudHJhbnNfc2VwYXJhdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlIGEgbGlzdCBvZiBhbGwgdGhlIHZhbGlkIHRyYW5zZm9ybWF0aW9uIG9wdGlvbiBuYW1lc1xuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiNsaXN0TmFtZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59IGEgYXJyYXkgb2YgYWxsIHRoZSB2YWxpZCBvcHRpb24gbmFtZXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ0b0h0bWxBdHRyaWJ1dGVzXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYXR0cmlidXRlcyBmb3IgYW4gSFRNTCB0YWcuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkudG9IdG1sQXR0cmlidXRlc1xuICAgICAqIEByZXR1cm4gUGxhaW5PYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0h0bWxBdHRyaWJ1dGVzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgYXR0ck5hbWUsIGhlaWdodCwgb3B0aW9ucywgcmVmMiwgcmVmMywgdmFsdWUsIHdpZHRoO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgdmFyIHNuYWtlQ2FzZUtleTtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMub3RoZXJPcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFsdWUgPSBfdGhpczIub3RoZXJPcHRpb25zW2tleV07XG4gICAgICAgIHNuYWtlQ2FzZUtleSA9IHNuYWtlQ2FzZShrZXkpO1xuICAgICAgICBpZiAoIWluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfZGVmYXVsdCgpKHRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uLlBBUkFNX05BTUVTLCBzbmFrZUNhc2VLZXkpICYmICFpbmNsdWRlc19yb290X2luY2x1ZGVzX2RlZmF1bHQoKShVUkxfS0VZUywgc25ha2VDYXNlS2V5KSkge1xuICAgICAgICAgIGF0dHJOYW1lID0gL15odG1sXy8udGVzdChrZXkpID8ga2V5LnNsaWNlKDUpIDoga2V5O1xuICAgICAgICAgIG9wdGlvbnNbYXR0ck5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gY29udmVydCBhbGwgXCJodG1sX2tleVwiIHRvIFwia2V5XCIgd2l0aCB0aGUgc2FtZSB2YWx1ZVxuICAgICAgdGhpcy5rZXlzKCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICgvXmh0bWxfLy50ZXN0KGtleSkpIHtcbiAgICAgICAgICBvcHRpb25zW2NhbWVsQ2FzZShrZXkuc2xpY2UoNSkpXSA9IF90aGlzMi5nZXRWYWx1ZShrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghKHRoaXMuaGFzTGF5ZXIoKSB8fCB0aGlzLmdldFZhbHVlKFwiYW5nbGVcIikgfHwgaW5jbHVkZXNfcm9vdF9pbmNsdWRlc19kZWZhdWx0KCkoW1wiZml0XCIsIFwibGltaXRcIiwgXCJsZmlsbFwiXSwgdGhpcy5nZXRWYWx1ZShcImNyb3BcIikpKSkge1xuICAgICAgICB3aWR0aCA9IChyZWYyID0gdGhpcy5nZXQoXCJ3aWR0aFwiKSkgIT0gbnVsbCA/IHJlZjIub3JpZ1ZhbHVlIDogdm9pZCAwO1xuICAgICAgICBoZWlnaHQgPSAocmVmMyA9IHRoaXMuZ2V0KFwiaGVpZ2h0XCIpKSAhPSBudWxsID8gcmVmMy5vcmlnVmFsdWUgOiB2b2lkIDA7XG4gICAgICAgIGlmIChwYXJzZUZsb2F0KHdpZHRoKSA+PSAxLjApIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy53aWR0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZUZsb2F0KGhlaWdodCkgPj0gMS4wKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSHRtbFwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIERlbGVnYXRlIHRvIHRoZSBwYXJlbnQgKHVwIHRoZSBjYWxsIGNoYWluKSB0byBwcm9kdWNlIEhUTUxcbiAgICAgKiBAZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24jdG9IdG1sXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBIVE1MIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwYXJlbnQgaWYgcG9zc2libGUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB0YWcgPSBjbG91ZGluYXJ5LkltYWdlVGFnLm5ldyhcInNhbXBsZVwiLCB7Y2xvdWRfbmFtZTogXCJkZW1vXCJ9KVxuICAgICAqIC8vIEltYWdlVGFnIHtuYW1lOiBcImltZ1wiLCBwdWJsaWNJZDogXCJzYW1wbGVcIn1cbiAgICAgKiB0YWcudG9IdG1sKClcbiAgICAgKiAvLyA8aW1nIHNyYz1cImh0dHA6Ly9yZXMuY2xvdWRpbmFyeS5jb20vZGVtby9pbWFnZS91cGxvYWQvc2FtcGxlXCI+XG4gICAgICogdGFnLnRyYW5zZm9ybWF0aW9uKCkuY3JvcChcImZpdFwiKS53aWR0aCgzMDApLnRvSHRtbCgpXG4gICAgICogLy8gPGltZyBzcmM9XCJodHRwOi8vcmVzLmNsb3VkaW5hcnkuY29tL2RlbW8vaW1hZ2UvdXBsb2FkL2NfZml0LHdfMzAwL3NhbXBsZVwiPlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSHRtbCgpIHtcbiAgICAgIHZhciByZWY7XG4gICAgICByZXR1cm4gKHJlZiA9IHRoaXMuZ2V0UGFyZW50KCkpICE9IG51bGwgPyB0eXBlb2YgcmVmLnRvSHRtbCA9PT0gXCJmdW5jdGlvblwiID8gcmVmLnRvSHRtbCgpIDogdm9pZCAwIDogdm9pZCAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnRvT3B0aW9ucyh0cnVlKSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwibGlzdE5hbWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3ROYW1lcygpIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbi5tZXRob2RzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1ZhbGlkUGFyYW1OYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzVmFsaWRQYXJhbU5hbWUobmFtZSkge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uLm1ldGhvZHMuaW5kZXhPZihjYW1lbENhc2UobmFtZSkpID49IDA7XG4gICAgfVxuICB9XSk7XG59KCk7XG52YXIgVkFSX05BTUVfUkUgPSAvXlxcJFthLXpBLVowLTldKyQvO1xudHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb25CYXNlLnByb3RvdHlwZS50cmFuc19zZXBhcmF0b3IgPSAnLyc7XG50cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbkJhc2UucHJvdG90eXBlLnBhcmFtX3NlcGFyYXRvciA9ICcsJztcbmZ1bmN0aW9uIGxhc3RBcmdDYWxsYmFjayhhcmdzKSB7XG4gIHZhciBjYWxsYmFjaztcbiAgY2FsbGJhY2sgPSBhcmdzICE9IG51bGwgPyBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gOiB2b2lkIDA7XG4gIGlmIChpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoY2FsbGJhY2spKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NWYXIodmFyQXJyYXkpIHtcbiAgdmFyIGosIGxlbiwgbmFtZSwgcmVzdWx0cywgdjtcbiAgaWYgKGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKSh2YXJBcnJheSkpIHtcbiAgICByZXN1bHRzID0gW107XG4gICAgZm9yIChqID0gMCwgbGVuID0gdmFyQXJyYXkubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIHZhciBfdmFyQXJyYXkkaiA9IHRyYW5zZm9ybWF0aW9uX3NsaWNlZFRvQXJyYXkodmFyQXJyYXlbal0sIDIpO1xuICAgICAgbmFtZSA9IF92YXJBcnJheSRqWzBdO1xuICAgICAgdiA9IF92YXJBcnJheSRqWzFdO1xuICAgICAgcmVzdWx0cy5wdXNoKFwiXCIuY29uY2F0KG5hbWUsIFwiX1wiKS5jb25jYXQoZXhwcmVzc2lvbi5ub3JtYWxpemUodikpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhckFycmF5O1xuICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzQ3VzdG9tRnVuY3Rpb24oX3JlZikge1xuICB2YXIgZnVuY3Rpb25fdHlwZSA9IF9yZWYuZnVuY3Rpb25fdHlwZSxcbiAgICBzb3VyY2UgPSBfcmVmLnNvdXJjZTtcbiAgaWYgKGZ1bmN0aW9uX3R5cGUgPT09ICdyZW1vdGUnKSB7XG4gICAgcmV0dXJuIFtmdW5jdGlvbl90eXBlLCBidG9hKHNvdXJjZSldLmpvaW4oXCI6XCIpO1xuICB9IGVsc2UgaWYgKGZ1bmN0aW9uX3R5cGUgPT09ICd3YXNtJykge1xuICAgIHJldHVybiBbZnVuY3Rpb25fdHlwZSwgc291cmNlXS5qb2luKFwiOlwiKTtcbiAgfVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybWF0aW9uIENsYXNzIG1ldGhvZHMuXG4gKiBUaGlzIGlzIGEgbGlzdCBvZiB0aGUgcGFyYW1ldGVycyBkZWZpbmVkIGluIFRyYW5zZm9ybWF0aW9uLlxuICogVmFsdWVzIGFyZSBjYW1lbENhc2VkLlxuICogQGNvbnN0IFRyYW5zZm9ybWF0aW9uLm1ldGhvZHNcbiAqIEBwcml2YXRlXG4gKiBAaWdub3JlXG4gKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn1cbiAqL1xuLyoqXG4gKiBQYXJhbWV0ZXJzIHRoYXQgYXJlIGZpbHRlcmVkIG91dCBiZWZvcmUgcGFzc2luZyB0aGUgb3B0aW9ucyB0byBhbiBIVE1MIHRhZy5cbiAqXG4gKiBUaGUgbGlzdCBvZiBwYXJhbWV0ZXJzIGlzIGEgY29tYmluYXRpb24gb2YgYFRyYW5zZm9ybWF0aW9uOjptZXRob2RzYCBhbmQgYENvbmZpZ3VyYXRpb246OkNPTkZJR19QQVJBTVNgXG4gKiBAY29uc3Qge0FycmF5PHN0cmluZz59IFRyYW5zZm9ybWF0aW9uLlBBUkFNX05BTUVTXG4gKiBAcHJpdmF0ZVxuICogQGlnbm9yZVxuICogQHNlZSB0b0h0bWxBdHRyaWJ1dGVzXG4gKi9cbnZhciB0cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RyYW5zZm9ybWF0aW9uQmFzZSkge1xuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHNpbmdsZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICogQGNsYXNzIFRyYW5zZm9ybWF0aW9uXG4gICAqIEBleGFtcGxlXG4gICAqIHQgPSBuZXcgY2xvdWRpbmFyeS5UcmFuc2Zvcm1hdGlvbigpO1xuICAgKiB0LmFuZ2xlKDIwKS5jcm9wKFwic2NhbGVcIikud2lkdGgoXCJhdXRvXCIpO1xuICAgKlxuICAgKiAvLyBvclxuICAgKlxuICAgKiB0ID0gbmV3IGNsb3VkaW5hcnkuVHJhbnNmb3JtYXRpb24oIHthbmdsZTogMjAsIGNyb3A6IFwic2NhbGVcIiwgd2lkdGg6IFwiYXV0b1wifSk7XG4gICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIlxuICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiXG4gICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgdmlkZW8gdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgKi9cbiAgZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24ob3B0aW9ucykge1xuICAgIHRyYW5zZm9ybWF0aW9uX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zZm9ybWF0aW9uKTtcbiAgICByZXR1cm4gdHJhbnNmb3JtYXRpb25fY2FsbFN1cGVyKHRoaXMsIFRyYW5zZm9ybWF0aW9uLCBbb3B0aW9uc10pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1RyYW5zZm9ybWF0aW9ufVxuICAgKiBAZXhhbXBsZSBjbCA9IGNsb3VkaW5hcnkuVHJhbnNmb3JtYXRpb24ubmV3KCB7YW5nbGU6IDIwLCBjcm9wOiBcInNjYWxlXCIsIHdpZHRoOiBcImF1dG9cIn0pXG4gICAqL1xuICB0cmFuc2Zvcm1hdGlvbl9pbmhlcml0cyhUcmFuc2Zvcm1hdGlvbiwgX1RyYW5zZm9ybWF0aW9uQmFzZSk7XG4gIHJldHVybiB0cmFuc2Zvcm1hdGlvbl9jcmVhdGVDbGFzcyhUcmFuc2Zvcm1hdGlvbiwgW3tcbiAgICBrZXk6IFwiYW5nbGVcIixcbiAgICB2YWx1ZTpcbiAgICAvKlxuICAgICAgVHJhbnNmb3JtYXRpb24gUGFyYW1ldGVyc1xuICAgICovXG4gICAgZnVuY3Rpb24gYW5nbGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmFycmF5UGFyYW0odmFsdWUsIFwiYW5nbGVcIiwgXCJhXCIsIFwiLlwiLCBleHByZXNzaW9uLm5vcm1hbGl6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImF1ZGlvQ29kZWNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXVkaW9Db2RlYyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiYXVkaW9fY29kZWNcIiwgXCJhY1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXVkaW9GcmVxdWVuY3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXVkaW9GcmVxdWVuY3kodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImF1ZGlvX2ZyZXF1ZW5jeVwiLCBcImFmXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhc3BlY3RSYXRpb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhc3BlY3RSYXRpbyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiYXNwZWN0X3JhdGlvXCIsIFwiYXJcIiwgZXhwcmVzc2lvbi5ub3JtYWxpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiYWNrZ3JvdW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJhY2tncm91bmQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImJhY2tncm91bmRcIiwgXCJiXCIsIHBhcmFtZXRlcnNfUGFyYW0ubm9ybV9jb2xvcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJpdFJhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYml0UmF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiYml0X3JhdGVcIiwgXCJiclwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJvcmRlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiYm9yZGVyXCIsIFwiYm9cIiwgZnVuY3Rpb24gKGJvcmRlcikge1xuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfZGVmYXVsdCgpKGJvcmRlcikpIHtcbiAgICAgICAgICBib3JkZXIgPSBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHt9LCB7XG4gICAgICAgICAgICBjb2xvcjogXCJibGFja1wiLFxuICAgICAgICAgICAgd2lkdGg6IDJcbiAgICAgICAgICB9LCBib3JkZXIpO1xuICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChib3JkZXIud2lkdGgsIFwicHhfc29saWRfXCIpLmNvbmNhdChwYXJhbWV0ZXJzX1BhcmFtLm5vcm1fY29sb3IoYm9yZGVyLmNvbG9yKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGJvcmRlcjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJjb2xvclwiLCBcImNvXCIsIHBhcmFtZXRlcnNfUGFyYW0ubm9ybV9jb2xvcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbG9yU3BhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29sb3JTcGFjZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiY29sb3Jfc3BhY2VcIiwgXCJjc1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcm9wKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJjcm9wXCIsIFwiY1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3VzdG9tRnVuY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3VzdG9tRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImN1c3RvbV9mdW5jdGlvblwiLCBcImZuXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NDdXN0b21GdW5jdGlvbih2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3VzdG9tUHJlRnVuY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3VzdG9tUHJlRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLmdldCgnY3VzdG9tX2Z1bmN0aW9uJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmF3UGFyYW0odmFsdWUsIFwiY3VzdG9tX2Z1bmN0aW9uXCIsIFwiXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFsdWUgPSBwcm9jZXNzQ3VzdG9tRnVuY3Rpb24odmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWUgPyBcImZuX3ByZTpcIi5jb25jYXQodmFsdWUpIDogdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVmYXVsdEltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlZmF1bHRJbWFnZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiZGVmYXVsdF9pbWFnZVwiLCBcImRcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGF5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJkZWxheVwiLCBcImRsXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZW5zaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbnNpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImRlbnNpdHlcIiwgXCJkblwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHVyYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHVyYXRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJhbmdlUGFyYW0odmFsdWUsIFwiZHVyYXRpb25cIiwgXCJkdVwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHByXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRwcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiZHByXCIsIFwiZHByXCIsIGZ1bmN0aW9uIChkcHIpIHtcbiAgICAgICAgZHByID0gZHByLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChkcHIgIT0gbnVsbCA/IGRwci5tYXRjaCgvXlxcZCskLykgOiB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gZHByICsgXCIuMFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBleHByZXNzaW9uLm5vcm1hbGl6ZShkcHIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWZmZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVmZmVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXJyYXlQYXJhbSh2YWx1ZSwgXCJlZmZlY3RcIiwgXCJlXCIsIFwiOlwiLCBleHByZXNzaW9uLm5vcm1hbGl6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVsc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Vsc2UoKSB7XG4gICAgICByZXR1cm4gdGhpc1tcImlmXCJdKCdlbHNlJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZElmXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZElmKCkge1xuICAgICAgcmV0dXJuIHRoaXNbXCJpZlwiXSgnZW5kJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZE9mZnNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmRPZmZzZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJhbmdlUGFyYW0odmFsdWUsIFwiZW5kX29mZnNldFwiLCBcImVvXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmYWxsYmFja0NvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFsbGJhY2tDb250ZW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJmYWxsYmFja19jb250ZW50XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmZXRjaEZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmZXRjaEZvcm1hdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiZmV0Y2hfZm9ybWF0XCIsIFwiZlwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiZm9ybWF0XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmbGFnc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmbGFncyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXJyYXlQYXJhbSh2YWx1ZSwgXCJmbGFnc1wiLCBcImZsXCIsIFwiLlwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ3Jhdml0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBncmF2aXR5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJncmF2aXR5XCIsIFwiZ1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnBzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZwcyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiZnBzXCIsIFwiZnBzXCIsIGZ1bmN0aW9uIChmcHMpIHtcbiAgICAgICAgaWYgKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKGZwcykpIHtcbiAgICAgICAgICByZXR1cm4gZnBzO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKShmcHMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZwcy5qb2luKFwiLVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZnBzO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGVpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhlaWdodCh2YWx1ZSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJoZWlnaHRcIiwgXCJoXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzMy5nZXRWYWx1ZShcImNyb3BcIikgfHwgX3RoaXMzLmdldFZhbHVlKFwib3ZlcmxheVwiKSB8fCBfdGhpczMuZ2V0VmFsdWUoXCJ1bmRlcmxheVwiKSkge1xuICAgICAgICAgIHJldHVybiBleHByZXNzaW9uLm5vcm1hbGl6ZSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJodG1sSGVpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGh0bWxIZWlnaHQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImh0bWxfaGVpZ2h0XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJodG1sV2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaHRtbFdpZHRoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJodG1sX3dpZHRoXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpZlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaWYoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFwiXCI7XG4gICAgICB2YXIgaSwgaWZWYWwsIGosIHJlZiwgdHJJZiwgdHJSZXN0O1xuICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICBjYXNlIFwiZWxzZVwiOlxuICAgICAgICAgIHRoaXMuY2hhaW4oKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJpZlwiLCBcImlmXCIpO1xuICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgdGhpcy5jaGFpbigpO1xuICAgICAgICAgIGZvciAoaSA9IGogPSByZWYgPSB0aGlzLmNoYWluZWQubGVuZ3RoIC0gMTsgaiA+PSAwOyBpID0gaiArPSAtMSkge1xuICAgICAgICAgICAgaWZWYWwgPSB0aGlzLmNoYWluZWRbaV0uZ2V0VmFsdWUoXCJpZlwiKTtcbiAgICAgICAgICAgIGlmIChpZlZhbCA9PT0gXCJlbmRcIikge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaWZWYWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB0cklmID0gVHJhbnNmb3JtYXRpb25bXCJuZXdcIl0oKVtcImlmXCJdKGlmVmFsKTtcbiAgICAgICAgICAgICAgdGhpcy5jaGFpbmVkW2ldLnJlbW92ZShcImlmXCIpO1xuICAgICAgICAgICAgICB0clJlc3QgPSB0aGlzLmNoYWluZWRbaV07XG4gICAgICAgICAgICAgIHRoaXMuY2hhaW5lZFtpXSA9IFRyYW5zZm9ybWF0aW9uW1wibmV3XCJdKCkudHJhbnNmb3JtYXRpb24oW3RySWYsIHRyUmVzdF0pO1xuICAgICAgICAgICAgICBpZiAoaWZWYWwgIT09IFwiZWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiaWZcIiwgXCJpZlwiKTtcbiAgICAgICAgY2FzZSBcIlwiOlxuICAgICAgICAgIHJldHVybiBjb25kaXRpb25bXCJuZXdcIl0oKS5zZXRQYXJlbnQodGhpcyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiaWZcIiwgXCJpZlwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25kaXRpb25bXCJuZXdcIl0odmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImtleWZyYW1lSW50ZXJ2YWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ga2V5ZnJhbWVJbnRlcnZhbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwia2V5ZnJhbWVfaW50ZXJ2YWxcIiwgXCJraVwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib2NyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9jcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwib2NyXCIsIFwib2NyXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvZmZzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2Zmc2V0KHZhbHVlKSB7XG4gICAgICB2YXIgZW5kX28sIHN0YXJ0X287XG4gICAgICB2YXIgX3JlZjIgPSBpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkodmFsdWUgIT0gbnVsbCA/IHZhbHVlLnNwbGl0IDogdm9pZCAwKSA/IHZhbHVlLnNwbGl0KCcuLicpIDogaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHZhbHVlKSA/IHZhbHVlIDogW251bGwsIG51bGxdO1xuICAgICAgdmFyIF9yZWYzID0gdHJhbnNmb3JtYXRpb25fc2xpY2VkVG9BcnJheShfcmVmMiwgMik7XG4gICAgICBzdGFydF9vID0gX3JlZjNbMF07XG4gICAgICBlbmRfbyA9IF9yZWYzWzFdO1xuICAgICAgaWYgKHN0YXJ0X28gIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnN0YXJ0T2Zmc2V0KHN0YXJ0X28pO1xuICAgICAgfVxuICAgICAgaWYgKGVuZF9vICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kT2Zmc2V0KGVuZF9vKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3BhY2l0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcGFjaXR5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJvcGFjaXR5XCIsIFwib1wiLCBleHByZXNzaW9uLm5vcm1hbGl6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm92ZXJsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3ZlcmxheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMubGF5ZXJQYXJhbSh2YWx1ZSwgXCJvdmVybGF5XCIsIFwibFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYWdlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJwYWdlXCIsIFwicGdcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3N0ZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInBvc3RlclwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJlZml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZWZpeCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwicHJlZml4XCIsIFwicFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicXVhbGl0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBxdWFsaXR5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJxdWFsaXR5XCIsIFwicVwiLCBleHByZXNzaW9uLm5vcm1hbGl6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJhZGl1c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByYWRpdXModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmFycmF5UGFyYW0odmFsdWUsIFwicmFkaXVzXCIsIFwiclwiLCBcIjpcIiwgZXhwcmVzc2lvbi5ub3JtYWxpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyYXdUcmFuc2Zvcm1hdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByYXdUcmFuc2Zvcm1hdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmF3UGFyYW0odmFsdWUsIFwicmF3X3RyYW5zZm9ybWF0aW9uXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpemUodmFsdWUpIHtcbiAgICAgIHZhciBoZWlnaHQsIHdpZHRoO1xuICAgICAgaWYgKGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKSh2YWx1ZSAhPSBudWxsID8gdmFsdWUuc3BsaXQgOiB2b2lkIDApKSB7XG4gICAgICAgIHZhciBfdmFsdWUkc3BsaXQgPSB2YWx1ZS5zcGxpdCgneCcpO1xuICAgICAgICB2YXIgX3ZhbHVlJHNwbGl0MiA9IHRyYW5zZm9ybWF0aW9uX3NsaWNlZFRvQXJyYXkoX3ZhbHVlJHNwbGl0LCAyKTtcbiAgICAgICAgd2lkdGggPSBfdmFsdWUkc3BsaXQyWzBdO1xuICAgICAgICBoZWlnaHQgPSBfdmFsdWUkc3BsaXQyWzFdO1xuICAgICAgICB0aGlzLndpZHRoKHdpZHRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0KGhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNvdXJjZVR5cGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvdXJjZVR5cGVzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJzb3VyY2VfdHlwZXNcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNvdXJjZVRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvdXJjZVRyYW5zZm9ybWF0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJzb3VyY2VfdHJhbnNmb3JtYXRpb25cIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0T2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0T2Zmc2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yYW5nZVBhcmFtKHZhbHVlLCBcInN0YXJ0X29mZnNldFwiLCBcInNvXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdHJlYW1pbmdQcm9maWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0cmVhbWluZ1Byb2ZpbGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInN0cmVhbWluZ19wcm9maWxlXCIsIFwic3BcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1hdGlvblBhcmFtKHZhbHVlLCBcInRyYW5zZm9ybWF0aW9uXCIsIFwidFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5kZXJsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5kZXJsYXkodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmxheWVyUGFyYW0odmFsdWUsIFwidW5kZXJsYXlcIiwgXCJ1XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YXJpYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YXJpYWJsZShuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIG5hbWUsIG5hbWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YXJpYWJsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFyaWFibGVzKHZhbHVlcykge1xuICAgICAgcmV0dXJuIHRoaXMuYXJyYXlQYXJhbSh2YWx1ZXMsIFwidmFyaWFibGVzXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2aWRlb0NvZGVjXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpZGVvQ29kZWModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInZpZGVvX2NvZGVjXCIsIFwidmNcIiwgcGFyYW1ldGVyc19QYXJhbS5wcm9jZXNzX3ZpZGVvX3BhcmFtcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZpZGVvU2FtcGxpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmlkZW9TYW1wbGluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwidmlkZW9fc2FtcGxpbmdcIiwgXCJ2c1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2lkdGgodmFsdWUpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwid2lkdGhcIiwgXCJ3XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzNC5nZXRWYWx1ZShcImNyb3BcIikgfHwgX3RoaXM0LmdldFZhbHVlKFwib3ZlcmxheVwiKSB8fCBfdGhpczQuZ2V0VmFsdWUoXCJ1bmRlcmxheVwiKSkge1xuICAgICAgICAgIHJldHVybiBleHByZXNzaW9uLm5vcm1hbGl6ZSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHgodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInhcIiwgXCJ4XCIsIGV4cHJlc3Npb24ubm9ybWFsaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwieVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJ5XCIsIFwieVwiLCBleHByZXNzaW9uLm5vcm1hbGl6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInpvb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gem9vbSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiem9vbVwiLCBcInpcIiwgZXhwcmVzc2lvbi5ub3JtYWxpemUpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcIm5ld1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbmV3KG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgVHJhbnNmb3JtYXRpb24ob3B0aW9ucyk7XG4gICAgfVxuICB9XSk7XG59KHRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uQmFzZSk7XG4vKipcbiAqIFRyYW5zZm9ybWF0aW9uIENsYXNzIG1ldGhvZHMuXG4gKiBUaGlzIGlzIGEgbGlzdCBvZiB0aGUgcGFyYW1ldGVycyBkZWZpbmVkIGluIFRyYW5zZm9ybWF0aW9uLlxuICogVmFsdWVzIGFyZSBjYW1lbENhc2VkLlxuICovXG50cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbi5tZXRob2RzID0gW1wiYW5nbGVcIiwgXCJhdWRpb0NvZGVjXCIsIFwiYXVkaW9GcmVxdWVuY3lcIiwgXCJhc3BlY3RSYXRpb1wiLCBcImJhY2tncm91bmRcIiwgXCJiaXRSYXRlXCIsIFwiYm9yZGVyXCIsIFwiY29sb3JcIiwgXCJjb2xvclNwYWNlXCIsIFwiY3JvcFwiLCBcImN1c3RvbUZ1bmN0aW9uXCIsIFwiY3VzdG9tUHJlRnVuY3Rpb25cIiwgXCJkZWZhdWx0SW1hZ2VcIiwgXCJkZWxheVwiLCBcImRlbnNpdHlcIiwgXCJkdXJhdGlvblwiLCBcImRwclwiLCBcImVmZmVjdFwiLCBcImVsc2VcIiwgXCJlbmRJZlwiLCBcImVuZE9mZnNldFwiLCBcImZhbGxiYWNrQ29udGVudFwiLCBcImZldGNoRm9ybWF0XCIsIFwiZm9ybWF0XCIsIFwiZmxhZ3NcIiwgXCJncmF2aXR5XCIsIFwiZnBzXCIsIFwiaGVpZ2h0XCIsIFwiaHRtbEhlaWdodFwiLCBcImh0bWxXaWR0aFwiLCBcImlmXCIsIFwia2V5ZnJhbWVJbnRlcnZhbFwiLCBcIm9jclwiLCBcIm9mZnNldFwiLCBcIm9wYWNpdHlcIiwgXCJvdmVybGF5XCIsIFwicGFnZVwiLCBcInBvc3RlclwiLCBcInByZWZpeFwiLCBcInF1YWxpdHlcIiwgXCJyYWRpdXNcIiwgXCJyYXdUcmFuc2Zvcm1hdGlvblwiLCBcInNpemVcIiwgXCJzb3VyY2VUeXBlc1wiLCBcInNvdXJjZVRyYW5zZm9ybWF0aW9uXCIsIFwic3RhcnRPZmZzZXRcIiwgXCJzdHJlYW1pbmdQcm9maWxlXCIsIFwidHJhbnNmb3JtYXRpb25cIiwgXCJ1bmRlcmxheVwiLCBcInZhcmlhYmxlXCIsIFwidmFyaWFibGVzXCIsIFwidmlkZW9Db2RlY1wiLCBcInZpZGVvU2FtcGxpbmdcIiwgXCJ3aWR0aFwiLCBcInhcIiwgXCJ5XCIsIFwiem9vbVwiXTtcblxuLyoqXG4gKiBQYXJhbWV0ZXJzIHRoYXQgYXJlIGZpbHRlcmVkIG91dCBiZWZvcmUgcGFzc2luZyB0aGUgb3B0aW9ucyB0byBhbiBIVE1MIHRhZy5cbiAqXG4gKiBUaGUgbGlzdCBvZiBwYXJhbWV0ZXJzIGlzIGEgY29tYmluYXRpb24gb2YgYFRyYW5zZm9ybWF0aW9uOjptZXRob2RzYCBhbmQgYENvbmZpZ3VyYXRpb246OkNPTkZJR19QQVJBTVNgXG4gKi9cbnRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uLlBBUkFNX05BTUVTID0gdHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb24ubWV0aG9kcy5tYXAoc25ha2VDYXNlKS5jb25jYXQoc3JjX2NvbmZpZ3VyYXRpb24uQ09ORklHX1BBUkFNUyk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfdHJhbnNmb3JtYXRpb24gPSAodHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb24pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdGFncy9odG1sdGFnLmpzXG5mdW5jdGlvbiBodG1sdGFnX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIGh0bWx0YWdfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIGh0bWx0YWdfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBodG1sdGFnX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiBodG1sdGFnX2RlZmluZVByb3BlcnRpZXMoZSwgcikgeyBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHsgdmFyIG8gPSByW3RdOyBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgaHRtbHRhZ190b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7IH0gfVxuZnVuY3Rpb24gaHRtbHRhZ19jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIGh0bWx0YWdfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgaHRtbHRhZ19kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7IH1cbmZ1bmN0aW9uIGh0bWx0YWdfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gaHRtbHRhZ190b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gaHRtbHRhZ190eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIGh0bWx0YWdfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBodG1sdGFnX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBodG1sdGFnX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG4vKipcbiAqIEdlbmVyaWMgSFRNTCB0YWdcbiAqIERlcGVuZHMgb24gJ3RyYW5zZm9ybWF0aW9uJywgJ3V0aWwnXG4gKi9cblxuXG5cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIEhUTUwgKERPTSkgdGFnXG4gKiBAY29uc3RydWN0b3IgSHRtbFRhZ1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgdGFnXG4gKiBAcGFyYW0ge3N0cmluZ30gW3B1YmxpY0lkXVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBleGFtcGxlIHRhZyA9IG5ldyBIdG1sVGFnKCAnZGl2JywgeyAnd2lkdGgnOiAxMH0pXG4gKi9cbnZhciBodG1sdGFnX0h0bWxUYWcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBIdG1sVGFnKG5hbWUsIHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgaHRtbHRhZ19jbGFzc0NhbGxDaGVjayh0aGlzLCBIdG1sVGFnKTtcbiAgICB2YXIgdHJhbnNmb3JtYXRpb247XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnB1YmxpY0lkID0gcHVibGljSWQ7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgaWYgKGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQoKShwdWJsaWNJZCkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHB1YmxpY0lkO1xuICAgICAgICB0aGlzLnB1YmxpY0lkID0gdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuICAgIH1cbiAgICB0cmFuc2Zvcm1hdGlvbiA9IG5ldyBzcmNfdHJhbnNmb3JtYXRpb24ob3B0aW9ucyk7XG4gICAgdHJhbnNmb3JtYXRpb24uc2V0UGFyZW50KHRoaXMpO1xuICAgIHRoaXMudHJhbnNmb3JtYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtYXRpb247XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBjb25zdHJ1Y3RvclxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGFuIEhUTUwgKERPTSkgdGFnXG4gICAqIEBmdW5jdGlvbiBIdG1sVGFnLm5ld1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSB0YWdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtwdWJsaWNJZF1cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7SHRtbFRhZ31cbiAgICogQGV4YW1wbGUgdGFnID0gSHRtbFRhZy5uZXcoICdkaXYnLCB7ICd3aWR0aCc6IDEwfSlcbiAgICovXG4gIHJldHVybiBodG1sdGFnX2NyZWF0ZUNsYXNzKEh0bWxUYWcsIFt7XG4gICAga2V5OiBcImh0bWxBdHRyc1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIGNvbWJpbmUga2V5IGFuZCB2YWx1ZSBmcm9tIHRoZSBgYXR0cmAgdG8gZ2VuZXJhdGUgYW4gSFRNTCB0YWcgYXR0cmlidXRlcyBzdHJpbmcuXG4gICAgICogYFRyYW5zZm9ybWF0aW9uOjp0b0h0bWxUYWdPcHRpb25zYCBpcyB1c2VkIHRvIGZpbHRlciBvdXQgdHJhbnNmb3JtYXRpb24gYW5kIGNvbmZpZ3VyYXRpb24ga2V5cy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJzXG4gICAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgYXR0cmlidXRlcyBpbiB0aGUgZm9ybWF0IGAna2V5MT1cInZhbHVlMVwiIGtleTI9XCJ2YWx1ZTJcIidgXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGh0bWxBdHRycyhhdHRycykge1xuICAgICAgdmFyIGtleSwgcGFpcnMsIHZhbHVlO1xuICAgICAgcmV0dXJuIHBhaXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0cztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgICAgICAgIHZhbHVlID0gZXNjYXBlUXVvdGVzKGF0dHJzW2tleV0pO1xuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGh0bWx0YWdfdG9BdHRyaWJ1dGUoa2V5LCB2YWx1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH0oKS5zb3J0KCkuam9pbignICcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgb3B0aW9ucyByZWxhdGVkIHRvIHRoaXMgdGFnLlxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI2dldE9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgb3B0aW9uc1xuICAgICAqXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPcHRpb25zKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtYXRpb24oKS50b09wdGlvbnMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIG9wdGlvbiBgbmFtZWBcbiAgICAgKiBAZnVuY3Rpb24gSHRtbFRhZyNnZXRPcHRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG9wdGlvblxuICAgICAqXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T3B0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9wdGlvbihuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1hdGlvbigpLmdldFZhbHVlKG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgdGFnLlxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI2F0dHJpYnV0ZXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYXR0cmlidXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVzKCkge1xuICAgICAgLy8gVGhlIGF0dHJpYnV0ZXMgYXJlIGJlIGNvbXB1dGVkIGZyb20gdGhlIG9wdGlvbnMgZXZlcnkgdGltZSB0aGlzIG1ldGhvZCBpcyBpbnZva2VkLlxuICAgICAgdmFyIGh0bWxBdHRyaWJ1dGVzID0gdGhpcy50cmFuc2Zvcm1hdGlvbigpLnRvSHRtbEF0dHJpYnV0ZXMoKTtcbiAgICAgIE9iamVjdC5rZXlzKGh0bWxBdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQoKShodG1sQXR0cmlidXRlc1trZXldKSkge1xuICAgICAgICAgIGRlbGV0ZSBodG1sQXR0cmlidXRlc1trZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChodG1sQXR0cmlidXRlcy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIC8vIEN1cnJlbnRseSBIVE1MIGF0dHJpYnV0ZXMgYXJlIGRlZmluZWQgYm90aCBhdCB0aGUgdG9wIGxldmVsIGFuZCB1bmRlciAnYXR0cmlidXRlcydcbiAgICAgICAgbWVyZ2Vfcm9vdF9tZXJnZV9kZWZhdWx0KCkoaHRtbEF0dHJpYnV0ZXMsIGh0bWxBdHRyaWJ1dGVzLmF0dHJpYnV0ZXMpO1xuICAgICAgICBkZWxldGUgaHRtbEF0dHJpYnV0ZXMuYXR0cmlidXRlcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBodG1sQXR0cmlidXRlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSB0YWcgYXR0cmlidXRlIG5hbWVkIGBuYW1lYCB0byBgdmFsdWVgXG4gICAgICogQGZ1bmN0aW9uIEh0bWxUYWcjc2V0QXR0clxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0QXR0clwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBdHRyKG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybWF0aW9uKCkuc2V0KFwiaHRtbF9cIi5jb25jYXQobmFtZSksIHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgb2YgdGhlIHRhZyBhdHRyaWJ1dGUgYG5hbWVgXG4gICAgICogQGZ1bmN0aW9uIEh0bWxUYWcjZ2V0QXR0clxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEF0dHJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXR0cihuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzKClbXCJodG1sX1wiLmNvbmNhdChuYW1lKV0gfHwgdGhpcy5hdHRyaWJ1dGVzKClbbmFtZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSB0YWcgYXR0cmlidXRlZCBuYW1lZCBgbmFtZWBcbiAgICAgKiBAZnVuY3Rpb24gSHRtbFRhZyNyZW1vdmVBdHRyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlQXR0clwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVBdHRyKG5hbWUpIHtcbiAgICAgIHZhciByZWY7XG4gICAgICByZXR1cm4gKHJlZiA9IHRoaXMudHJhbnNmb3JtYXRpb24oKS5yZW1vdmUoXCJodG1sX1wiLmNvbmNhdChuYW1lKSkpICE9IG51bGwgPyByZWYgOiB0aGlzLnRyYW5zZm9ybWF0aW9uKCkucmVtb3ZlKG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI2NvbnRlbnRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGVudCgpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI29wZW5UYWdcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm9wZW5UYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3BlblRhZygpIHtcbiAgICAgIHZhciB0YWcgPSBcIjxcIiArIHRoaXMubmFtZTtcbiAgICAgIHZhciBodG1sQXR0cnMgPSB0aGlzLmh0bWxBdHRycyh0aGlzLmF0dHJpYnV0ZXMoKSk7XG4gICAgICBpZiAoaHRtbEF0dHJzICYmIGh0bWxBdHRycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRhZyArPSBcIiBcIiArIGh0bWxBdHRycztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWcgKyBcIj5cIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gSHRtbFRhZyNjbG9zZVRhZ1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VUYWcoKSB7XG4gICAgICByZXR1cm4gXCI8L1wiLmNvbmNhdCh0aGlzLm5hbWUsIFwiPlwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW4gSFRNTCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGFnLlxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI3RvSHRtbFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgSFRNTCBpbiBzdHJpbmcgZm9ybWF0XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidG9IdG1sXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSHRtbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wZW5UYWcoKSArIHRoaXMuY29udGVudCgpICsgdGhpcy5jbG9zZVRhZygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBET00gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgdGFnLlxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI3RvRE9NXG4gICAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidG9ET01cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9ET00oKSB7XG4gICAgICB2YXIgZWxlbWVudCwgbmFtZSwgcmVmLCB2YWx1ZTtcbiAgICAgIGlmICghaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudCAhPT0gbnVsbCA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgOiB2b2lkIDApKSB7XG4gICAgICAgIHRocm93IFwiQ2FuJ3QgY3JlYXRlIERPTSBpZiBkb2N1bWVudCBpcyBub3QgcHJlc2VudCFcIjtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMubmFtZSk7XG4gICAgICByZWYgPSB0aGlzLmF0dHJpYnV0ZXMoKTtcbiAgICAgIGZvciAobmFtZSBpbiByZWYpIHtcbiAgICAgICAgdmFsdWUgPSByZWZbbmFtZV07XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcIm5ld1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbmV3KG5hbWUsIHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMobmFtZSwgcHVibGljSWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1Jlc3BvbnNpdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNSZXNwb25zaXZlKHRhZywgcmVzcG9uc2l2ZUNsYXNzKSB7XG4gICAgICB2YXIgZGF0YVNyYztcbiAgICAgIGRhdGFTcmMgPSBsb2Rhc2hfZ2V0RGF0YSh0YWcsICdzcmMtY2FjaGUnKSB8fCBsb2Rhc2hfZ2V0RGF0YSh0YWcsICdzcmMnKTtcbiAgICAgIHJldHVybiBsb2Rhc2hfaGFzQ2xhc3ModGFnLCByZXNwb25zaXZlQ2xhc3MpICYmIC9cXGJ3X2F1dG9cXGIvLmV4ZWMoZGF0YVNyYyk7XG4gICAgfVxuICB9XSk7XG59KCk7XG47XG5cbi8qKlxuICogUmVwcmVzZW50IHRoZSBnaXZlbiBrZXkgYW5kIHZhbHVlIGFzIGFuIEhUTUwgYXR0cmlidXRlLlxuICogQGZ1bmN0aW9uIHRvQXR0cmlidXRlXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gYXR0cmlidXRlIG5hbWVcbiAqIEBwYXJhbSB7Knxib29sZWFufSB2YWx1ZSAtIHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlLiBJZiB0aGUgdmFsdWUgaXMgYm9vbGVhbiBgdHJ1ZWAsIHJldHVybiB0aGUga2V5IG9ubHkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgYXR0cmlidXRlXG4gKlxuICovXG5mdW5jdGlvbiBodG1sdGFnX3RvQXR0cmlidXRlKGtleSwgdmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICByZXR1cm4ga2V5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdChrZXksIFwiPVxcXCJcIikuY29uY2F0KHZhbHVlLCBcIlxcXCJcIik7XG4gIH1cbn1cblxuLyoqXG4gKiBJZiBnaXZlbiB2YWx1ZSBpcyBhIHN0cmluZywgcmVwbGFjZXMgcXVvdGVzIHdpdGggY2hhcmFjdGVyIGVudGl0aWVzICgmIzM0OywgJiMzOTspXG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byBjaGFuZ2VcbiAqIEByZXR1cm5zIHsqfSBjaGFuZ2VkIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVF1b3Rlcyh2YWx1ZSkge1xuICByZXR1cm4gaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkodmFsdWUpID8gdmFsdWUucmVwbGFjZSgnXCInLCAnJiMzNDsnKS5yZXBsYWNlKFwiJ1wiLCAnJiMzOTsnKSA6IHZhbHVlO1xufVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaHRtbHRhZyA9IChodG1sdGFnX0h0bWxUYWcpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXJsLmpzXG52YXIgX2V4Y2x1ZGVkID0gW1wicGxhY2Vob2xkZXJcIiwgXCJhY2Nlc3NpYmlsaXR5XCJdO1xuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGUsIHQpIHsgaWYgKG51bGwgPT0gZSkgcmV0dXJuIHt9OyB2YXIgbywgciwgaSA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKGUsIHQpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IGZvciAociA9IDA7IHIgPCBuLmxlbmd0aDsgcisrKSBvID0gbltyXSwgLTEgPT09IHQuaW5kZXhPZihvKSAmJiB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsIG8pICYmIChpW29dID0gZVtvXSk7IH0gcmV0dXJuIGk7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHIsIGUpIHsgaWYgKG51bGwgPT0gcikgcmV0dXJuIHt9OyB2YXIgdCA9IHt9OyBmb3IgKHZhciBuIGluIHIpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsIG4pKSB7IGlmICgtMSAhPT0gZS5pbmRleE9mKG4pKSBjb250aW51ZTsgdFtuXSA9IHJbbl07IH0gcmV0dXJuIHQ7IH1cblxuXG5cblxuXG5cblxuLyoqXG4gKiBBZGRzIHByb3RvY29sLCBob3N0LCBwYXRobmFtZSBwcmVmaXhlcyB0byBnaXZlbiBzdHJpbmdcbiAqIEBwYXJhbSBzdHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIG1ha2VVcmwoc3RyKSB7XG4gIHZhciBwcmVmaXggPSBkb2N1bWVudC5sb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBkb2N1bWVudC5sb2NhdGlvbi5ob3N0O1xuICBpZiAoc3RyWzBdID09PSAnPycpIHtcbiAgICBwcmVmaXggKz0gZG9jdW1lbnQubG9jYXRpb24ucGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoc3RyWzBdICE9PSAnLycpIHtcbiAgICBwcmVmaXggKz0gZG9jdW1lbnQubG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCAnLycpO1xuICB9XG4gIHJldHVybiBwcmVmaXggKyBzdHI7XG59XG5cbi8qKlxuICogQ2hlY2sgaXMgZ2l2ZW4gc3RyaW5nIGlzIGEgdXJsXG4gKiBAcGFyYW0gc3RyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNVcmwoc3RyKSB7XG4gIHJldHVybiBzdHIgPyAhIXN0ci5tYXRjaCgvXmh0dHBzPzpcXC8vKSA6IGZhbHNlO1xufVxuXG4vLyBQcm9kdWNlIGEgbnVtYmVyIGJldHdlZW4gMSBhbmQgNSB0byBiZSB1c2VkIGZvciBjZG4gc3ViIGRvbWFpbnMgZGVzaWduYXRpb25cbmZ1bmN0aW9uIGNkblN1YmRvbWFpbk51bWJlcihwdWJsaWNJZCkge1xuICByZXR1cm4gc3JjX2NyYzMyKHB1YmxpY0lkKSAlIDUgKyAxO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgc2lnbmF0dXJlIGZyb20gb3B0aW9ucyBhbmQgcmV0dXJucyB0aGUgc2lnbmF0dXJlXG4gKiBNYWtlcyBzdXJlIHNpZ25hdHVyZSBpcyBlbXB0eSBvciBvZiB0aGlzIGZvcm1hdDogcy0tc2lnbmF0dXJlLS1cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgZm9ybWF0dGVkIHNpZ25hdHVyZVxuICovXG5mdW5jdGlvbiBoYW5kbGVTaWduYXR1cmUob3B0aW9ucykge1xuICB2YXIgc2lnbmF0dXJlID0gb3B0aW9ucy5zaWduYXR1cmU7XG4gIHZhciBpc0Zvcm1hdHRlZCA9ICFzaWduYXR1cmUgfHwgc2lnbmF0dXJlLmluZGV4T2YoJ3MtLScpID09PSAwICYmIHNpZ25hdHVyZS5zdWJzdHIoLTIpID09PSAnLS0nO1xuICBkZWxldGUgb3B0aW9ucy5zaWduYXR1cmU7XG4gIHJldHVybiBpc0Zvcm1hdHRlZCA/IHNpZ25hdHVyZSA6IFwicy0tXCIuY29uY2F0KHNpZ25hdHVyZSwgXCItLVwiKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgdGhlIFVSTCBwcmVmaXggZm9yIENsb3VkaW5hcnkgcmVzb3VyY2VzLlxuICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIHRoZSByZXNvdXJjZSBwdWJsaWMgSURcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGFkZGl0aW9uYWwgb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2xvdWRfbmFtZSAtIHRoZSBjbG91ZCBuYW1lLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jZG5fc3ViZG9tYWluPWZhbHNlXSAtIFdoZXRoZXIgdG8gYXV0b21hdGljYWxseSBidWlsZCBVUkxzIHdpdGhcbiAqICBtdWx0aXBsZSBDRE4gc3ViLWRvbWFpbnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucHJpdmF0ZV9jZG5dIC0gQm9vbGVhbiAoZGVmYXVsdDogZmFsc2UpLiBTaG91bGQgYmUgc2V0IHRvIHRydWUgZm9yIEFkdmFuY2VkIHBsYW4ncyB1c2Vyc1xuICogIHRoYXQgaGF2ZSBhIHByaXZhdGUgQ0ROIGRpc3RyaWJ1dGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wcm90b2NvbD1cImh0dHA6Ly9cIl0gLSB0aGUgVVJJIHByb3RvY29sIHRvIHVzZS4gSWYgb3B0aW9ucy5zZWN1cmUgaXMgdHJ1ZSxcbiAqICB0aGUgdmFsdWUgaXMgb3ZlcnJpZGRlbiB0byBcImh0dHBzOi8vXCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zZWN1cmVfZGlzdHJpYnV0aW9uXSAtIFRoZSBkb21haW4gbmFtZSBvZiB0aGUgQ0ROIGRpc3RyaWJ1dGlvbiB0byB1c2UgZm9yIGJ1aWxkaW5nIEhUVFBTIFVSTHMuXG4gKiAgUmVsZXZhbnQgb25seSBmb3IgQWR2YW5jZWQgcGxhbidzIHVzZXJzIHRoYXQgaGF2ZSBhIHByaXZhdGUgQ0ROIGRpc3RyaWJ1dGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jbmFtZV0gLSBDdXN0b20gZG9tYWluIG5hbWUgdG8gdXNlIGZvciBidWlsZGluZyBIVFRQIFVSTHMuXG4gKiAgUmVsZXZhbnQgb25seSBmb3IgQWR2YW5jZWQgcGxhbidzIHVzZXJzIHRoYXQgaGF2ZSBhIHByaXZhdGUgQ0ROIGRpc3RyaWJ1dGlvbiBhbmQgYSBjdXN0b20gQ05BTUUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZV9jZG5fc3ViZG9tYWluPXRydWVdIC0gV2hlbiBvcHRpb25zLnNlY3VyZSBpcyB0cnVlIGFuZCB0aGlzIHBhcmFtZXRlciBpcyBmYWxzZSxcbiAqICB0aGUgc3ViZG9tYWluIGlzIHNldCB0byBcInJlc1wiLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmU9ZmFsc2VdIC0gRm9yY2UgSFRUUFMgVVJMcyBvZiBpbWFnZXMgZXZlbiBpZiBlbWJlZGRlZCBpbiBub24tc2VjdXJlIEhUVFAgcGFnZXMuXG4gKiAgV2hlbiB0aGlzIHZhbHVlIGlzIHRydWUsIG9wdGlvbnMuc2VjdXJlX2Rpc3RyaWJ1dGlvbiB3aWxsIGJlIHVzZWQgYXMgaG9zdCBpZiBwcm92aWRlZCwgYW5kIG9wdGlvbnMucHJvdG9jb2wgaXMgc2V0XG4gKiAgdG8gXCJodHRwczovL1wiLlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIFVSTCBwcmVmaXggZm9yIHRoZSByZXNvdXJjZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVByZWZpeChwdWJsaWNJZCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5jbG91ZF9uYW1lICYmIG9wdGlvbnMuY2xvdWRfbmFtZVswXSA9PT0gJy8nKSB7XG4gICAgcmV0dXJuICcvcmVzJyArIG9wdGlvbnMuY2xvdWRfbmFtZTtcbiAgfVxuICAvLyBkZWZhdWx0c1xuICB2YXIgcHJvdG9jb2wgPSBcImh0dHA6Ly9cIjtcbiAgdmFyIGNkblBhcnQgPSBcIlwiO1xuICB2YXIgc3ViZG9tYWluID0gXCJyZXNcIjtcbiAgdmFyIGhvc3QgPSBcIi5jbG91ZGluYXJ5LmNvbVwiO1xuICB2YXIgcGF0aCA9IFwiL1wiICsgb3B0aW9ucy5jbG91ZF9uYW1lO1xuICAvLyBtb2RpZmljYXRpb25zXG4gIGlmIChvcHRpb25zLnByb3RvY29sKSB7XG4gICAgcHJvdG9jb2wgPSBvcHRpb25zLnByb3RvY29sICsgJy8vJztcbiAgfVxuICBpZiAob3B0aW9ucy5wcml2YXRlX2Nkbikge1xuICAgIGNkblBhcnQgPSBvcHRpb25zLmNsb3VkX25hbWUgKyBcIi1cIjtcbiAgICBwYXRoID0gXCJcIjtcbiAgfVxuICBpZiAob3B0aW9ucy5jZG5fc3ViZG9tYWluKSB7XG4gICAgc3ViZG9tYWluID0gXCJyZXMtXCIgKyBjZG5TdWJkb21haW5OdW1iZXIocHVibGljSWQpO1xuICB9XG4gIGlmIChvcHRpb25zLnNlY3VyZSkge1xuICAgIHByb3RvY29sID0gXCJodHRwczovL1wiO1xuICAgIGlmIChvcHRpb25zLnNlY3VyZV9jZG5fc3ViZG9tYWluID09PSBmYWxzZSkge1xuICAgICAgc3ViZG9tYWluID0gXCJyZXNcIjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc2VjdXJlX2Rpc3RyaWJ1dGlvbiAhPSBudWxsICYmIG9wdGlvbnMuc2VjdXJlX2Rpc3RyaWJ1dGlvbiAhPT0gT0xEX0FLQU1BSV9TSEFSRURfQ0ROICYmIG9wdGlvbnMuc2VjdXJlX2Rpc3RyaWJ1dGlvbiAhPT0gU0hBUkVEX0NETikge1xuICAgICAgY2RuUGFydCA9IFwiXCI7XG4gICAgICBzdWJkb21haW4gPSBcIlwiO1xuICAgICAgaG9zdCA9IG9wdGlvbnMuc2VjdXJlX2Rpc3RyaWJ1dGlvbjtcbiAgICB9XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5jbmFtZSkge1xuICAgIHByb3RvY29sID0gXCJodHRwOi8vXCI7XG4gICAgY2RuUGFydCA9IFwiXCI7XG4gICAgc3ViZG9tYWluID0gb3B0aW9ucy5jZG5fc3ViZG9tYWluID8gJ2EnICsgKHNyY19jcmMzMihwdWJsaWNJZCkgJSA1ICsgMSkgKyAnLicgOiAnJztcbiAgICBob3N0ID0gb3B0aW9ucy5jbmFtZTtcbiAgfVxuICByZXR1cm4gW3Byb3RvY29sLCBjZG5QYXJ0LCBzdWJkb21haW4sIGhvc3QsIHBhdGhdLmpvaW4oXCJcIik7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSByZXNvdXJjZSB0eXBlIGFuZCBhY3Rpb24gdHlwZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gY29uZmlndXJhdGlvblxuICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjaGFuZGxlUmVzb3VyY2VUeXBlXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IHJlc291cmNlX3R5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZT0ndXBsb2FkJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbdXJsX3N1ZmZpeF1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZV9yb290X3BhdGhdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzaG9ydGVuXVxuICogQHJldHVybnMge3N0cmluZ30gcmVzb3VyY2VfdHlwZS90eXBlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVJlc291cmNlVHlwZShfcmVmKSB7XG4gIHZhciBfcmVmJHJlc291cmNlX3R5cGUgPSBfcmVmLnJlc291cmNlX3R5cGUsXG4gICAgcmVzb3VyY2VfdHlwZSA9IF9yZWYkcmVzb3VyY2VfdHlwZSA9PT0gdm9pZCAwID8gXCJpbWFnZVwiIDogX3JlZiRyZXNvdXJjZV90eXBlLFxuICAgIF9yZWYkdHlwZSA9IF9yZWYudHlwZSxcbiAgICB0eXBlID0gX3JlZiR0eXBlID09PSB2b2lkIDAgPyBcInVwbG9hZFwiIDogX3JlZiR0eXBlLFxuICAgIHVybF9zdWZmaXggPSBfcmVmLnVybF9zdWZmaXgsXG4gICAgdXNlX3Jvb3RfcGF0aCA9IF9yZWYudXNlX3Jvb3RfcGF0aCxcbiAgICBzaG9ydGVuID0gX3JlZi5zaG9ydGVuO1xuICB2YXIgb3B0aW9ucyxcbiAgICByZXNvdXJjZVR5cGUgPSByZXNvdXJjZV90eXBlO1xuICBpZiAoaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfZGVmYXVsdCgpKHJlc291cmNlVHlwZSkpIHtcbiAgICBvcHRpb25zID0gcmVzb3VyY2VUeXBlO1xuICAgIHJlc291cmNlVHlwZSA9IG9wdGlvbnMucmVzb3VyY2VfdHlwZTtcbiAgICB0eXBlID0gb3B0aW9ucy50eXBlO1xuICAgIHNob3J0ZW4gPSBvcHRpb25zLnNob3J0ZW47XG4gIH1cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHR5cGUgPSAndXBsb2FkJztcbiAgfVxuICBpZiAodXJsX3N1ZmZpeCAhPSBudWxsKSB7XG4gICAgcmVzb3VyY2VUeXBlID0gU0VPX1RZUEVTW1wiXCIuY29uY2F0KHJlc291cmNlVHlwZSwgXCIvXCIpLmNvbmNhdCh0eXBlKV07XG4gICAgdHlwZSA9IG51bGw7XG4gICAgaWYgKHJlc291cmNlVHlwZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVUkwgU3VmZml4IG9ubHkgc3VwcG9ydGVkIGZvciBcIi5jb25jYXQoT2JqZWN0LmtleXMoU0VPX1RZUEVTKS5qb2luKCcsICcpKSk7XG4gICAgfVxuICB9XG4gIGlmICh1c2Vfcm9vdF9wYXRoKSB7XG4gICAgaWYgKHJlc291cmNlVHlwZSA9PT0gJ2ltYWdlJyAmJiB0eXBlID09PSAndXBsb2FkJyB8fCByZXNvdXJjZVR5cGUgPT09IFwiaW1hZ2VzXCIpIHtcbiAgICAgIHJlc291cmNlVHlwZSA9IG51bGw7XG4gICAgICB0eXBlID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vdCBwYXRoIG9ubHkgc3VwcG9ydGVkIGZvciBpbWFnZS91cGxvYWRcIik7XG4gICAgfVxuICB9XG4gIGlmIChzaG9ydGVuICYmIHJlc291cmNlVHlwZSA9PT0gJ2ltYWdlJyAmJiB0eXBlID09PSAndXBsb2FkJykge1xuICAgIHJlc291cmNlVHlwZSA9ICdpdSc7XG4gICAgdHlwZSA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIFtyZXNvdXJjZVR5cGUsIHR5cGVdLmpvaW4oXCIvXCIpO1xufVxuXG4vKipcbiAqIEVuY29kZSBwdWJsaWNJZFxuICogQHBhcmFtIHB1YmxpY0lkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBlbmNvZGVkIHB1YmxpY0lkXG4gKi9cbmZ1bmN0aW9uIGVuY29kZVB1YmxpY0lkKHB1YmxpY0lkKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQocHVibGljSWQpLnJlcGxhY2UoLyUzQS9nLCAnOicpLnJlcGxhY2UoLyUyRi9nLCAnLycpO1xufVxuXG4vKipcbiAqIEVuY29kZSBhbmQgZm9ybWF0IHB1YmxpY0lkXG4gKiBAcGFyYW0gcHVibGljSWRcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBwdWJsaWNJZFxuICovXG5mdW5jdGlvbiBmb3JtYXRQdWJsaWNJZChwdWJsaWNJZCwgb3B0aW9ucykge1xuICBpZiAoaXNVcmwocHVibGljSWQpKSB7XG4gICAgcHVibGljSWQgPSBlbmNvZGVQdWJsaWNJZChwdWJsaWNJZCk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIE1ha2Ugc3VyZSBwdWJsaWNJZCBpcyBVUkkgZW5jb2RlZC5cbiAgICAgIHB1YmxpY0lkID0gZGVjb2RlVVJJQ29tcG9uZW50KHB1YmxpY0lkKTtcbiAgICB9IGNhdGNoIChlcnJvcikge31cbiAgICBwdWJsaWNJZCA9IGVuY29kZVB1YmxpY0lkKHB1YmxpY0lkKTtcbiAgICBpZiAob3B0aW9ucy51cmxfc3VmZml4KSB7XG4gICAgICBwdWJsaWNJZCA9IHB1YmxpY0lkICsgJy8nICsgb3B0aW9ucy51cmxfc3VmZml4O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5mb3JtYXQpIHtcbiAgICAgIGlmICghb3B0aW9ucy50cnVzdF9wdWJsaWNfaWQpIHtcbiAgICAgICAgcHVibGljSWQgPSBwdWJsaWNJZC5yZXBsYWNlKC9cXC4oanBnfHBuZ3xnaWZ8d2VicCkkLywgJycpO1xuICAgICAgfVxuICAgICAgcHVibGljSWQgPSBwdWJsaWNJZCArICcuJyArIG9wdGlvbnMuZm9ybWF0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHVibGljSWQ7XG59XG5cbi8qKlxuICogR2V0IGFueSBlcnJvciB3aXRoIHVybCBvcHRpb25zXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnMge3N0cmluZ30gaWYgZXJyb3IsIG90aGVyd2lzZSByZXR1cm4gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlKG9wdGlvbnMpIHtcbiAgdmFyIGNsb3VkX25hbWUgPSBvcHRpb25zLmNsb3VkX25hbWUsXG4gICAgdXJsX3N1ZmZpeCA9IG9wdGlvbnMudXJsX3N1ZmZpeDtcbiAgaWYgKCFjbG91ZF9uYW1lKSB7XG4gICAgcmV0dXJuICdVbmtub3duIGNsb3VkX25hbWUnO1xuICB9XG4gIGlmICh1cmxfc3VmZml4ICYmIHVybF9zdWZmaXgubWF0Y2goL1tcXC5cXC9dLykpIHtcbiAgICByZXR1cm4gJ3VybF9zdWZmaXggc2hvdWxkIG5vdCBpbmNsdWRlIC4gb3IgLyc7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdmVyc2lvbiBwYXJ0IG9mIHRoZSB1cmxcbiAqIEBwYXJhbSBwdWJsaWNJZFxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVZlcnNpb24ocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgLy8gZm9yY2VfdmVyc2lvbiBwYXJhbSBtZWFucyB0byBtYWtlIHN1cmUgdGhlcmUgaXMgYSB2ZXJzaW9uIGluIHRoZSB1cmwgKERlZmF1bHQgaXMgdHJ1ZSlcbiAgdmFyIGlzRm9yY2VWZXJzaW9uID0gb3B0aW9ucy5mb3JjZV92ZXJzaW9uIHx8IHR5cGVvZiBvcHRpb25zLmZvcmNlX3ZlcnNpb24gPT09ICd1bmRlZmluZWQnO1xuXG4gIC8vIElzIHZlcnNpb24gaW5jbHVkZWQgaW4gcHVibGljSWQgb3IgaW4gb3B0aW9ucywgb3IgcHVibGljSWQgaXMgYSB1cmwgKGRvZXNuJ3QgbmVlZCB2ZXJzaW9uKVxuICB2YXIgaXNWZXJzaW9uRXhpc3QgPSBwdWJsaWNJZC5pbmRleE9mKCcvJykgPCAwIHx8IHB1YmxpY0lkLm1hdGNoKC9edlswLTldKy8pIHx8IGlzVXJsKHB1YmxpY0lkKSB8fCBvcHRpb25zLnZlcnNpb247XG4gIGlmIChpc0ZvcmNlVmVyc2lvbiAmJiAhaXNWZXJzaW9uRXhpc3QpIHtcbiAgICBvcHRpb25zLnZlcnNpb24gPSAxO1xuICB9XG4gIHJldHVybiBvcHRpb25zLnZlcnNpb24gPyBcInZcIi5jb25jYXQob3B0aW9ucy52ZXJzaW9uKSA6ICcnO1xufVxuXG4vKipcbiAqIEdldCBmaW5hbCB0cmFuc2Zvcm1hdGlvbiBjb21wb25lbnQgZm9yIHVybCBzdHJpbmdcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoYW5kbGVUcmFuc2Zvcm1hdGlvbihvcHRpb25zKSB7XG4gIHZhciBfcmVmMiA9IG9wdGlvbnMgfHwge30sXG4gICAgcGxhY2Vob2xkZXIgPSBfcmVmMi5wbGFjZWhvbGRlcixcbiAgICBhY2Nlc3NpYmlsaXR5ID0gX3JlZjIuYWNjZXNzaWJpbGl0eSxcbiAgICBvdGhlck9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIF9leGNsdWRlZCk7XG4gIHZhciByZXN1bHQgPSBuZXcgc3JjX3RyYW5zZm9ybWF0aW9uKG90aGVyT3B0aW9ucyk7XG5cbiAgLy8gQXBwZW5kIGFjY2Vzc2liaWxpdHkgdHJhbnNmb3JtYXRpb25zXG4gIGlmIChhY2Nlc3NpYmlsaXR5ICYmIEFDQ0VTU0lCSUxJVFlfTU9ERVNbYWNjZXNzaWJpbGl0eV0pIHtcbiAgICByZXN1bHQuY2hhaW4oKS5lZmZlY3QoQUNDRVNTSUJJTElUWV9NT0RFU1thY2Nlc3NpYmlsaXR5XSk7XG4gIH1cblxuICAvLyBBcHBlbmQgcGxhY2Vob2xkZXIgdHJhbnNmb3JtYXRpb25zXG4gIGlmIChwbGFjZWhvbGRlcikge1xuICAgIGlmIChwbGFjZWhvbGRlciA9PT0gXCJwcmVkb21pbmFudC1jb2xvclwiICYmIHJlc3VsdC5nZXRWYWx1ZSgnd2lkdGgnKSAmJiByZXN1bHQuZ2V0VmFsdWUoJ2hlaWdodCcpKSB7XG4gICAgICBwbGFjZWhvbGRlciArPSAnLXBpeGVsJztcbiAgICB9XG4gICAgdmFyIHBsYWNlaG9sZGVyVHJhbnNmb3JtYXRpb25zID0gUExBQ0VIT0xERVJfSU1BR0VfTU9ERVNbcGxhY2Vob2xkZXJdIHx8IFBMQUNFSE9MREVSX0lNQUdFX01PREVTLmJsdXI7XG4gICAgcGxhY2Vob2xkZXJUcmFuc2Zvcm1hdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5jaGFpbigpLnRyYW5zZm9ybWF0aW9uKHQpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQuc2VyaWFsaXplKCk7XG59XG5cbi8qKlxuICogSWYgdHlwZSBpcyAnZmV0Y2gnLCB1cGRhdGUgcHVibGljSWQgdG8gYmUgYSB1cmxcbiAqIEBwYXJhbSBwdWJsaWNJZFxuICogQHBhcmFtIHR5cGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHByZXBhcmVQdWJsaWNJZChwdWJsaWNJZCwgX3JlZjMpIHtcbiAgdmFyIHR5cGUgPSBfcmVmMy50eXBlO1xuICByZXR1cm4gIWlzVXJsKHB1YmxpY0lkKSAmJiB0eXBlID09PSAnZmV0Y2gnID8gbWFrZVVybChwdWJsaWNJZCkgOiBwdWJsaWNJZDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSB1cmwgc3RyaW5nXG4gKiBAcGFyYW0gcHVibGljSWRcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBmaW5hbCB1cmxcbiAqL1xuZnVuY3Rpb24gdXJsU3RyaW5nKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gIGlmIChpc1VybChwdWJsaWNJZCkgJiYgKG9wdGlvbnMudHlwZSA9PT0gJ3VwbG9hZCcgfHwgb3B0aW9ucy50eXBlID09PSAnYXNzZXQnKSkge1xuICAgIHJldHVybiBwdWJsaWNJZDtcbiAgfVxuICB2YXIgdmVyc2lvbiA9IGhhbmRsZVZlcnNpb24ocHVibGljSWQsIG9wdGlvbnMpO1xuICB2YXIgdHJhbnNmb3JtYXRpb25TdHJpbmcgPSBoYW5kbGVUcmFuc2Zvcm1hdGlvbihvcHRpb25zKTtcbiAgdmFyIHByZWZpeCA9IGhhbmRsZVByZWZpeChwdWJsaWNJZCwgb3B0aW9ucyk7XG4gIHZhciBzaWduYXR1cmUgPSBoYW5kbGVTaWduYXR1cmUob3B0aW9ucyk7XG4gIHZhciByZXNvdXJjZVR5cGUgPSBoYW5kbGVSZXNvdXJjZVR5cGUob3B0aW9ucyk7XG4gIHB1YmxpY0lkID0gZm9ybWF0UHVibGljSWQocHVibGljSWQsIG9wdGlvbnMpO1xuICByZXR1cm4gY29tcGFjdF9yb290X2NvbXBhY3RfZGVmYXVsdCgpKFtwcmVmaXgsIHJlc291cmNlVHlwZSwgc2lnbmF0dXJlLCB0cmFuc2Zvcm1hdGlvblN0cmluZywgdmVyc2lvbiwgcHVibGljSWRdKS5qb2luKCcvJykucmVwbGFjZSgvKFteOl0pXFwvKy9nLCAnJDEvJykgLy8gcmVwbGFjZSAnLy8vJyB3aXRoICcvLydcbiAgLnJlcGxhY2UoJyAnLCAnJTIwJyk7XG59XG5cbi8qKlxuICogTWVyZ2Ugb3B0aW9ucyBhbmQgY29uZmlnIHdpdGggZGVmYXVsdHNcbiAqIHVwZGF0ZSBvcHRpb25zIGZldGNoX2Zvcm1hdCBhY2NvcmRpbmcgdG8gJ3R5cGUnIHBhcmFtXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIGNvbmZpZ1xuICogQHJldHVybnMgeyp9IHVwZGF0ZWQgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBwcmVwYXJlT3B0aW9ucyhvcHRpb25zLCBjb25maWcpIHtcbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBzcmNfdHJhbnNmb3JtYXRpb24pIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucy50b09wdGlvbnMoKTtcbiAgfVxuICBvcHRpb25zID0gZGVmYXVsdHMoe30sIG9wdGlvbnMsIGNvbmZpZywgREVGQVVMVF9JTUFHRV9QQVJBTVMpO1xuICBpZiAob3B0aW9ucy50eXBlID09PSAnZmV0Y2gnKSB7XG4gICAgb3B0aW9ucy5mZXRjaF9mb3JtYXQgPSBvcHRpb25zLmZldGNoX2Zvcm1hdCB8fCBvcHRpb25zLmZvcm1hdDtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBVUkwgZm9yIGFueSBhc3NldCBpbiB5b3VyIE1lZGlhIGxpYnJhcnkuXG4gKiBAZnVuY3Rpb24gdXJsXG4gKiBAaWdub3JlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgcHVibGljIElEIG9mIHRoZSBtZWRpYSBhc3NldC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzIHRvIGluY2x1ZGUgaW4gdGhlIFVSTC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbY29uZmlnPXt9XSAtIFVSTCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7dHlwZX0gW29wdGlvbnMudHlwZT0ndXBsb2FkJ10gLSBUaGUgYXNzZXQncyBzdG9yYWdlIHR5cGUuXG4gKiAgRm9yIGRldGFpbHMgb24gYWxsIGZldGNoIHR5cGVzLCBzZWVcbiAqIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25zI2ZldGNoaW5nX2ltYWdlc19mcm9tX3JlbW90ZV9sb2NhdGlvbnNcIlxuICogIHRhcmdldD1cIl9ibGFua1wiPkZldGNoIHR5cGVzPC9hPi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5yZXNvdXJjZV90eXBlPSdpbWFnZSddIC0gVGhlIHR5cGUgb2YgYXNzZXQuIDxwPlBvc3NpYmxlIHZhbHVlczo8YnIvPlxuICogIC0gYGltYWdlYDxici8+XG4gKiAgLSBgdmlkZW9gPGJyLz5cbiAqICAtIGByYXdgXG4gKiBAcGFyYW0ge3NpZ25hdHVyZX0gW29wdGlvbnMuc2lnbmF0dXJlPSdzLS0xMjM0NTY3OC0tJ10gLSBUaGUgc2lnbmF0dXJlIGNvbXBvbmVudCBvZiBhXG4gKiAgc2lnbmVkIGRlbGl2ZXJ5IFVSTCBvZiB0aGUgZm9ybWF0OiAvcy0tU0lHTkFUVVJFLS0vLlxuICogIEZvciBkZXRhaWxzIG9uIHNpZ25hdHVyZXMsIHNlZVxuICogPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zaWduYXR1cmVzXCIgdGFyZ2V0PVwiX2JsYW5rXCI+U2lnbmF0dXJlczwvYT4uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBtZWRpYSBhc3NldCBVUkwuXG4gKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gKiAgQXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi92aWRlb190cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAqICBBdmFpbGFibGUgdmlkZW8gdHJhbnNmb3JtYXRpb25zPC9hPlxuICovXG5mdW5jdGlvbiB1cmxfdXJsKHB1YmxpY0lkKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIGNvbmZpZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIGlmICghcHVibGljSWQpIHtcbiAgICByZXR1cm4gcHVibGljSWQ7XG4gIH1cbiAgb3B0aW9ucyA9IHByZXBhcmVPcHRpb25zKG9wdGlvbnMsIGNvbmZpZyk7XG4gIHB1YmxpY0lkID0gcHJlcGFyZVB1YmxpY0lkKHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgdmFyIGVycm9yID0gdmFsaWRhdGUob3B0aW9ucyk7XG4gIGlmIChlcnJvcikge1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIHZhciByZXN1bHRVcmwgPSB1cmxTdHJpbmcocHVibGljSWQsIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy51cmxBbmFseXRpY3MpIHtcbiAgICB2YXIgYW5hbHl0aWNzT3B0aW9ucyA9IGdldEFuYWx5dGljc09wdGlvbnMob3B0aW9ucyk7XG4gICAgdmFyIHNka0FuYWx5dGljc1NpZ25hdHVyZSA9IGdldFNES0FuYWx5dGljc1NpZ25hdHVyZShhbmFseXRpY3NPcHRpb25zKTtcbiAgICAvLyB1cmwgbWlnaHQgYWxyZWFkeSBoYXZlIGEgJz8nIHF1ZXJ5IHBhcmFtXG4gICAgdmFyIGFwcGVuZGVyID0gJz8nO1xuICAgIGlmIChyZXN1bHRVcmwuaW5kZXhPZignPycpID49IDApIHtcbiAgICAgIGFwcGVuZGVyID0gJyYnO1xuICAgIH1cbiAgICByZXN1bHRVcmwgPSBcIlwiLmNvbmNhdChyZXN1bHRVcmwpLmNvbmNhdChhcHBlbmRlciwgXCJfYT1cIikuY29uY2F0KHNka0FuYWx5dGljc1NpZ25hdHVyZSk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuYXV0aF90b2tlbikge1xuICAgIHZhciBfYXBwZW5kZXIgPSByZXN1bHRVcmwuaW5kZXhPZignPycpID49IDAgPyAnJicgOiAnPyc7XG4gICAgcmVzdWx0VXJsID0gXCJcIi5jb25jYXQocmVzdWx0VXJsKS5jb25jYXQoX2FwcGVuZGVyLCBcIl9fY2xkX3Rva2VuX189XCIpLmNvbmNhdChvcHRpb25zLmF1dGhfdG9rZW4pO1xuICB9XG4gIHJldHVybiByZXN1bHRVcmw7XG59XG47XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2dlbmVyYXRlQnJlYWtwb2ludHMuanNcbmZ1bmN0aW9uIGdlbmVyYXRlQnJlYWtwb2ludHNfc2xpY2VkVG9BcnJheShyLCBlKSB7IHJldHVybiBnZW5lcmF0ZUJyZWFrcG9pbnRzX2FycmF5V2l0aEhvbGVzKHIpIHx8IGdlbmVyYXRlQnJlYWtwb2ludHNfaXRlcmFibGVUb0FycmF5TGltaXQociwgZSkgfHwgZ2VuZXJhdGVCcmVha3BvaW50c191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBlKSB8fCBnZW5lcmF0ZUJyZWFrcG9pbnRzX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5mdW5jdGlvbiBnZW5lcmF0ZUJyZWFrcG9pbnRzX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gZ2VuZXJhdGVCcmVha3BvaW50c191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7IGlmIChyKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gZ2VuZXJhdGVCcmVha3BvaW50c19hcnJheUxpa2VUb0FycmF5KHIsIGEpOyB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpOyByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBnZW5lcmF0ZUJyZWFrcG9pbnRzX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7IH0gfVxuZnVuY3Rpb24gZ2VuZXJhdGVCcmVha3BvaW50c19hcnJheUxpa2VUb0FycmF5KHIsIGEpIHsgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpOyBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTsgcmV0dXJuIG47IH1cbmZ1bmN0aW9uIGdlbmVyYXRlQnJlYWtwb2ludHNfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkgeyB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSB0KSB7IHZhciBlLCBuLCBpLCB1LCBhID0gW10sIGYgPSAhMCwgbyA9ICExOyB0cnkgeyBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7IGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjsgZiA9ICExOyB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7IH0gY2F0Y2ggKHIpIHsgbyA9ICEwLCBuID0gcjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cbmZ1bmN0aW9uIGdlbmVyYXRlQnJlYWtwb2ludHNfYXJyYXlXaXRoSG9sZXMocikgeyBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIHI7IH1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uLiBHZXRzIG9yIHBvcHVsYXRlcyBzcmNzZXQgYnJlYWtwb2ludHMgdXNpbmcgcHJvdmlkZWQgcGFyYW1ldGVyc1xuICogRWl0aGVyIHRoZSBicmVha3BvaW50cyBvciBtaW5fd2lkdGgsIG1heF93aWR0aCwgbWF4X2ltYWdlcyBtdXN0IGJlIHByb3ZpZGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3NyY3NldH0gc3Jjc2V0IE9wdGlvbnMgd2l0aCBlaXRoZXIgYGJyZWFrcG9pbnRzYCBvciBgbWluX3dpZHRoYCwgYG1heF93aWR0aGAsIGFuZCBgbWF4X2ltYWdlc2BcbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJbXX0gQXJyYXkgb2YgYnJlYWtwb2ludHNcbiAqXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlQnJlYWtwb2ludHMoc3Jjc2V0KSB7XG4gIHZhciBicmVha3BvaW50cyA9IHNyY3NldC5icmVha3BvaW50cyB8fCBbXTtcbiAgaWYgKGJyZWFrcG9pbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBicmVha3BvaW50cztcbiAgfVxuICB2YXIgX21hcCA9IFtzcmNzZXQubWluX3dpZHRoLCBzcmNzZXQubWF4X3dpZHRoLCBzcmNzZXQubWF4X2ltYWdlc10ubWFwKE51bWJlciksXG4gICAgX21hcDIgPSBnZW5lcmF0ZUJyZWFrcG9pbnRzX3NsaWNlZFRvQXJyYXkoX21hcCwgMyksXG4gICAgbWluX3dpZHRoID0gX21hcDJbMF0sXG4gICAgbWF4X3dpZHRoID0gX21hcDJbMV0sXG4gICAgbWF4X2ltYWdlcyA9IF9tYXAyWzJdO1xuICBpZiAoW21pbl93aWR0aCwgbWF4X3dpZHRoLCBtYXhfaW1hZ2VzXS5zb21lKGlzTmFOKSkge1xuICAgIHRocm93ICdFaXRoZXIgKG1pbl93aWR0aCwgbWF4X3dpZHRoLCBtYXhfaW1hZ2VzKSAnICsgJ29yIGJyZWFrcG9pbnRzIG11c3QgYmUgcHJvdmlkZWQgdG8gdGhlIGltYWdlIHNyY3NldCBhdHRyaWJ1dGUnO1xuICB9XG4gIGlmIChtaW5fd2lkdGggPiBtYXhfd2lkdGgpIHtcbiAgICB0aHJvdyAnbWluX3dpZHRoIG11c3QgYmUgbGVzcyB0aGFuIG1heF93aWR0aCc7XG4gIH1cbiAgaWYgKG1heF9pbWFnZXMgPD0gMCkge1xuICAgIHRocm93ICdtYXhfaW1hZ2VzIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJztcbiAgfSBlbHNlIGlmIChtYXhfaW1hZ2VzID09PSAxKSB7XG4gICAgbWluX3dpZHRoID0gbWF4X3dpZHRoO1xuICB9XG4gIHZhciBzdGVwU2l6ZSA9IE1hdGguY2VpbCgobWF4X3dpZHRoIC0gbWluX3dpZHRoKSAvIE1hdGgubWF4KG1heF9pbWFnZXMgLSAxLCAxKSk7XG4gIGZvciAodmFyIGN1cnJlbnQgPSBtaW5fd2lkdGg7IGN1cnJlbnQgPCBtYXhfd2lkdGg7IGN1cnJlbnQgKz0gc3RlcFNpemUpIHtcbiAgICBicmVha3BvaW50cy5wdXNoKGN1cnJlbnQpO1xuICB9XG4gIGJyZWFrcG9pbnRzLnB1c2gobWF4X3dpZHRoKTtcbiAgcmV0dXJuIGJyZWFrcG9pbnRzO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9zcmNzZXRVdGlscy5qc1xuXG52YXIgc3Jjc2V0VXRpbHNfaXNFbXB0eSA9IGlzRW1wdHk7XG5cblxuXG5cbi8qKlxuICogT3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSBzcmNzZXQgYXR0cmlidXRlLlxuICogQHR5cGVkZWYge29iamVjdH0gc3Jjc2V0XG4gKiBAcHJvcGVydHkgeyhudW1iZXJbXXxzdHJpbmdbXSl9ICAgW2JyZWFrcG9pbnRzXSBBbiBhcnJheSBvZiBicmVha3BvaW50cy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgICAgICAgICAgICAgICBbbWluX3dpZHRoXSAgIE1pbmltYWwgd2lkdGggb2YgdGhlIHNyY3NldCBpbWFnZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gICAgICAgICAgICAgICAgW21heF93aWR0aF0gICBNYXhpbWFsIHdpZHRoIG9mIHRoZSBzcmNzZXQgaW1hZ2VzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9ICAgICAgICAgICAgICAgIFttYXhfaW1hZ2VzXSAgTnVtYmVyIG9mIHNyY3NldCBpbWFnZXMgdG8gZ2VuZXJhdGUuXG4gKiBAcHJvcGVydHkge29iamVjdHxzdHJpbmd9ICAgICAgICAgW3RyYW5zZm9ybWF0aW9uXSBUaGUgdHJhbnNmb3JtYXRpb24gdG8gdXNlIGluIHRoZSBzcmNzZXQgdXJscy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gICAgICAgICAgICAgICBbc2l6ZXNdIFdoZXRoZXIgdG8gY2FsY3VsYXRlIGFuZCBhZGQgdGhlIHNpemVzIGF0dHJpYnV0ZS5cbiAqL1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbi4gR2VuZXJhdGVzIGEgc2luZ2xlIHNyY3NldCBpdGVtIHVybFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHVibGljX2lkICBQdWJsaWMgSUQgb2YgdGhlIHJlc291cmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoICAgICAgV2lkdGggaW4gcGl4ZWxzIG9mIHRoZSBzcmNzZXQgaXRlbS5cbiAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gdHJhbnNmb3JtYXRpb25cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICAgIEFkZGl0aW9uYWwgb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJlc3VsdGluZyBVUkwgb2YgdGhlIGl0ZW1cbiAqL1xuZnVuY3Rpb24gc2NhbGVkVXJsKHB1YmxpY19pZCwgd2lkdGgsIHRyYW5zZm9ybWF0aW9uKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgdmFyIGNvbmZpZ1BhcmFtcyA9IGV4dHJhY3RVcmxQYXJhbXMob3B0aW9ucyk7XG4gIHRyYW5zZm9ybWF0aW9uID0gdHJhbnNmb3JtYXRpb24gfHwgb3B0aW9ucztcbiAgY29uZmlnUGFyYW1zLnJhd190cmFuc2Zvcm1hdGlvbiA9IG5ldyBzcmNfdHJhbnNmb3JtYXRpb24oW21lcmdlX3Jvb3RfbWVyZ2VfZGVmYXVsdC5hKHt9LCB0cmFuc2Zvcm1hdGlvbiksIHtcbiAgICBjcm9wOiAnc2NhbGUnLFxuICAgIHdpZHRoOiB3aWR0aFxuICB9XSkudG9TdHJpbmcoKTtcbiAgcmV0dXJuIHVybF91cmwocHVibGljX2lkLCBjb25maWdQYXJhbXMpO1xufVxuXG4vKipcbiAqIElmIGNhY2hlIGlzIGVuYWJsZWQsIGdldCB0aGUgYnJlYWtwb2ludHMgZnJvbSB0aGUgY2FjaGUuIElmIHRoZSB2YWx1ZXMgd2VyZSBub3QgZm91bmQgaW4gdGhlIGNhY2hlLFxuICogb3IgY2FjaGUgaXMgbm90IGVuYWJsZWQsIGdlbmVyYXRlIHRoZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge3NyY3NldH0gc3Jjc2V0IFRoZSBzcmNzZXQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gcHVibGljX2lkXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7KnxBcnJheX1cbiAqL1xuZnVuY3Rpb24gZ2V0T3JHZW5lcmF0ZUJyZWFrcG9pbnRzKHB1YmxpY19pZCkge1xuICB2YXIgc3Jjc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICByZXR1cm4gZ2VuZXJhdGVCcmVha3BvaW50cyhzcmNzZXQpO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbi4gR2VuZXJhdGVzIHNyY3NldCBhdHRyaWJ1dGUgdmFsdWUgb2YgdGhlIEhUTUwgaW1nIHRhZ1xuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHVibGljX2lkICBQdWJsaWMgSUQgb2YgdGhlIHJlc291cmNlXG4gKiBAcGFyYW0ge251bWJlcltdfSBicmVha3BvaW50cyBBbiBhcnJheSBvZiBicmVha3BvaW50cyAoaW4gcGl4ZWxzKVxuICogQHBhcmFtIHtvYmplY3R9IHRyYW5zZm9ybWF0aW9uIFRoZSB0cmFuc2Zvcm1hdGlvblxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgSW5jbHVkZXMgaHRtbCB0YWcgb3B0aW9ucywgdHJhbnNmb3JtYXRpb24gb3B0aW9uc1xuICogQHJldHVybiB7c3RyaW5nfSBSZXN1bHRpbmcgc3Jjc2V0IGF0dHJpYnV0ZSB2YWx1ZVxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVNyY3NldEF0dHJpYnV0ZShwdWJsaWNfaWQsIGJyZWFrcG9pbnRzLCB0cmFuc2Zvcm1hdGlvbiwgb3B0aW9ucykge1xuICBvcHRpb25zID0gY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwX2RlZmF1bHQuYShvcHRpb25zKTtcbiAgcGF0Y2hGZXRjaEZvcm1hdChvcHRpb25zKTtcbiAgcmV0dXJuIGJyZWFrcG9pbnRzLm1hcChmdW5jdGlvbiAod2lkdGgpIHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoc2NhbGVkVXJsKHB1YmxpY19pZCwgd2lkdGgsIHRyYW5zZm9ybWF0aW9uLCBvcHRpb25zKSwgXCIgXCIpLmNvbmNhdCh3aWR0aCwgXCJ3XCIpO1xuICB9KS5qb2luKCcsICcpO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbi4gR2VuZXJhdGVzIHNpemVzIGF0dHJpYnV0ZSB2YWx1ZSBvZiB0aGUgSFRNTCBpbWcgdGFnXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJbXX0gYnJlYWtwb2ludHMgQW4gYXJyYXkgb2YgYnJlYWtwb2ludHMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJlc3VsdGluZyBzaXplcyBhdHRyaWJ1dGUgdmFsdWVcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVTaXplc0F0dHJpYnV0ZShicmVha3BvaW50cykge1xuICBpZiAoYnJlYWtwb2ludHMgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gYnJlYWtwb2ludHMubWFwKGZ1bmN0aW9uICh3aWR0aCkge1xuICAgIHJldHVybiBcIihtYXgtd2lkdGg6IFwiLmNvbmNhdCh3aWR0aCwgXCJweCkgXCIpLmNvbmNhdCh3aWR0aCwgXCJweFwiKTtcbiAgfSkuam9pbignLCAnKTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24uIEdlbmVyYXRlcyBzcmNzZXQgYW5kIHNpemVzIGF0dHJpYnV0ZXMgb2YgdGhlIGltYWdlIHRhZ1xuICpcbiAqIEdlbmVyYXRlZCBhdHRyaWJ1dGVzIGFyZSBhZGRlZCB0byBhdHRyaWJ1dGVzIGFyZ3VtZW50XG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICBwdWJsaWNJZCAgVGhlIHB1YmxpYyBJRCBvZiB0aGUgcmVzb3VyY2VcbiAqIEBwYXJhbSB7b2JqZWN0fSAgICBhdHRyaWJ1dGVzIEV4aXN0aW5nIEhUTUwgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7c3Jjc2V0fSAgICBzcmNzZXREYXRhXG4gKiBAcGFyYW0ge29iamVjdH0gICAgb3B0aW9ucyAgICBBZGRpdGlvbmFsIG9wdGlvbnMuXG4gKlxuICogQHJldHVybiBhcnJheSBUaGUgcmVzcG9uc2l2ZSBhdHRyaWJ1dGVzXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VSZXNwb25zaXZlQXR0cmlidXRlcyhwdWJsaWNJZCkge1xuICB2YXIgYXR0cmlidXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBzcmNzZXREYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAvLyBDcmVhdGUgYm90aCBzcmNzZXQgYW5kIHNpemVzIGhlcmUgdG8gYXZvaWQgZmV0Y2hpbmcgYnJlYWtwb2ludHMgdHdpY2VcblxuICB2YXIgcmVzcG9uc2l2ZUF0dHJpYnV0ZXMgPSB7fTtcbiAgaWYgKHNyY3NldFV0aWxzX2lzRW1wdHkoc3Jjc2V0RGF0YSkpIHtcbiAgICByZXR1cm4gcmVzcG9uc2l2ZUF0dHJpYnV0ZXM7XG4gIH1cbiAgdmFyIGdlbmVyYXRlU2l6ZXMgPSAhYXR0cmlidXRlcy5zaXplcyAmJiBzcmNzZXREYXRhLnNpemVzID09PSB0cnVlO1xuICB2YXIgZ2VuZXJhdGVTcmNzZXQgPSAhYXR0cmlidXRlcy5zcmNzZXQ7XG4gIGlmIChnZW5lcmF0ZVNyY3NldCB8fCBnZW5lcmF0ZVNpemVzKSB7XG4gICAgdmFyIGJyZWFrcG9pbnRzID0gZ2V0T3JHZW5lcmF0ZUJyZWFrcG9pbnRzKHB1YmxpY0lkLCBzcmNzZXREYXRhLCBvcHRpb25zKTtcbiAgICBpZiAoZ2VuZXJhdGVTcmNzZXQpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1hdGlvbiA9IHNyY3NldERhdGEudHJhbnNmb3JtYXRpb247XG4gICAgICB2YXIgc3Jjc2V0QXR0ciA9IGdlbmVyYXRlU3Jjc2V0QXR0cmlidXRlKHB1YmxpY0lkLCBicmVha3BvaW50cywgdHJhbnNmb3JtYXRpb24sIG9wdGlvbnMpO1xuICAgICAgaWYgKCFzcmNzZXRVdGlsc19pc0VtcHR5KHNyY3NldEF0dHIpKSB7XG4gICAgICAgIHJlc3BvbnNpdmVBdHRyaWJ1dGVzLnNyY3NldCA9IHNyY3NldEF0dHI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChnZW5lcmF0ZVNpemVzKSB7XG4gICAgICB2YXIgc2l6ZXNBdHRyID0gZ2VuZXJhdGVTaXplc0F0dHJpYnV0ZShicmVha3BvaW50cyk7XG4gICAgICBpZiAoIXNyY3NldFV0aWxzX2lzRW1wdHkoc2l6ZXNBdHRyKSkge1xuICAgICAgICByZXNwb25zaXZlQXR0cmlidXRlcy5zaXplcyA9IHNpemVzQXR0cjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3BvbnNpdmVBdHRyaWJ1dGVzO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgbWVkaWEgcXVlcnlcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG9wdGlvbnMubWluX3dpZHRoXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG9wdGlvbnMubWF4X3dpZHRoXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGEgbWVkaWEgcXVlcnkgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlTWVkaWFBdHRyKG9wdGlvbnMpIHtcbiAgdmFyIG1lZGlhUXVlcnkgPSBbXTtcbiAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgIGlmIChvcHRpb25zLm1pbl93aWR0aCAhPSBudWxsKSB7XG4gICAgICBtZWRpYVF1ZXJ5LnB1c2goXCIobWluLXdpZHRoOiBcIi5jb25jYXQob3B0aW9ucy5taW5fd2lkdGgsIFwicHgpXCIpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubWF4X3dpZHRoICE9IG51bGwpIHtcbiAgICAgIG1lZGlhUXVlcnkucHVzaChcIihtYXgtd2lkdGg6IFwiLmNvbmNhdChvcHRpb25zLm1heF93aWR0aCwgXCJweClcIikpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVkaWFRdWVyeS5qb2luKCcgYW5kICcpO1xufVxudmFyIHNyY3NldFVybCA9IHNjYWxlZFVybDtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3RhZ3MvaW1hZ2V0YWcuanNcbmZ1bmN0aW9uIGltYWdldGFnX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIGltYWdldGFnX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBpbWFnZXRhZ190eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIGltYWdldGFnX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiBpbWFnZXRhZ19kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIGltYWdldGFnX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTsgfSB9XG5mdW5jdGlvbiBpbWFnZXRhZ19jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIGltYWdldGFnX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIGltYWdldGFnX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTsgfVxuZnVuY3Rpb24gaW1hZ2V0YWdfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gaW1hZ2V0YWdfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IGltYWdldGFnX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gaW1hZ2V0YWdfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBpbWFnZXRhZ190eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gaW1hZ2V0YWdfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbmZ1bmN0aW9uIGltYWdldGFnX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gaW1hZ2V0YWdfZ2V0UHJvdG90eXBlT2YobyksIGltYWdldGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgaW1hZ2V0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBpbWFnZXRhZ19nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuZnVuY3Rpb24gaW1hZ2V0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBlKSB7IGlmIChlICYmIChcIm9iamVjdFwiID09IGltYWdldGFnX3R5cGVvZihlKSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUpKSByZXR1cm4gZTsgaWYgKHZvaWQgMCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyByZXR1cm4gaW1hZ2V0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHQpOyB9XG5mdW5jdGlvbiBpbWFnZXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoZSkgeyBpZiAodm9pZCAwID09PSBlKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IHJldHVybiBlOyB9XG5mdW5jdGlvbiBpbWFnZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChpbWFnZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG5mdW5jdGlvbiBpbWFnZXRhZ19zdXBlclByb3BHZXQodCwgbywgZSwgcikgeyB2YXIgcCA9IGltYWdldGFnX2dldChpbWFnZXRhZ19nZXRQcm90b3R5cGVPZigxICYgciA/IHQucHJvdG90eXBlIDogdCksIG8sIGUpOyByZXR1cm4gMiAmIHIgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBwID8gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHAuYXBwbHkoZSwgdCk7IH0gOiBwOyB9XG5mdW5jdGlvbiBpbWFnZXRhZ19nZXQoKSB7IHJldHVybiBpbWFnZXRhZ19nZXQgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBSZWZsZWN0ICYmIFJlZmxlY3QuZ2V0ID8gUmVmbGVjdC5nZXQuYmluZCgpIDogZnVuY3Rpb24gKGUsIHQsIHIpIHsgdmFyIHAgPSBpbWFnZXRhZ19zdXBlclByb3BCYXNlKGUsIHQpOyBpZiAocCkgeyB2YXIgbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocCwgdCk7IHJldHVybiBuLmdldCA/IG4uZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBlIDogcikgOiBuLnZhbHVlOyB9IH0sIGltYWdldGFnX2dldC5hcHBseShudWxsLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBpbWFnZXRhZ19zdXBlclByb3BCYXNlKHQsIG8pIHsgZm9yICg7ICF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIG8pICYmIG51bGwgIT09ICh0ID0gaW1hZ2V0YWdfZ2V0UHJvdG90eXBlT2YodCkpOyk7IHJldHVybiB0OyB9XG5mdW5jdGlvbiBpbWFnZXRhZ19nZXRQcm90b3R5cGVPZih0KSB7IHJldHVybiBpbWFnZXRhZ19nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpOyB9LCBpbWFnZXRhZ19nZXRQcm90b3R5cGVPZih0KTsgfVxuZnVuY3Rpb24gaW1hZ2V0YWdfaW5oZXJpdHModCwgZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlICYmIG51bGwgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHQsIHdyaXRhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCB9IH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGUgJiYgaW1hZ2V0YWdfc2V0UHJvdG90eXBlT2YodCwgZSk7IH1cbmZ1bmN0aW9uIGltYWdldGFnX3NldFByb3RvdHlwZU9mKHQsIGUpIHsgcmV0dXJuIGltYWdldGFnX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0LCBlKSB7IHJldHVybiB0Ll9fcHJvdG9fXyA9IGUsIHQ7IH0sIGltYWdldGFnX3NldFByb3RvdHlwZU9mKHQsIGUpOyB9XG4vKipcbiAqIEltYWdlIFRhZ1xuICogRGVwZW5kcyBvbiAndGFncy9odG1sdGFnJywgJ2Nsb3VkaW5hcnknXG4gKi9cblxuXG5cblxuXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBIVE1MIChET00pIEltYWdlIHRhZyB1c2luZyBDbG91ZGluYXJ5IGFzIHRoZSBzb3VyY2UuXG4gKiBAY29uc3RydWN0b3IgSW1hZ2VUYWdcbiAqIEBleHRlbmRzIEh0bWxUYWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHVibGljSWRdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKi9cbnZhciBpbWFnZXRhZ19JbWFnZVRhZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0h0bWxUYWcpIHtcbiAgZnVuY3Rpb24gSW1hZ2VUYWcocHVibGljSWQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgaW1hZ2V0YWdfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW1hZ2VUYWcpO1xuICAgIHJldHVybiBpbWFnZXRhZ19jYWxsU3VwZXIodGhpcywgSW1hZ2VUYWcsIFtcImltZ1wiLCBwdWJsaWNJZCwgb3B0aW9uc10pO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBpbWFnZXRhZ19pbmhlcml0cyhJbWFnZVRhZywgX0h0bWxUYWcpO1xuICByZXR1cm4gaW1hZ2V0YWdfY3JlYXRlQ2xhc3MoSW1hZ2VUYWcsIFt7XG4gICAga2V5OiBcImNsb3NlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlVGFnKCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICB9LCB7XG4gICAga2V5OiBcImF0dHJpYnV0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlcygpIHtcbiAgICAgIHZhciBhdHRyLCBvcHRpb25zLCBzcmNBdHRyaWJ1dGU7XG4gICAgICBhdHRyID0gaW1hZ2V0YWdfc3VwZXJQcm9wR2V0KEltYWdlVGFnLCBcImF0dHJpYnV0ZXNcIiwgdGhpcywgMykoW10pIHx8IHt9O1xuICAgICAgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmdldE9wdGlvbignYXR0cmlidXRlcycpIHx8IHt9O1xuICAgICAgdmFyIHNyY3NldFBhcmFtID0gdGhpcy5nZXRPcHRpb24oJ3NyY3NldCcpIHx8IGF0dHJpYnV0ZXMuc3Jjc2V0O1xuICAgICAgdmFyIHJlc3BvbnNpdmVBdHRyaWJ1dGVzID0ge307XG4gICAgICBpZiAoaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkoc3Jjc2V0UGFyYW0pKSB7XG4gICAgICAgIHJlc3BvbnNpdmVBdHRyaWJ1dGVzLnNyY3NldCA9IHNyY3NldFBhcmFtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzcG9uc2l2ZUF0dHJpYnV0ZXMgPSBnZW5lcmF0ZUltYWdlUmVzcG9uc2l2ZUF0dHJpYnV0ZXModGhpcy5wdWJsaWNJZCwgYXR0cmlidXRlcywgc3Jjc2V0UGFyYW0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0VtcHR5KHJlc3BvbnNpdmVBdHRyaWJ1dGVzKSkge1xuICAgICAgICBkZWxldGUgYXR0ci53aWR0aDtcbiAgICAgICAgZGVsZXRlIGF0dHIuaGVpZ2h0O1xuICAgICAgfVxuICAgICAgbWVyZ2Vfcm9vdF9tZXJnZV9kZWZhdWx0KCkoYXR0ciwgcmVzcG9uc2l2ZUF0dHJpYnV0ZXMpO1xuICAgICAgc3JjQXR0cmlidXRlID0gb3B0aW9ucy5yZXNwb25zaXZlICYmICFvcHRpb25zLmNsaWVudF9oaW50cyA/ICdkYXRhLXNyYycgOiAnc3JjJztcbiAgICAgIGlmIChhdHRyW3NyY0F0dHJpYnV0ZV0gPT0gbnVsbCkge1xuICAgICAgICBhdHRyW3NyY0F0dHJpYnV0ZV0gPSB1cmxfdXJsKHRoaXMucHVibGljSWQsIHRoaXMuZ2V0T3B0aW9ucygpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyO1xuICAgIH1cbiAgfV0pO1xufShodG1sdGFnKTtcbjtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGltYWdldGFnID0gKGltYWdldGFnX0ltYWdlVGFnKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3RhZ3Mvc291cmNldGFnLmpzXG5mdW5jdGlvbiBzb3VyY2V0YWdfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gc291cmNldGFnX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBzb3VyY2V0YWdfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBzb3VyY2V0YWdfY2xhc3NDYWxsQ2hlY2soYSwgbikgeyBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH1cbmZ1bmN0aW9uIHNvdXJjZXRhZ19kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHNvdXJjZXRhZ190b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7IH0gfVxuZnVuY3Rpb24gc291cmNldGFnX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHsgcmV0dXJuIHIgJiYgc291cmNldGFnX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIHNvdXJjZXRhZ19kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7IH1cbmZ1bmN0aW9uIHNvdXJjZXRhZ190b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBzb3VyY2V0YWdfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IHNvdXJjZXRhZ190eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIHNvdXJjZXRhZ190b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IHNvdXJjZXRhZ190eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gc291cmNldGFnX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiBzb3VyY2V0YWdfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBzb3VyY2V0YWdfZ2V0UHJvdG90eXBlT2YobyksIHNvdXJjZXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIHNvdXJjZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIHNvdXJjZXRhZ19nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuZnVuY3Rpb24gc291cmNldGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgZSkgeyBpZiAoZSAmJiAoXCJvYmplY3RcIiA9PSBzb3VyY2V0YWdfdHlwZW9mKGUpIHx8IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSkpIHJldHVybiBlOyBpZiAodm9pZCAwICE9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IHJldHVybiBzb3VyY2V0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHQpOyB9XG5mdW5jdGlvbiBzb3VyY2V0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkKGUpIHsgaWYgKHZvaWQgMCA9PT0gZSkgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyByZXR1cm4gZTsgfVxuZnVuY3Rpb24gc291cmNldGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKHNvdXJjZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG5mdW5jdGlvbiBzb3VyY2V0YWdfc3VwZXJQcm9wR2V0KHQsIG8sIGUsIHIpIHsgdmFyIHAgPSBzb3VyY2V0YWdfZ2V0KHNvdXJjZXRhZ19nZXRQcm90b3R5cGVPZigxICYgciA/IHQucHJvdG90eXBlIDogdCksIG8sIGUpOyByZXR1cm4gMiAmIHIgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBwID8gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHAuYXBwbHkoZSwgdCk7IH0gOiBwOyB9XG5mdW5jdGlvbiBzb3VyY2V0YWdfZ2V0KCkgeyByZXR1cm4gc291cmNldGFnX2dldCA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFJlZmxlY3QgJiYgUmVmbGVjdC5nZXQgPyBSZWZsZWN0LmdldC5iaW5kKCkgOiBmdW5jdGlvbiAoZSwgdCwgcikgeyB2YXIgcCA9IHNvdXJjZXRhZ19zdXBlclByb3BCYXNlKGUsIHQpOyBpZiAocCkgeyB2YXIgbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocCwgdCk7IHJldHVybiBuLmdldCA/IG4uZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBlIDogcikgOiBuLnZhbHVlOyB9IH0sIHNvdXJjZXRhZ19nZXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gc291cmNldGFnX3N1cGVyUHJvcEJhc2UodCwgbykgeyBmb3IgKDsgIXt9Lmhhc093blByb3BlcnR5LmNhbGwodCwgbykgJiYgbnVsbCAhPT0gKHQgPSBzb3VyY2V0YWdfZ2V0UHJvdG90eXBlT2YodCkpOyk7IHJldHVybiB0OyB9XG5mdW5jdGlvbiBzb3VyY2V0YWdfZ2V0UHJvdG90eXBlT2YodCkgeyByZXR1cm4gc291cmNldGFnX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7IH0sIHNvdXJjZXRhZ19nZXRQcm90b3R5cGVPZih0KTsgfVxuZnVuY3Rpb24gc291cmNldGFnX2luaGVyaXRzKHQsIGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSAmJiBudWxsICE9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiB0LCB3cml0YWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAgfSB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlICYmIHNvdXJjZXRhZ19zZXRQcm90b3R5cGVPZih0LCBlKTsgfVxuZnVuY3Rpb24gc291cmNldGFnX3NldFByb3RvdHlwZU9mKHQsIGUpIHsgcmV0dXJuIHNvdXJjZXRhZ19zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCwgZSkgeyByZXR1cm4gdC5fX3Byb3RvX18gPSBlLCB0OyB9LCBzb3VyY2V0YWdfc2V0UHJvdG90eXBlT2YodCwgZSk7IH1cbi8qKlxuICogSW1hZ2UgVGFnXG4gKiBEZXBlbmRzIG9uICd0YWdzL2h0bWx0YWcnLCAnY2xvdWRpbmFyeSdcbiAqL1xuXG5cblxuXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBIVE1MIChET00pIEltYWdlIHRhZyB1c2luZyBDbG91ZGluYXJ5IGFzIHRoZSBzb3VyY2UuXG4gKiBAY29uc3RydWN0b3IgU291cmNlVGFnXG4gKiBAZXh0ZW5kcyBIdG1sVGFnXG4gKiBAcGFyYW0ge3N0cmluZ30gW3B1YmxpY0lkXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICovXG52YXIgc291cmNldGFnX1NvdXJjZVRhZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0h0bWxUYWcpIHtcbiAgZnVuY3Rpb24gU291cmNlVGFnKHB1YmxpY0lkKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHNvdXJjZXRhZ19jbGFzc0NhbGxDaGVjayh0aGlzLCBTb3VyY2VUYWcpO1xuICAgIHJldHVybiBzb3VyY2V0YWdfY2FsbFN1cGVyKHRoaXMsIFNvdXJjZVRhZywgW1wic291cmNlXCIsIHB1YmxpY0lkLCBvcHRpb25zXSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIHNvdXJjZXRhZ19pbmhlcml0cyhTb3VyY2VUYWcsIF9IdG1sVGFnKTtcbiAgcmV0dXJuIHNvdXJjZXRhZ19jcmVhdGVDbGFzcyhTb3VyY2VUYWcsIFt7XG4gICAga2V5OiBcImNsb3NlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlVGFnKCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICB9LCB7XG4gICAga2V5OiBcImF0dHJpYnV0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlcygpIHtcbiAgICAgIHZhciBzcmNzZXRQYXJhbSA9IHRoaXMuZ2V0T3B0aW9uKCdzcmNzZXQnKTtcbiAgICAgIHZhciBhdHRyID0gc291cmNldGFnX3N1cGVyUHJvcEdldChTb3VyY2VUYWcsIFwiYXR0cmlidXRlc1wiLCB0aGlzLCAzKShbXSkgfHwge307XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgICAgbWVyZ2Vfcm9vdF9tZXJnZV9kZWZhdWx0KCkoYXR0ciwgZ2VuZXJhdGVJbWFnZVJlc3BvbnNpdmVBdHRyaWJ1dGVzKHRoaXMucHVibGljSWQsIGF0dHIsIHNyY3NldFBhcmFtLCBvcHRpb25zKSk7XG4gICAgICBpZiAoIWF0dHIuc3Jjc2V0KSB7XG4gICAgICAgIGF0dHIuc3Jjc2V0ID0gdXJsX3VybCh0aGlzLnB1YmxpY0lkLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICghYXR0ci5tZWRpYSAmJiBvcHRpb25zLm1lZGlhKSB7XG4gICAgICAgIGF0dHIubWVkaWEgPSBnZW5lcmF0ZU1lZGlhQXR0cihvcHRpb25zLm1lZGlhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyO1xuICAgIH1cbiAgfV0pO1xufShodG1sdGFnKTtcbjtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNvdXJjZXRhZyA9IChzb3VyY2V0YWdfU291cmNlVGFnKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3RhZ3MvcGljdHVyZXRhZy5qc1xuZnVuY3Rpb24gcGljdHVyZXRhZ190eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBwaWN0dXJldGFnX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBwaWN0dXJldGFnX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gcGljdHVyZXRhZ19jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxuZnVuY3Rpb24gcGljdHVyZXRhZ19kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHBpY3R1cmV0YWdfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfY3JlYXRlQ2xhc3MoZSwgciwgdCkgeyByZXR1cm4gciAmJiBwaWN0dXJldGFnX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIHBpY3R1cmV0YWdfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBwaWN0dXJldGFnX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IHBpY3R1cmV0YWdfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IHBpY3R1cmV0YWdfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBwaWN0dXJldGFnX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gcGljdHVyZXRhZ190eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gcGljdHVyZXRhZ190eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gcGljdHVyZXRhZ19jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IHBpY3R1cmV0YWdfZ2V0UHJvdG90eXBlT2YobyksIHBpY3R1cmV0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBwaWN0dXJldGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgcGljdHVyZXRhZ19nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuZnVuY3Rpb24gcGljdHVyZXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIGUpIHsgaWYgKGUgJiYgKFwib2JqZWN0XCIgPT0gcGljdHVyZXRhZ190eXBlb2YoZSkgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlKSkgcmV0dXJuIGU7IGlmICh2b2lkIDAgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgcmV0dXJuIHBpY3R1cmV0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHQpOyB9XG5mdW5jdGlvbiBwaWN0dXJldGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZChlKSB7IGlmICh2b2lkIDAgPT09IGUpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAocGljdHVyZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG5mdW5jdGlvbiBwaWN0dXJldGFnX3N1cGVyUHJvcEdldCh0LCBvLCBlLCByKSB7IHZhciBwID0gcGljdHVyZXRhZ19nZXQocGljdHVyZXRhZ19nZXRQcm90b3R5cGVPZigxICYgciA/IHQucHJvdG90eXBlIDogdCksIG8sIGUpOyByZXR1cm4gMiAmIHIgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBwID8gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHAuYXBwbHkoZSwgdCk7IH0gOiBwOyB9XG5mdW5jdGlvbiBwaWN0dXJldGFnX2dldCgpIHsgcmV0dXJuIHBpY3R1cmV0YWdfZ2V0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmdldCA/IFJlZmxlY3QuZ2V0LmJpbmQoKSA6IGZ1bmN0aW9uIChlLCB0LCByKSB7IHZhciBwID0gcGljdHVyZXRhZ19zdXBlclByb3BCYXNlKGUsIHQpOyBpZiAocCkgeyB2YXIgbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocCwgdCk7IHJldHVybiBuLmdldCA/IG4uZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBlIDogcikgOiBuLnZhbHVlOyB9IH0sIHBpY3R1cmV0YWdfZ2V0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfc3VwZXJQcm9wQmFzZSh0LCBvKSB7IGZvciAoOyAhe30uaGFzT3duUHJvcGVydHkuY2FsbCh0LCBvKSAmJiBudWxsICE9PSAodCA9IHBpY3R1cmV0YWdfZ2V0UHJvdG90eXBlT2YodCkpOyk7IHJldHVybiB0OyB9XG5mdW5jdGlvbiBwaWN0dXJldGFnX2dldFByb3RvdHlwZU9mKHQpIHsgcmV0dXJuIHBpY3R1cmV0YWdfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZih0KTsgfSwgcGljdHVyZXRhZ19nZXRQcm90b3R5cGVPZih0KTsgfVxuZnVuY3Rpb24gcGljdHVyZXRhZ19pbmhlcml0cyh0LCBlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUgJiYgbnVsbCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogdCwgd3JpdGFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0gfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZSAmJiBwaWN0dXJldGFnX3NldFByb3RvdHlwZU9mKHQsIGUpOyB9XG5mdW5jdGlvbiBwaWN0dXJldGFnX3NldFByb3RvdHlwZU9mKHQsIGUpIHsgcmV0dXJuIHBpY3R1cmV0YWdfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQsIGUpIHsgcmV0dXJuIHQuX19wcm90b19fID0gZSwgdDsgfSwgcGljdHVyZXRhZ19zZXRQcm90b3R5cGVPZih0LCBlKTsgfVxuXG5cblxuXG5cbnZhciBwaWN0dXJldGFnX1BpY3R1cmVUYWcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9IdG1sVGFnKSB7XG4gIGZ1bmN0aW9uIFBpY3R1cmVUYWcocHVibGljSWQpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBzb3VyY2VzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBbXTtcbiAgICBwaWN0dXJldGFnX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBpY3R1cmVUYWcpO1xuICAgIF90aGlzID0gcGljdHVyZXRhZ19jYWxsU3VwZXIodGhpcywgUGljdHVyZVRhZywgWydwaWN0dXJlJywgcHVibGljSWQsIG9wdGlvbnNdKTtcbiAgICBfdGhpcy53aWR0aExpc3QgPSBzb3VyY2VzO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgcGljdHVyZXRhZ19pbmhlcml0cyhQaWN0dXJlVGFnLCBfSHRtbFRhZyk7XG4gIHJldHVybiBwaWN0dXJldGFnX2NyZWF0ZUNsYXNzKFBpY3R1cmVUYWcsIFt7XG4gICAga2V5OiBcImNvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGVudCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMud2lkdGhMaXN0Lm1hcChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgbWluX3dpZHRoID0gX3JlZi5taW5fd2lkdGgsXG4gICAgICAgICAgbWF4X3dpZHRoID0gX3JlZi5tYXhfd2lkdGgsXG4gICAgICAgICAgdHJhbnNmb3JtYXRpb24gPSBfcmVmLnRyYW5zZm9ybWF0aW9uO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IF90aGlzMi5nZXRPcHRpb25zKCk7XG4gICAgICAgIHZhciBzb3VyY2VUcmFuc2Zvcm1hdGlvbiA9IG5ldyBzcmNfdHJhbnNmb3JtYXRpb24ob3B0aW9ucyk7XG4gICAgICAgIHNvdXJjZVRyYW5zZm9ybWF0aW9uLmNoYWluKCkuZnJvbU9wdGlvbnModHlwZW9mIHRyYW5zZm9ybWF0aW9uID09PSAnc3RyaW5nJyA/IHtcbiAgICAgICAgICByYXdfdHJhbnNmb3JtYXRpb246IHRyYW5zZm9ybWF0aW9uXG4gICAgICAgIH0gOiB0cmFuc2Zvcm1hdGlvbik7XG4gICAgICAgIG9wdGlvbnMgPSBleHRyYWN0VXJsUGFyYW1zKG9wdGlvbnMpO1xuICAgICAgICBvcHRpb25zLm1lZGlhID0ge1xuICAgICAgICAgIG1pbl93aWR0aDogbWluX3dpZHRoLFxuICAgICAgICAgIG1heF93aWR0aDogbWF4X3dpZHRoXG4gICAgICAgIH07XG4gICAgICAgIG9wdGlvbnMudHJhbnNmb3JtYXRpb24gPSBzb3VyY2VUcmFuc2Zvcm1hdGlvbjtcbiAgICAgICAgcmV0dXJuIG5ldyBzb3VyY2V0YWcoX3RoaXMyLnB1YmxpY0lkLCBvcHRpb25zKS50b0h0bWwoKTtcbiAgICAgIH0pLmpvaW4oJycpICsgbmV3IGltYWdldGFnKHRoaXMucHVibGljSWQsIHRoaXMuZ2V0T3B0aW9ucygpKS50b0h0bWwoKTtcbiAgICB9XG5cbiAgICAvKiogQG92ZXJyaWRlICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYXR0cmlidXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVzKCkge1xuICAgICAgdmFyIGF0dHIgPSBwaWN0dXJldGFnX3N1cGVyUHJvcEdldChQaWN0dXJlVGFnLCBcImF0dHJpYnV0ZXNcIiwgdGhpcywgMykoW10pO1xuICAgICAgZGVsZXRlIGF0dHIud2lkdGg7XG4gICAgICBkZWxldGUgYXR0ci5oZWlnaHQ7XG4gICAgICByZXR1cm4gYXR0cjtcbiAgICB9XG5cbiAgICAvKiogQG92ZXJyaWRlICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VUYWcoKSB7XG4gICAgICByZXR1cm4gXCI8L1wiICsgdGhpcy5uYW1lICsgXCI+XCI7XG4gICAgfVxuICB9XSk7XG59KGh0bWx0YWcpO1xuO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgcGljdHVyZXRhZyA9IChwaWN0dXJldGFnX1BpY3R1cmVUYWcpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdGFncy92aWRlb3RhZy5qc1xuZnVuY3Rpb24gdmlkZW90YWdfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gdmlkZW90YWdfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIHZpZGVvdGFnX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gdmlkZW90YWdfY2xhc3NDYWxsQ2hlY2soYSwgbikgeyBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH1cbmZ1bmN0aW9uIHZpZGVvdGFnX2RlZmluZVByb3BlcnRpZXMoZSwgcikgeyBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHsgdmFyIG8gPSByW3RdOyBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgdmlkZW90YWdfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIHZpZGVvdGFnX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHsgcmV0dXJuIHIgJiYgdmlkZW90YWdfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgdmlkZW90YWdfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiB2aWRlb3RhZ190b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSB2aWRlb3RhZ190b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gdmlkZW90YWdfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiB2aWRlb3RhZ190b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IHZpZGVvdGFnX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSB2aWRlb3RhZ190eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gdmlkZW90YWdfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSB2aWRlb3RhZ19nZXRQcm90b3R5cGVPZihvKSwgdmlkZW90YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCB2aWRlb3RhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIHZpZGVvdGFnX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG5mdW5jdGlvbiB2aWRlb3RhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIGUpIHsgaWYgKGUgJiYgKFwib2JqZWN0XCIgPT0gdmlkZW90YWdfdHlwZW9mKGUpIHx8IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSkpIHJldHVybiBlOyBpZiAodm9pZCAwICE9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IHJldHVybiB2aWRlb3RhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQodCk7IH1cbmZ1bmN0aW9uIHZpZGVvdGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZChlKSB7IGlmICh2b2lkIDAgPT09IGUpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIHZpZGVvdGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKHZpZGVvdGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbmZ1bmN0aW9uIHZpZGVvdGFnX3N1cGVyUHJvcEdldCh0LCBvLCBlLCByKSB7IHZhciBwID0gdmlkZW90YWdfZ2V0KHZpZGVvdGFnX2dldFByb3RvdHlwZU9mKDEgJiByID8gdC5wcm90b3R5cGUgOiB0KSwgbywgZSk7IHJldHVybiAyICYgciAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHAgPyBmdW5jdGlvbiAodCkgeyByZXR1cm4gcC5hcHBseShlLCB0KTsgfSA6IHA7IH1cbmZ1bmN0aW9uIHZpZGVvdGFnX2dldCgpIHsgcmV0dXJuIHZpZGVvdGFnX2dldCA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFJlZmxlY3QgJiYgUmVmbGVjdC5nZXQgPyBSZWZsZWN0LmdldC5iaW5kKCkgOiBmdW5jdGlvbiAoZSwgdCwgcikgeyB2YXIgcCA9IHZpZGVvdGFnX3N1cGVyUHJvcEJhc2UoZSwgdCk7IGlmIChwKSB7IHZhciBuID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwLCB0KTsgcmV0dXJuIG4uZ2V0ID8gbi5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoIDwgMyA/IGUgOiByKSA6IG4udmFsdWU7IH0gfSwgdmlkZW90YWdfZ2V0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIHZpZGVvdGFnX3N1cGVyUHJvcEJhc2UodCwgbykgeyBmb3IgKDsgIXt9Lmhhc093blByb3BlcnR5LmNhbGwodCwgbykgJiYgbnVsbCAhPT0gKHQgPSB2aWRlb3RhZ19nZXRQcm90b3R5cGVPZih0KSk7KTsgcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIHZpZGVvdGFnX2dldFByb3RvdHlwZU9mKHQpIHsgcmV0dXJuIHZpZGVvdGFnX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7IH0sIHZpZGVvdGFnX2dldFByb3RvdHlwZU9mKHQpOyB9XG5mdW5jdGlvbiB2aWRlb3RhZ19pbmhlcml0cyh0LCBlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUgJiYgbnVsbCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogdCwgd3JpdGFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0gfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZSAmJiB2aWRlb3RhZ19zZXRQcm90b3R5cGVPZih0LCBlKTsgfVxuZnVuY3Rpb24gdmlkZW90YWdfc2V0UHJvdG90eXBlT2YodCwgZSkgeyByZXR1cm4gdmlkZW90YWdfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQsIGUpIHsgcmV0dXJuIHQuX19wcm90b19fID0gZSwgdDsgfSwgdmlkZW90YWdfc2V0UHJvdG90eXBlT2YodCwgZSk7IH1cbi8qKlxuICogVmlkZW8gVGFnXG4gKiBEZXBlbmRzIG9uICd0YWdzL2h0bWx0YWcnLCAndXRpbCcsICdjbG91ZGluYXJ5J1xuICovXG5cblxuXG5cblxudmFyIFZJREVPX1RBR19QQVJBTVMgPSBbJ3NvdXJjZV90eXBlcycsICdzb3VyY2VfdHJhbnNmb3JtYXRpb24nLCAnZmFsbGJhY2tfY29udGVudCcsICdwb3N0ZXInLCAnc291cmNlcyddO1xudmFyIHZpZGVvdGFnX0RFRkFVTFRfVklERU9fU09VUkNFX1RZUEVTID0gWyd3ZWJtJywgJ21wNCcsICdvZ3YnXTtcbnZhciB2aWRlb3RhZ19ERUZBVUxUX1BPU1RFUl9PUFRJT05TID0ge1xuICBmb3JtYXQ6ICdqcGcnLFxuICByZXNvdXJjZV90eXBlOiAndmlkZW8nXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gSFRNTCAoRE9NKSBWaWRlbyB0YWcgdXNpbmcgQ2xvdWRpbmFyeSBhcyB0aGUgc291cmNlLlxuICogQGNvbnN0cnVjdG9yIFZpZGVvVGFnXG4gKiBAZXh0ZW5kcyBIdG1sVGFnXG4gKiBAcGFyYW0ge3N0cmluZ30gW3B1YmxpY0lkXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICovXG52YXIgdmlkZW90YWdfVmlkZW9UYWcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9IdG1sVGFnKSB7XG4gIGZ1bmN0aW9uIFZpZGVvVGFnKHB1YmxpY0lkKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZpZGVvdGFnX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZpZGVvVGFnKTtcbiAgICBvcHRpb25zID0gZGVmYXVsdHMoe30sIG9wdGlvbnMsIERFRkFVTFRfVklERU9fUEFSQU1TKTtcbiAgICByZXR1cm4gdmlkZW90YWdfY2FsbFN1cGVyKHRoaXMsIFZpZGVvVGFnLCBbXCJ2aWRlb1wiLCBwdWJsaWNJZC5yZXBsYWNlKC9cXC4obXA0fG9ndnx3ZWJtKSQvLCAnJyksIG9wdGlvbnNdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRyYW5zZm9ybWF0aW9uIHRvIGFwcGx5IG9uIGVhY2ggc291cmNlXG4gICAqIEBmdW5jdGlvbiBWaWRlb1RhZyNzZXRTb3VyY2VUcmFuc2Zvcm1hdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gYW4gb2JqZWN0IHdpdGggcGFpcnMgb2Ygc291cmNlIHR5cGUgYW5kIHNvdXJjZSB0cmFuc2Zvcm1hdGlvblxuICAgKiBAcmV0dXJucyB7VmlkZW9UYWd9IFJldHVybnMgdGhpcyBpbnN0YW5jZSBmb3IgY2hhaW5pbmcgcHVycG9zZXMuXG4gICAqL1xuICB2aWRlb3RhZ19pbmhlcml0cyhWaWRlb1RhZywgX0h0bWxUYWcpO1xuICByZXR1cm4gdmlkZW90YWdfY3JlYXRlQ2xhc3MoVmlkZW9UYWcsIFt7XG4gICAga2V5OiBcInNldFNvdXJjZVRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNvdXJjZVRyYW5zZm9ybWF0aW9uKHZhbHVlKSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybWF0aW9uKCkuc291cmNlVHJhbnNmb3JtYXRpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzb3VyY2UgdHlwZXMgdG8gaW5jbHVkZSBpbiB0aGUgdmlkZW8gdGFnXG4gICAgICogQGZ1bmN0aW9uIFZpZGVvVGFnI3NldFNvdXJjZVR5cGVzXG4gICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhbiBhcnJheSBvZiBzb3VyY2UgdHlwZXNcbiAgICAgKiBAcmV0dXJucyB7VmlkZW9UYWd9IFJldHVybnMgdGhpcyBpbnN0YW5jZSBmb3IgY2hhaW5pbmcgcHVycG9zZXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U291cmNlVHlwZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U291cmNlVHlwZXModmFsdWUpIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtYXRpb24oKS5zb3VyY2VUeXBlcyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHBvc3RlciB0byBiZSB1c2VkIGluIHRoZSB2aWRlbyB0YWdcbiAgICAgKiBAZnVuY3Rpb24gVmlkZW9UYWcjc2V0UG9zdGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSB2YWx1ZVxuICAgICAqIC0gc3RyaW5nOiBhIFVSTCB0byB1c2UgZm9yIHRoZSBwb3N0ZXJcbiAgICAgKiAtIE9iamVjdDogdHJhbnNmb3JtYXRpb24gcGFyYW1ldGVycyB0byBhcHBseSB0byB0aGUgcG9zdGVyLiBNYXkgb3B0aW9uYWxseSBpbmNsdWRlIGEgcHVibGljX2lkIHRvIHVzZSBpbnN0ZWFkIG9mIHRoZSB2aWRlbyBwdWJsaWNfaWQuXG4gICAgICogQHJldHVybnMge1ZpZGVvVGFnfSBSZXR1cm5zIHRoaXMgaW5zdGFuY2UgZm9yIGNoYWluaW5nIHB1cnBvc2VzLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldFBvc3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQb3N0ZXIodmFsdWUpIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtYXRpb24oKS5wb3N0ZXIodmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjb250ZW50IHRvIHVzZSBhcyBmYWxsYmFjayBpbiB0aGUgdmlkZW8gdGFnXG4gICAgICogQGZ1bmN0aW9uIFZpZGVvVGFnI3NldEZhbGxiYWNrQ29udGVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIHRoZSBjb250ZW50IHRvIHVzZSwgaW4gSFRNTCBmb3JtYXRcbiAgICAgKiBAcmV0dXJucyB7VmlkZW9UYWd9IFJldHVybnMgdGhpcyBpbnN0YW5jZSBmb3IgY2hhaW5pbmcgcHVycG9zZXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RmFsbGJhY2tDb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZhbGxiYWNrQ29udGVudCh2YWx1ZSkge1xuICAgICAgdGhpcy50cmFuc2Zvcm1hdGlvbigpLmZhbGxiYWNrQ29udGVudCh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29udGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb250ZW50KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBzb3VyY2VUeXBlcyA9IHRoaXMudHJhbnNmb3JtYXRpb24oKS5nZXRWYWx1ZSgnc291cmNlX3R5cGVzJyk7XG4gICAgICB2YXIgc291cmNlVHJhbnNmb3JtYXRpb24gPSB0aGlzLnRyYW5zZm9ybWF0aW9uKCkuZ2V0VmFsdWUoJ3NvdXJjZV90cmFuc2Zvcm1hdGlvbicpO1xuICAgICAgdmFyIGZhbGxiYWNrID0gdGhpcy50cmFuc2Zvcm1hdGlvbigpLmdldFZhbHVlKCdmYWxsYmFja19jb250ZW50Jyk7XG4gICAgICB2YXIgc291cmNlcyA9IHRoaXMuZ2V0T3B0aW9uKCdzb3VyY2VzJyk7XG4gICAgICB2YXIgaW5uZXJUYWdzID0gW107XG4gICAgICBpZiAoaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHNvdXJjZXMpICYmICFpc0VtcHR5KHNvdXJjZXMpKSB7XG4gICAgICAgIGlubmVyVGFncyA9IHNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICB2YXIgc3JjID0gdXJsX3VybChfdGhpcy5wdWJsaWNJZCwgZGVmYXVsdHMoe30sIHNvdXJjZS50cmFuc2Zvcm1hdGlvbnMgfHwge30sIHtcbiAgICAgICAgICAgIHJlc291cmNlX3R5cGU6ICd2aWRlbycsXG4gICAgICAgICAgICBmb3JtYXQ6IHNvdXJjZS50eXBlXG4gICAgICAgICAgfSksIF90aGlzLmdldE9wdGlvbnMoKSk7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmNyZWF0ZVNvdXJjZVRhZyhzcmMsIHNvdXJjZS50eXBlLCBzb3VyY2UuY29kZWNzKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNFbXB0eShzb3VyY2VUeXBlcykpIHtcbiAgICAgICAgICBzb3VyY2VUeXBlcyA9IHZpZGVvdGFnX0RFRkFVTFRfVklERU9fU09VUkNFX1RZUEVTO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkoc291cmNlVHlwZXMpKSB7XG4gICAgICAgICAgaW5uZXJUYWdzID0gc291cmNlVHlwZXMubWFwKGZ1bmN0aW9uIChzcmNUeXBlKSB7XG4gICAgICAgICAgICB2YXIgc3JjID0gdXJsX3VybChfdGhpcy5wdWJsaWNJZCwgZGVmYXVsdHMoe30sIHNvdXJjZVRyYW5zZm9ybWF0aW9uW3NyY1R5cGVdIHx8IHt9LCB7XG4gICAgICAgICAgICAgIHJlc291cmNlX3R5cGU6ICd2aWRlbycsXG4gICAgICAgICAgICAgIGZvcm1hdDogc3JjVHlwZVxuICAgICAgICAgICAgfSksIF90aGlzLmdldE9wdGlvbnMoKSk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuY3JlYXRlU291cmNlVGFnKHNyYywgc3JjVHlwZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpbm5lclRhZ3Muam9pbignJykgKyBmYWxsYmFjaztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXR0cmlidXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVzKCkge1xuICAgICAgdmFyIHNvdXJjZVR5cGVzID0gdGhpcy5nZXRPcHRpb24oJ3NvdXJjZV90eXBlcycpO1xuICAgICAgdmFyIHBvc3RlciA9IHRoaXMuZ2V0T3B0aW9uKCdwb3N0ZXInKTtcbiAgICAgIGlmIChwb3N0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb3N0ZXIgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkocG9zdGVyKSkge1xuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSBwb3N0ZXIucHVibGljX2lkICE9IG51bGwgPyBERUZBVUxUX0lNQUdFX1BBUkFNUyA6IHZpZGVvdGFnX0RFRkFVTFRfUE9TVEVSX09QVElPTlM7XG4gICAgICAgIHBvc3RlciA9IHVybF91cmwocG9zdGVyLnB1YmxpY19pZCB8fCB0aGlzLnB1YmxpY0lkLCBkZWZhdWx0cyh7fSwgcG9zdGVyLCBkZWZhdWx0T3B0aW9ucywgdGhpcy5nZXRPcHRpb25zKCkpKTtcbiAgICAgIH1cbiAgICAgIHZhciBhdHRyID0gdmlkZW90YWdfc3VwZXJQcm9wR2V0KFZpZGVvVGFnLCBcImF0dHJpYnV0ZXNcIiwgdGhpcywgMykoW10pIHx8IHt9O1xuICAgICAgYXR0ciA9IG9taXQoYXR0ciwgVklERU9fVEFHX1BBUkFNUyk7XG4gICAgICB2YXIgc291cmNlcyA9IHRoaXMuZ2V0T3B0aW9uKCdzb3VyY2VzJyk7XG4gICAgICAvLyBJbiBjYXNlIG9mIGVtcHR5IHNvdXJjZVR5cGVzIC0gZmFsbGJhY2sgdG8gZGVmYXVsdCBzb3VyY2UgdHlwZXMgaXMgdXNlZC5cbiAgICAgIHZhciBoYXNTb3VyY2VUYWdzID0gIWlzRW1wdHkoc291cmNlcykgfHwgaXNFbXB0eShzb3VyY2VUeXBlcykgfHwgaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHNvdXJjZVR5cGVzKTtcbiAgICAgIGlmICghaGFzU291cmNlVGFncykge1xuICAgICAgICBhdHRyW1wic3JjXCJdID0gdXJsX3VybCh0aGlzLnB1YmxpY0lkLCB0aGlzLmdldE9wdGlvbnMoKSwge1xuICAgICAgICAgIHJlc291cmNlX3R5cGU6ICd2aWRlbycsXG4gICAgICAgICAgZm9ybWF0OiBzb3VyY2VUeXBlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChwb3N0ZXIgIT0gbnVsbCkge1xuICAgICAgICBhdHRyW1wicG9zdGVyXCJdID0gcG9zdGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVNvdXJjZVRhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVTb3VyY2VUYWcoc3JjLCBzb3VyY2VUeXBlKSB7XG4gICAgICB2YXIgY29kZWNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgICAgdmFyIG1pbWVUeXBlID0gbnVsbDtcbiAgICAgIGlmICghaXNFbXB0eShzb3VyY2VUeXBlKSkge1xuICAgICAgICB2YXIgdmlkZW9UeXBlID0gc291cmNlVHlwZSA9PT0gJ29ndicgPyAnb2dnJyA6IHNvdXJjZVR5cGU7XG4gICAgICAgIG1pbWVUeXBlID0gJ3ZpZGVvLycgKyB2aWRlb1R5cGU7XG4gICAgICAgIGlmICghaXNFbXB0eShjb2RlY3MpKSB7XG4gICAgICAgICAgdmFyIGNvZGVjc1N0ciA9IGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKShjb2RlY3MpID8gY29kZWNzLmpvaW4oJywgJykgOiBjb2RlY3M7XG4gICAgICAgICAgbWltZVR5cGUgKz0gJzsgY29kZWNzPScgKyBjb2RlY3NTdHI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBcIjxzb3VyY2UgXCIgKyB0aGlzLmh0bWxBdHRycyh7XG4gICAgICAgIHNyYzogc3JjLFxuICAgICAgICB0eXBlOiBtaW1lVHlwZVxuICAgICAgfSkgKyBcIj5cIjtcbiAgICB9XG4gIH1dKTtcbn0oaHRtbHRhZyk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB2aWRlb3RhZyA9ICh2aWRlb3RhZ19WaWRlb1RhZyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy90YWdzL2NsaWVudGhpbnRzbWV0YXRhZy5qc1xuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIGNsaWVudGhpbnRzbWV0YXRhZ190eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgY2xpZW50aGludHNtZXRhdGFnX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiBjbGllbnRoaW50c21ldGF0YWdfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7IGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykgeyB2YXIgbyA9IHJbdF07IG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBjbGllbnRoaW50c21ldGF0YWdfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIGNsaWVudGhpbnRzbWV0YXRhZ19kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBjbGllbnRoaW50c21ldGF0YWdfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBjbGllbnRoaW50c21ldGF0YWdfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gY2xpZW50aGludHNtZXRhdGFnX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBjbGllbnRoaW50c21ldGF0YWdfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBjbGllbnRoaW50c21ldGF0YWdfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBjbGllbnRoaW50c21ldGF0YWdfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IGNsaWVudGhpbnRzbWV0YXRhZ190eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gY2xpZW50aGludHNtZXRhdGFnX2dldFByb3RvdHlwZU9mKG8pLCBjbGllbnRoaW50c21ldGF0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBjbGllbnRoaW50c21ldGF0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBjbGllbnRoaW50c21ldGF0YWdfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIGUpIHsgaWYgKGUgJiYgKFwib2JqZWN0XCIgPT0gY2xpZW50aGludHNtZXRhdGFnX3R5cGVvZihlKSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUpKSByZXR1cm4gZTsgaWYgKHZvaWQgMCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyByZXR1cm4gY2xpZW50aGludHNtZXRhdGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZCh0KTsgfVxuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZChlKSB7IGlmICh2b2lkIDAgPT09IGUpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChjbGllbnRoaW50c21ldGF0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX2dldFByb3RvdHlwZU9mKHQpIHsgcmV0dXJuIGNsaWVudGhpbnRzbWV0YXRhZ19nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpOyB9LCBjbGllbnRoaW50c21ldGF0YWdfZ2V0UHJvdG90eXBlT2YodCk7IH1cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19pbmhlcml0cyh0LCBlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUgJiYgbnVsbCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogdCwgd3JpdGFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0gfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZSAmJiBjbGllbnRoaW50c21ldGF0YWdfc2V0UHJvdG90eXBlT2YodCwgZSk7IH1cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19zZXRQcm90b3R5cGVPZih0LCBlKSB7IHJldHVybiBjbGllbnRoaW50c21ldGF0YWdfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQsIGUpIHsgcmV0dXJuIHQuX19wcm90b19fID0gZSwgdDsgfSwgY2xpZW50aGludHNtZXRhdGFnX3NldFByb3RvdHlwZU9mKHQsIGUpOyB9XG4vKipcbiAqIEltYWdlIFRhZ1xuICogRGVwZW5kcyBvbiAndGFncy9odG1sdGFnJywgJ2Nsb3VkaW5hcnknXG4gKi9cblxuXG5cblxuLyoqXG4gKiBDcmVhdGVzIGFuIEhUTUwgKERPTSkgTWV0YSB0YWcgdGhhdCBlbmFibGVzIENsaWVudC1IaW50cyBmb3IgdGhlIEhUTUwgcGFnZS4gPGJyLz5cbiAqICBTZWVcbiAqICA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3Jlc3BvbnNpdmVfaW1hZ2VzI2F1dG9tYXRpbmdfcmVzcG9uc2l2ZV9pbWFnZXNfd2l0aF9jbGllbnRfaGludHNcIlxuICogIHRhcmdldD1cIl9uZXdcIj5BdXRvbWF0aW5nIHJlc3BvbnNpdmUgaW1hZ2VzIHdpdGggQ2xpZW50IEhpbnRzPC9hPiBmb3IgbW9yZSBkZXRhaWxzLlxuICogQGNvbnN0cnVjdG9yIENsaWVudEhpbnRzTWV0YVRhZ1xuICogQGV4dGVuZHMgSHRtbFRhZ1xuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBleGFtcGxlXG4gKiB0YWcgPSBuZXcgQ2xpZW50SGludHNNZXRhVGFnKClcbiAqIC8vcmV0dXJuczogPG1ldGEgaHR0cC1lcXVpdj1cIkFjY2VwdC1DSFwiIGNvbnRlbnQ9XCJEUFIsIFZpZXdwb3J0LVdpZHRoLCBXaWR0aFwiPlxuICovXG52YXIgY2xpZW50aGludHNtZXRhdGFnX0NsaWVudEhpbnRzTWV0YVRhZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0h0bWxUYWcpIHtcbiAgZnVuY3Rpb24gQ2xpZW50SGludHNNZXRhVGFnKG9wdGlvbnMpIHtcbiAgICBjbGllbnRoaW50c21ldGF0YWdfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2xpZW50SGludHNNZXRhVGFnKTtcbiAgICByZXR1cm4gY2xpZW50aGludHNtZXRhdGFnX2NhbGxTdXBlcih0aGlzLCBDbGllbnRIaW50c01ldGFUYWcsIFsnbWV0YScsIHZvaWQgMCwgYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh7XG4gICAgICBcImh0dHAtZXF1aXZcIjogXCJBY2NlcHQtQ0hcIixcbiAgICAgIGNvbnRlbnQ6IFwiRFBSLCBWaWV3cG9ydC1XaWR0aCwgV2lkdGhcIlxuICAgIH0sIG9wdGlvbnMpXSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGNsaWVudGhpbnRzbWV0YXRhZ19pbmhlcml0cyhDbGllbnRIaW50c01ldGFUYWcsIF9IdG1sVGFnKTtcbiAgcmV0dXJuIGNsaWVudGhpbnRzbWV0YXRhZ19jcmVhdGVDbGFzcyhDbGllbnRIaW50c01ldGFUYWcsIFt7XG4gICAga2V5OiBcImNsb3NlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlVGFnKCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICB9XSk7XG59KGh0bWx0YWcpO1xuO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY2xpZW50aGludHNtZXRhdGFnID0gKGNsaWVudGhpbnRzbWV0YXRhZ19DbGllbnRIaW50c01ldGFUYWcpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9wYXJzZS9ub3JtYWxpemVUb0FycmF5LmpzXG5mdW5jdGlvbiBub3JtYWxpemVUb0FycmF5X3RvQ29uc3VtYWJsZUFycmF5KHIpIHsgcmV0dXJuIG5vcm1hbGl6ZVRvQXJyYXlfYXJyYXlXaXRob3V0SG9sZXMocikgfHwgbm9ybWFsaXplVG9BcnJheV9pdGVyYWJsZVRvQXJyYXkocikgfHwgbm9ybWFsaXplVG9BcnJheV91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyKSB8fCBub3JtYWxpemVUb0FycmF5X25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRvQXJyYXlfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBub3JtYWxpemVUb0FycmF5X3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHsgaWYgKHIpIHsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBub3JtYWxpemVUb0FycmF5X2FycmF5TGlrZVRvQXJyYXkociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IG5vcm1hbGl6ZVRvQXJyYXlfYXJyYXlMaWtlVG9BcnJheShyLCBhKSA6IHZvaWQgMDsgfSB9XG5mdW5jdGlvbiBub3JtYWxpemVUb0FycmF5X2l0ZXJhYmxlVG9BcnJheShyKSB7IGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgbnVsbCAhPSByW1N5bWJvbC5pdGVyYXRvcl0gfHwgbnVsbCAhPSByW1wiQEBpdGVyYXRvclwiXSkgcmV0dXJuIEFycmF5LmZyb20ocik7IH1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRvQXJyYXlfYXJyYXlXaXRob3V0SG9sZXMocikgeyBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIG5vcm1hbGl6ZVRvQXJyYXlfYXJyYXlMaWtlVG9BcnJheShyKTsgfVxuZnVuY3Rpb24gbm9ybWFsaXplVG9BcnJheV9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHsgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpOyBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTsgcmV0dXJuIG47IH1cblxuXG4vKipcbiAqIEBkZXNjIG5vcm1hbGl6ZSBlbGVtZW50cywgc3VwcG9ydCBhIHNpbmdsZSBlbGVtZW50LCBhcnJheSBvciBub2RlbGlzdCwgYWx3YXlzIG91dHB1dHMgYXJyYXlcbiAqIEBwYXJhbSBlbGVtZW50czxIVE1MRWxlbWVudFtdPlxuICogQHJldHVybnMge1tdfVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVUb0FycmF5KGVsZW1lbnRzKSB7XG4gIGlmIChpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkoZWxlbWVudHMpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9IGVsc2UgaWYgKGVsZW1lbnRzLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiTm9kZUxpc3RcIikge1xuICAgIHJldHVybiBub3JtYWxpemVUb0FycmF5X3RvQ29uc3VtYWJsZUFycmF5KGVsZW1lbnRzKTsgLy8gZW5zdXJlIGFuIGFycmF5IGlzIGFsd2F5cyByZXR1cm5lZCwgZXZlbiBpZiBub2RlbGlzdFxuICB9IGVsc2UgaWYgKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKGVsZW1lbnRzKSkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGVsZW1lbnRzKSwgMCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtlbGVtZW50c107XG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvZmVhdHVyZXMvdHJhbnNwYXJlbnRWaWRlby9tb3VudENsb3VkaW5hcnlWaWRlb1RhZy5qc1xuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBodG1sRWxDb250YWluZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBjbEluc3RhbmNlIGNsb3VkaW5hcnkgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBUcmFuc2Zvcm1hdGlvbk9wdGlvbnNcbiAqIEByZXR1cm5zIFByb21pc2U8SFRNTEVsZW1lbnQ+XG4gKi9cbmZ1bmN0aW9uIG1vdW50Q2xvdWRpbmFyeVZpZGVvVGFnKGh0bWxFbENvbnRhaW5lciwgY2xJbnN0YW5jZSwgcHVibGljSWQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBodG1sRWxDb250YWluZXIuaW5uZXJIVE1MID0gY2xJbnN0YW5jZS52aWRlb1RhZyhwdWJsaWNJZCwgb3B0aW9ucykudG9IdG1sKCk7XG5cbiAgICAvLyBBbGwgdmlkZW9zIHVuZGVyIHRoZSBodG1sIGNvbnRhaW5lciBtdXN0IGhhdmUgYSB3aWR0aCBvZiAxMDAlLCBvciB0aGV5IG1pZ2h0IG92ZXJmbG93IGZyb20gdGhlIGNvbnRhaW5lclxuICAgIHZhciBjbG91ZGluYXJ5VmlkZW9FbGVtZW50ID0gaHRtbEVsQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5jbGQtdHJhbnNwYXJlbnQtdmlkZW8nKTtcbiAgICBjbG91ZGluYXJ5VmlkZW9FbGVtZW50LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHJlc29sdmUoaHRtbEVsQ29udGFpbmVyKTtcbiAgfSk7XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BhcmVudFZpZGVvX21vdW50Q2xvdWRpbmFyeVZpZGVvVGFnID0gKG1vdW50Q2xvdWRpbmFyeVZpZGVvVGFnKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvdHJhbnNmb3JtYXRpb25zL2FkZEZsYWcuanNcbi8qKlxuICogQGRlc2NyaXB0aW9uIC0gRnVuY3Rpb24gd2lsbCBwdXNoIGEgZmxhZyB0byBpbmNvbWluZyBvcHRpb25zXG4gKiBAcGFyYW0ge3t0cmFuc2Zvcm1hdGlvbn0gfCB7Li4udHJhbnNmb3JtYXRpb259fSBvcHRpb25zIC0gVGhlc2Ugb3B0aW9ucyBhcmUgdGhlIHNhbWUgb3B0aW9ucyBwcm92aWRlZCB0byBhbGwgb3VyIFNESyBtZXRob2RzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFdlIGV4cGVjdCBvcHRpb25zIHRvIGVpdGhlciBiZSB0aGUgdHJhbnNmb3JtYXRpb24gaXRzZWxmLCBvciBhbiBvYmplY3QgY29udGFpbmluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICBhbiBhcnJheSBvZiB0cmFuc2Zvcm1hdGlvbnNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmxhZ1xuICogQHJldHVybnMgdGhlIG11dGF0ZWQgb3B0aW9ucyBvYmplY3RcbiAqL1xuXG5mdW5jdGlvbiBhZGRGbGFnVG9PcHRpb25zKG9wdGlvbnMsIGZsYWcpIHtcbiAgLy8gRG8gd2UgaGF2ZSB0cmFuc2Zvcm1hdGlvblxuICBpZiAob3B0aW9ucy50cmFuc2Zvcm1hdGlvbikge1xuICAgIG9wdGlvbnMudHJhbnNmb3JtYXRpb24ucHVzaCh7XG4gICAgICBmbGFnczogW2ZsYWddXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbm8gdHJhbnNmb3JtYXRpb25cbiAgICAvLyBlbnN1cmUgdGhlIGZsYWdzIGFyZSBleHRlbmRlZFxuICAgIGlmICghb3B0aW9ucy5mbGFncykge1xuICAgICAgb3B0aW9ucy5mbGFncyA9IFtdO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmxhZ3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRpb25zLmZsYWdzID0gW29wdGlvbnMuZmxhZ3NdO1xuICAgIH1cbiAgICBvcHRpb25zLmZsYWdzLnB1c2goZmxhZyk7XG4gIH1cbn1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGFkZEZsYWcgPSAoYWRkRmxhZ1RvT3B0aW9ucyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2ZlYXR1cmVzL3RyYW5zcGFyZW50VmlkZW8vZW5mb3JjZU9wdGlvbnNGb3JUcmFuc3BhcmVudFZpZGVvLmpzXG5cblxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiAtIEVuZm9yY2Ugb3B0aW9uIHN0cnVjdHVyZSwgc2V0cyBkZWZhdWx0cyBhbmQgZW5zdXJlcyBhbHBoYSBmbGFnIGV4aXN0c1xuICogQHBhcmFtIG9wdGlvbnMge1RyYW5zZm9ybWF0aW9uT3B0aW9uc31cbiAqL1xuZnVuY3Rpb24gZW5mb3JjZU9wdGlvbnNGb3JUcmFuc3BhcmVudFZpZGVvKG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5hdXRvcGxheSA9IHRydWU7XG4gIG9wdGlvbnMubXV0ZWQgPSB0cnVlO1xuICBvcHRpb25zLmNvbnRyb2xzID0gZmFsc2U7XG4gIG9wdGlvbnMubWF4X3RpbWVvdXRfbXMgPSBvcHRpb25zLm1heF90aW1lb3V0X21zIHx8IERFRkFVTFRfVElNRU9VVF9NUztcbiAgb3B0aW9uc1tcImNsYXNzXCJdID0gb3B0aW9uc1tcImNsYXNzXCJdIHx8ICcnO1xuICBvcHRpb25zW1wiY2xhc3NcIl0gKz0gJyBjbGQtdHJhbnNwYXJlbnQtdmlkZW8nO1xuICBvcHRpb25zLmV4dGVybmFsTGlicmFyaWVzID0gb3B0aW9ucy5leHRlcm5hbExpYnJhcmllcyB8fCB7fTtcbiAgaWYgKCFvcHRpb25zLmV4dGVybmFsTGlicmFyaWVzLnNlZVRocnUpIHtcbiAgICBvcHRpb25zLmV4dGVybmFsTGlicmFyaWVzLnNlZVRocnUgPSBERUZBVUxUX0VYVEVSTkFMX0xJQlJBUklFUy5zZWVUaHJ1O1xuICB9XG5cbiAgLy8gZW5zdXJlIHRoZXJlJ3MgYW4gYWxwaGEgdHJhbnNmb3JtYXRpb24gcHJlc2VudFxuICAvLyB0aGlzIGlzIGEgbm9uIGRvY3VtZW50ZWQgaW50ZXJuYWwgZmxhZ1xuICBhZGRGbGFnKG9wdGlvbnMsICdhbHBoYScpO1xufVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdHJhbnNwYXJlbnRWaWRlb19lbmZvcmNlT3B0aW9uc0ZvclRyYW5zcGFyZW50VmlkZW8gPSAoZW5mb3JjZU9wdGlvbnNGb3JUcmFuc3BhcmVudFZpZGVvKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwveGhyL2xvYWRTY3JpcHQuanNcbi8qKlxuICogQGRlc2NyaXB0aW9uIC0gR2l2ZW4gYSBzdHJpbmcgVVJMLCB0aGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCB0aGUgc2NyaXB0IGFuZCByZXNvbHZlIHRoZSBwcm9taXNlLlxuICogICAgICAgICAgICAgICAgVGhlIGZ1bmN0aW9uIGRvZXNuJ3QgcmVzb2x2ZSBhbnkgdmFsdWUsXG4gKiAgICAgICAgICAgICAgICB0aGlzIGlzIG5vdCBhIFVNRCBsb2FkZXIgd2hlcmUgeW91IGNhbiBnZXQgeW91ciBsaWJyYXJ5IG5hbWUgYmFjay5cbiAqIEBwYXJhbSBzY3JpcHRVUkwge3N0cmluZ31cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhfdGltZW91dF9tcyAtIFRpbWUgdG8gZWxhcHNlIGJlZm9yZSBwcm9taXNlIGlzIHJlamVjdGVkXG4gKiBAcGFyYW0gaXNBbHJlYWR5TG9hZGVkIHtib29sZWFufSBpZiB0cnVlLCB0aGUgbG9hZFNjcmlwdCByZXNvbHZlcyBpbW1lZGlhdGVseVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBpcyB1c2VkIGZvciBtdWx0aXBsZSBpbnZvY2F0aW9ucyAtIHByZXZlbnRzIHRoZSBzY3JpcHQgZnJvbSBiZWluZyBsb2FkZWQgbXVsdGlwbGUgdGltZXNcbiAqIEByZXR1cm4ge1Byb21pc2U8YW55IHwge3N0YXR1czpzdHJpbmcsIG1lc3NhZ2U6c3RyaW5nfT59XG4gKi9cbmZ1bmN0aW9uIGxvYWRTY3JpcHQoc2NyaXB0VVJMLCBtYXhfdGltZW91dF9tcywgaXNBbHJlYWR5TG9hZGVkKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKGlzQWxyZWFkeUxvYWRlZCkge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2NyaXB0VGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICBzY3JpcHRUYWcuc3JjID0gc2NyaXB0VVJMO1xuICAgICAgdmFyIHRpbWVySUQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgbWVzc2FnZTogXCJUaW1lb3V0IGxvYWRpbmcgc2NyaXB0IFwiLmNvbmNhdChzY3JpcHRVUkwpXG4gICAgICAgIH0pO1xuICAgICAgfSwgbWF4X3RpbWVvdXRfbXMpOyAvLyAxMCBzZWNvbmRzIGZvciB0aW1lb3V0XG5cbiAgICAgIHNjcmlwdFRhZy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJRCk7IC8vIGNsZWFyIHRpbWVvdXQgcmVqZWN0IGVycm9yXG4gICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICAgIG1lc3NhZ2U6IFwiRXJyb3IgbG9hZGluZyBcIi5jb25jYXQoc2NyaXB0VVJMKVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBzY3JpcHRUYWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJRCk7IC8vIGNsZWFyIHRpbWVvdXQgcmVqZWN0IGVycm9yXG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdFRhZyk7XG4gICAgfVxuICB9KTtcbn1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHhocl9sb2FkU2NyaXB0ID0gKGxvYWRTY3JpcHQpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC94aHIvZ2V0QmxvYkZyb21VUkwuanNcbi8qKlxuICogUmVqZWN0IG9uIHRpbWVvdXRcbiAqIEBwYXJhbSBtYXhUaW1lb3V0TVNcbiAqIEBwYXJhbSByZWplY3RcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRpbWVySURcbiAqL1xuZnVuY3Rpb24gcmVqZWN0T25UaW1lb3V0KG1heFRpbWVvdXRNUywgcmVqZWN0KSB7XG4gIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICByZWplY3Qoe1xuICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgbWVzc2FnZTogJ1RpbWVvdXQgbG9hZGluZyBCbG9iIFVSTCdcbiAgICB9KTtcbiAgfSwgbWF4VGltZW91dE1TKTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gQ29udmVydHMgYSBVUkwgdG8gYSBCTE9CIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHVybFRvTG9hZFxuICogQHBhcmFtIHtudW1iZXJ9IG1heF90aW1lb3V0X21zIC0gVGltZSB0byBlbGFwc2UgYmVmb3JlIHByb21pc2UgaXMgcmVqZWN0ZWRcbiAqIEByZXR1cm4ge1Byb21pc2U8e1xuICogICBzdGF0dXM6ICdzdWNjZXNzJyB8ICdlcnJvcidcbiAqICAgbWVzc2FnZT86IHN0cmluZyxcbiAqICAgIHBheWxvYWQ6IHtcbiAqICAgICAgdXJsOiBzdHJpbmdcbiAqICAgIH1cbiAqIH0+fVxuICovXG5mdW5jdGlvbiBnZXRCbG9iRnJvbVVSTCh1cmxUb0xvYWQsIG1heFRpbWVvdXRNUykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciB0aW1lcklEID0gcmVqZWN0T25UaW1lb3V0KG1heFRpbWVvdXRNUywgcmVqZWN0KTtcblxuICAgIC8vIElmIGZldGNoIGV4aXN0cywgdXNlIGl0IHRvIGZldGNoIGJsb2IsIG90aGVyd2lzZSB1c2UgWEhSLlxuICAgIC8vIFhIUiBjYXVzZXMgaXNzdWVzIG9uIHNhZmFyaSAxNC4xIHNvIHdlIHByZWZlciBmZXRjaFxuICAgIHZhciBmZXRjaEJsb2IgPSB0eXBlb2YgZmV0Y2ggIT09ICd1bmRlZmluZWQnICYmIGZldGNoID8gbG9hZFVybFVzaW5nRmV0Y2ggOiBsb2FkVXJsVXNpbmdYaHI7XG4gICAgZmV0Y2hCbG9iKHVybFRvTG9hZCkudGhlbihmdW5jdGlvbiAoYmxvYikge1xuICAgICAgcmVzb2x2ZSh7XG4gICAgICAgIHN0YXR1czogJ3N1Y2Nlc3MnLFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgYmxvYlVSTDogVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlamVjdCh7XG4gICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgbWVzc2FnZTogJ0Vycm9yIGxvYWRpbmcgQmxvYiBVUkwnXG4gICAgICB9KTtcbiAgICB9KVtcImZpbmFsbHlcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgLy8gQ2xlYXIgdGhlIHRpbWVvdXQgdGltZXIgb24gZmFpbCBvciBzdWNjZXNzLlxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySUQpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBVc2UgZmV0Y2ggZnVuY3Rpb24gdG8gZmV0Y2ggZmlsZVxuICogQHBhcmFtIHVybFRvTG9hZFxuICogQHJldHVybnMge1Byb21pc2U8dW5rbm93bj59XG4gKi9cbmZ1bmN0aW9uIGxvYWRVcmxVc2luZ0ZldGNoKHVybFRvTG9hZCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZldGNoKHVybFRvTG9hZCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIHJlc3BvbnNlLmJsb2IoKS50aGVuKGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICAgIHJlc29sdmUoYmxvYik7XG4gICAgICB9KTtcbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlamVjdCgnZXJyb3InKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogVXNlIFhIUiB0byBmZXRjaCBmaWxlXG4gKiBAcGFyYW0gdXJsVG9Mb2FkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx1bmtub3duPn1cbiAqL1xuZnVuY3Rpb24gbG9hZFVybFVzaW5nWGhyKHVybFRvTG9hZCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIHJlc29sdmUoeGhyLnJlc3BvbnNlKTtcbiAgICB9O1xuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmVqZWN0KCdlcnJvcicpO1xuICAgIH07XG4gICAgeGhyLm9wZW4oJ0dFVCcsIHVybFRvTG9hZCwgdHJ1ZSk7XG4gICAgeGhyLnNlbmQoKTtcbiAgfSk7XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB4aHJfZ2V0QmxvYkZyb21VUkwgPSAoZ2V0QmxvYkZyb21VUkwpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9mZWF0dXJlcy90cmFuc3BhcmVudFZpZGVvL2NyZWF0ZUhpZGRlblZpZGVvVGFnLmpzXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgaGlkZGVuIEhUTUxWaWRlb0VsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIHZpZGVvT3B0aW9uc1xuICogQHBhcmFtIHt7YXV0b3BsYXksIHBsYXlzaW5saW5lLCBsb29wLCBtdXRlZCwgcG9zdGVyLCBibG9iVVJMLCB2aWRlb1VSTCB9fSB2aWRlb09wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmlkZW9PcHRpb25zLmF1dG9wbGF5IC0gYXV0b3BsYXlzIHRoZSB2aWRlbyBpZiB0cnVlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmlkZW9PcHRpb25zLmJsb2JVUkwgLSB0aGUgYmxvYlVSTCB0byBzZXQgYXMgdmlkZW8uc3JjXG4gKiBAcGFyYW0ge3N0cmluZ30gdmlkZW9PcHRpb25zLnZpZGVvVVJMIC0gdGhlIG9yaWdpbmFsIHZpZGVvVVJMIHRoZSB1c2VyIGNyZWF0ZWQgKHdpdGggdHJhbnNmb3JtYXRpb25zKVxuICogQHJldHVybiB7SFRNTFZpZGVvRWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSGlkZGVuVmlkZW9UYWcodmlkZW9PcHRpb25zKSB7XG4gIHZhciBhdXRvcGxheSA9IHZpZGVvT3B0aW9ucy5hdXRvcGxheSxcbiAgICBwbGF5c2lubGluZSA9IHZpZGVvT3B0aW9ucy5wbGF5c2lubGluZSxcbiAgICBsb29wID0gdmlkZW9PcHRpb25zLmxvb3AsXG4gICAgbXV0ZWQgPSB2aWRlb09wdGlvbnMubXV0ZWQsXG4gICAgcG9zdGVyID0gdmlkZW9PcHRpb25zLnBvc3RlcixcbiAgICBibG9iVVJMID0gdmlkZW9PcHRpb25zLmJsb2JVUkwsXG4gICAgdmlkZW9VUkwgPSB2aWRlb09wdGlvbnMudmlkZW9VUkw7XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gIGVsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgZWwucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBlbC54ID0gMDtcbiAgZWwueSA9IDA7XG4gIGVsLnNyYyA9IGJsb2JVUkw7XG4gIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS12aWRlby11cmwnLCB2aWRlb1VSTCk7IC8vIGZvciBkZWJ1Z2dpbmcvdGVzdGluZ1xuXG4gIGF1dG9wbGF5ICYmIGVsLnNldEF0dHJpYnV0ZSgnYXV0b3BsYXknLCBhdXRvcGxheSk7XG4gIHBsYXlzaW5saW5lICYmIGVsLnNldEF0dHJpYnV0ZSgncGxheXNpbmxpbmUnLCBwbGF5c2lubGluZSk7XG4gIGxvb3AgJiYgZWwuc2V0QXR0cmlidXRlKCdsb29wJywgbG9vcCk7XG4gIG11dGVkICYmIGVsLnNldEF0dHJpYnV0ZSgnbXV0ZWQnLCBtdXRlZCk7XG4gIG11dGVkICYmIChlbC5tdXRlZCA9IG11dGVkKTsgLy8gdGhpcyBpcyBhbHNvIG5lZWRlZCBmb3IgYXV0b3BsYXksIG9uIHRvcCBvZiBzZXRBdHRyaWJ1dGVcbiAgcG9zdGVyICYmIGVsLnNldEF0dHJpYnV0ZSgncG9zdGVyJywgcG9zdGVyKTtcblxuICAvLyBGcmVlIG1lbW9yeSBhdCB0aGUgZW5kIG9mIHRoZSBmaWxlIGxvYWRpbmcuXG4gIGVsLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGJsb2JVUkwpO1xuICB9O1xuICByZXR1cm4gZWw7XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BhcmVudFZpZGVvX2NyZWF0ZUhpZGRlblZpZGVvVGFnID0gKGNyZWF0ZUhpZGRlblZpZGVvVGFnKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvZmVhdHVyZXMvdHJhbnNwYXJlbnRWaWRlby9pbnN0YW50aWF0ZVNlZVRocnUuanNcbi8qKlxuICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gY3JlYXRlcyBhIG5ldyBpbnN0YW5jIGVvZiBzZWVUaHJ1IChzZWVUaHJ1LmNyZWF0ZSgpKSBhbmQgcmV0dXJucyBhIHByb21pc2Ugb2YgdGhlIHNlZVRocnUgaW5zdGFuY2VcbiAqIEBwYXJhbSB7SFRNTFZpZGVvRWxlbWVudH0gdmlkZW9FbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gbWF4X3RpbWVvdXRfbXMgLSBUaW1lIHRvIGVsYXBzZSBiZWZvcmUgcHJvbWlzZSBpcyByZWplY3RlZFxuICogQHBhcmFtIHtzdHJpbmd9IGN1c3RvbUNsYXNzIC0gQSBjbGFzc25hbWUgdG8gYmUgYWRkZWQgdG8gdGhlIGNhbnZhcyBlbGVtZW50IGNyZWF0ZWQgYnkgc2VlVGhydVxuICogQHBhcmFtIHtib29sZWFufSBhdXRvUGxheVxuICogQHJldHVybiB7UHJvbWlzZTxhbnk+fSBTZWVUaHJ1IGluc3RhbmNlIG9yIHJlamVjdGlvbiBlcnJvclxuICovXG5mdW5jdGlvbiBpbnN0YW50aWF0ZVNlZVRocnUodmlkZW9FbGVtZW50LCBtYXhfdGltZW91dF9tcywgY3VzdG9tQ2xhc3MsIGF1dG9QbGF5KSB7XG4gIHZhciBfd2luZG93ID0gd2luZG93LFxuICAgIHNlZVRocnUgPSBfd2luZG93LnNlZVRocnUsXG4gICAgc2V0VGltZW91dCA9IF93aW5kb3cuc2V0VGltZW91dCxcbiAgICBjbGVhclRpbWVvdXQgPSBfd2luZG93LmNsZWFyVGltZW91dDtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgdGltZXJJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmVqZWN0KHtcbiAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICBtZXNzYWdlOiAnVGltZW91dCBpbnN0YW50aWF0aW5nIHNlZVRocnUgaW5zdGFuY2UnXG4gICAgICB9KTtcbiAgICB9LCBtYXhfdGltZW91dF9tcyk7XG4gICAgaWYgKHNlZVRocnUpIHtcbiAgICAgIHZhciBzZWVUaHJ1SW5zdGFuY2UgPSBzZWVUaHJ1LmNyZWF0ZSh2aWRlb0VsZW1lbnQpLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gY2xlYXIgdGltZW91dCByZWplY3QgZXJyb3JcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySUQpO1xuXG4gICAgICAgIC8vIGZvcmNlIGNvbnRhaW5lciB3aWR0aCwgZWxzZSB0aGUgY2FudmFzIGNhbiBvdmVyZmxvdyBvdXRcbiAgICAgICAgdmFyIGNhbnZhc0VsZW1lbnQgPSBzZWVUaHJ1SW5zdGFuY2UuZ2V0Q2FudmFzKCk7XG4gICAgICAgIGNhbnZhc0VsZW1lbnQuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIGNhbnZhc0VsZW1lbnQuY2xhc3NOYW1lICs9ICcgJyArIGN1c3RvbUNsYXNzO1xuXG4gICAgICAgIC8vIHN0YXJ0IHRoZSB2aWRlbyBpZiBhdXRvcGxheSBpcyBzZXRcbiAgICAgICAgaWYgKGF1dG9QbGF5KSB7XG4gICAgICAgICAgc2VlVGhydUluc3RhbmNlLnBsYXkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHNlZVRocnVJbnN0YW5jZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVqZWN0KHtcbiAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICBtZXNzYWdlOiAnRXJyb3IgaW5zdGFudGlhdGluZyBzZWVUaHJ1IGluc3RhbmNlJ1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRyYW5zcGFyZW50VmlkZW9faW5zdGFudGlhdGVTZWVUaHJ1ID0gKGluc3RhbnRpYXRlU2VlVGhydSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2ZlYXR1cmVzL3RyYW5zcGFyZW50VmlkZW8vbW91bnRTZWVUaHJ1Q2FudmFzVGFnLmpzXG5cblxuXG5cblxuLyoqXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaHRtbEVsQ29udGFpbmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gdmlkZW9VUkxcbiAqIEBwYXJhbSB7VHJhbnNmb3JtYXRpb25PcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJuIHtQcm9taXNlPGFueT59XG4gKi9cbmZ1bmN0aW9uIG1vdW50U2VlVGhydUNhbnZhc1RhZyhodG1sRWxDb250YWluZXIsIHZpZGVvVVJMLCBvcHRpb25zKSB7XG4gIHZhciBwb3N0ZXIgPSBvcHRpb25zLnBvc3RlcixcbiAgICBhdXRvcGxheSA9IG9wdGlvbnMuYXV0b3BsYXksXG4gICAgcGxheXNpbmxpbmUgPSBvcHRpb25zLnBsYXlzaW5saW5lLFxuICAgIGxvb3AgPSBvcHRpb25zLmxvb3AsXG4gICAgbXV0ZWQgPSBvcHRpb25zLm11dGVkO1xuICB2aWRlb1VSTCA9IHZpZGVvVVJMICsgJy5tcDQnOyAvLyBzZWVUaHJ1IGFsd2F5cyB1c2VzIG1wNFxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHhocl9sb2FkU2NyaXB0KG9wdGlvbnMuZXh0ZXJuYWxMaWJyYXJpZXMuc2VlVGhydSwgb3B0aW9ucy5tYXhfdGltZW91dF9tcywgd2luZG93LnNlZVRocnUpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgeGhyX2dldEJsb2JGcm9tVVJMKHZpZGVvVVJMLCBvcHRpb25zLm1heF90aW1lb3V0X21zKS50aGVuKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBwYXlsb2FkID0gX3JlZi5wYXlsb2FkO1xuICAgICAgICB2YXIgdmlkZW9FbGVtZW50ID0gdHJhbnNwYXJlbnRWaWRlb19jcmVhdGVIaWRkZW5WaWRlb1RhZyh7XG4gICAgICAgICAgYmxvYlVSTDogcGF5bG9hZC5ibG9iVVJMLFxuICAgICAgICAgIHZpZGVvVVJMOiB2aWRlb1VSTCxcbiAgICAgICAgICAvLyBmb3IgZGVidWdnaW5nL3Rlc3RpbmdcbiAgICAgICAgICBwb3N0ZXI6IHBvc3RlcixcbiAgICAgICAgICBhdXRvcGxheTogYXV0b3BsYXksXG4gICAgICAgICAgcGxheXNpbmxpbmU6IHBsYXlzaW5saW5lLFxuICAgICAgICAgIGxvb3A6IGxvb3AsXG4gICAgICAgICAgbXV0ZWQ6IG11dGVkXG4gICAgICAgIH0pO1xuICAgICAgICBodG1sRWxDb250YWluZXIuYXBwZW5kQ2hpbGQodmlkZW9FbGVtZW50KTtcbiAgICAgICAgdHJhbnNwYXJlbnRWaWRlb19pbnN0YW50aWF0ZVNlZVRocnUodmlkZW9FbGVtZW50LCBvcHRpb25zLm1heF90aW1lb3V0X21zLCBvcHRpb25zW1wiY2xhc3NcIl0sIG9wdGlvbnMuYXV0b3BsYXkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlc29sdmUoaHRtbEVsQ29udGFpbmVyKTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNhdGNoIGZvciBnZXRCbG9iRnJvbVVSTCgpXG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICB2YXIgc3RhdHVzID0gX3JlZjIuc3RhdHVzLFxuICAgICAgICAgIG1lc3NhZ2UgPSBfcmVmMi5tZXNzYWdlO1xuICAgICAgICByZWplY3Qoe1xuICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8vIGNhdGNoIGZvciBsb2FkU2NyaXB0KClcbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgdmFyIHN0YXR1cyA9IF9yZWYzLnN0YXR1cyxcbiAgICAgICAgbWVzc2FnZSA9IF9yZWYzLm1lc3NhZ2U7XG4gICAgICByZWplY3Qoe1xuICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdHJhbnNwYXJlbnRWaWRlb19tb3VudFNlZVRocnVDYW52YXNUYWcgPSAobW91bnRTZWVUaHJ1Q2FudmFzVGFnKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvZmVhdHVyZXMvdHJhbnNwYXJlbnRWaWRlby9jaGVja1N1cHBvcnRGb3JUcmFuc3BhcmVuY3kuanNcbi8qKlxuICogQHJldHVybiB7UHJvbWlzZTxib29sZWFuPn0gLSBXaGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIHRyYW5zcGFyZW50IHZpZGVvcyBvciBub3RcbiAqL1xuXG5mdW5jdGlvbiBjaGVja1N1cHBvcnRGb3JUcmFuc3BhcmVuY3koKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgLy8gUmVzb2x2ZSBlYXJseSBmb3Igc2FmYXJpLlxuICAgIC8vIEN1cnJlbnRseSAoMjkgRGVjZW1iZXIgMjAyMSkgU2FmYXJpIGNhbiBwbGF5IHdlYm0vdnA5LFxuICAgIC8vIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0IHRyYW5zcGFyZW50IHZpZGVvIGluIHRoZSBmb3JtYXQgd2UncmUgb3V0cHV0dGluZ1xuICAgIGlmIChpc1NhZmFyaSgpKSB7XG4gICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICB9XG4gICAgdmFyIHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICB2YXIgY2FuUGxheSA9IHZpZGVvLmNhblBsYXlUeXBlICYmIHZpZGVvLmNhblBsYXlUeXBlKCd2aWRlby93ZWJtOyBjb2RlY3M9XCJ2cDlcIicpO1xuICAgIHJlc29sdmUoY2FuUGxheSA9PT0gJ21heWJlJyB8fCBjYW5QbGF5ID09PSAncHJvYmFibHknKTtcbiAgfSk7XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BhcmVudFZpZGVvX2NoZWNrU3VwcG9ydEZvclRyYW5zcGFyZW5jeSA9IChjaGVja1N1cHBvcnRGb3JUcmFuc3BhcmVuY3kpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY2xvdWRpbmFyeS5qc1xuZnVuY3Rpb24gY2xvdWRpbmFyeV90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBjbG91ZGluYXJ5X3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBjbG91ZGluYXJ5X3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gY2xvdWRpbmFyeV9jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxuZnVuY3Rpb24gY2xvdWRpbmFyeV9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIGNsb3VkaW5hcnlfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIGNsb3VkaW5hcnlfY3JlYXRlQ2xhc3MoZSwgciwgdCkgeyByZXR1cm4gciAmJiBjbG91ZGluYXJ5X2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIGNsb3VkaW5hcnlfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBjbG91ZGluYXJ5X3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IGNsb3VkaW5hcnlfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IGNsb3VkaW5hcnlfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBjbG91ZGluYXJ5X3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gY2xvdWRpbmFyeV90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gY2xvdWRpbmFyeV90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuXG52YXIgYXBwbHlCcmVha3BvaW50cywgY2xvc2VzdEFib3ZlLCBkZWZhdWx0QnJlYWtwb2ludHMsIGNsb3VkaW5hcnlfZmluZENvbnRhaW5lcldpZHRoLCBjbG91ZGluYXJ5X21heFdpZHRoLCB1cGRhdGVEcHI7XG5cblxuXG5cblxuXG5cblxuXG5cbi8vXG5cblxuXG5cblxuZGVmYXVsdEJyZWFrcG9pbnRzID0gZnVuY3Rpb24gZGVmYXVsdEJyZWFrcG9pbnRzKHdpZHRoKSB7XG4gIHZhciBzdGVwcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTAwO1xuICByZXR1cm4gc3RlcHMgKiBNYXRoLmNlaWwod2lkdGggLyBzdGVwcyk7XG59O1xuY2xvc2VzdEFib3ZlID0gZnVuY3Rpb24gY2xvc2VzdEFib3ZlKGxpc3QsIHZhbHVlKSB7XG4gIHZhciBpO1xuICBpID0gbGlzdC5sZW5ndGggLSAyO1xuICB3aGlsZSAoaSA+PSAwICYmIGxpc3RbaV0gPj0gdmFsdWUpIHtcbiAgICBpLS07XG4gIH1cbiAgcmV0dXJuIGxpc3RbaSArIDFdO1xufTtcbmFwcGx5QnJlYWtwb2ludHMgPSBmdW5jdGlvbiBhcHBseUJyZWFrcG9pbnRzKHRhZywgd2lkdGgsIHN0ZXBzLCBvcHRpb25zKSB7XG4gIHZhciByZWYsIHJlZjEsIHJlZjIsIHJlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzO1xuICByZXNwb25zaXZlX3VzZV9icmVha3BvaW50cyA9IChyZWYgPSAocmVmMSA9IChyZWYyID0gb3B0aW9uc1sncmVzcG9uc2l2ZV91c2VfYnJlYWtwb2ludHMnXSkgIT0gbnVsbCA/IHJlZjIgOiBvcHRpb25zWydyZXNwb25zaXZlX3VzZV9zdG9wcG9pbnRzJ10pICE9IG51bGwgPyByZWYxIDogdGhpcy5jb25maWcoJ3Jlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzJykpICE9IG51bGwgPyByZWYgOiB0aGlzLmNvbmZpZygncmVzcG9uc2l2ZV91c2Vfc3RvcHBvaW50cycpO1xuICBpZiAoIXJlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzIHx8IHJlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzID09PSAncmVzaXplJyAmJiAhb3B0aW9ucy5yZXNpemluZykge1xuICAgIHJldHVybiB3aWR0aDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5jYWxjX2JyZWFrcG9pbnQodGFnLCB3aWR0aCwgc3RlcHMpO1xuICB9XG59O1xuY2xvdWRpbmFyeV9maW5kQ29udGFpbmVyV2lkdGggPSBmdW5jdGlvbiBmaW5kQ29udGFpbmVyV2lkdGgoZWxlbWVudCkge1xuICB2YXIgY29udGFpbmVyV2lkdGgsIHN0eWxlO1xuICBjb250YWluZXJXaWR0aCA9IDA7XG4gIHdoaWxlICgoZWxlbWVudCA9IGVsZW1lbnQgIT0gbnVsbCA/IGVsZW1lbnQucGFyZW50Tm9kZSA6IHZvaWQgMCkgaW5zdGFuY2VvZiBFbGVtZW50ICYmICFjb250YWluZXJXaWR0aCkge1xuICAgIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgaWYgKCEvXmlubGluZS8udGVzdChzdHlsZS5kaXNwbGF5KSkge1xuICAgICAgY29udGFpbmVyV2lkdGggPSBsb2Rhc2hfd2lkdGgoZWxlbWVudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb250YWluZXJXaWR0aDtcbn07XG51cGRhdGVEcHIgPSBmdW5jdGlvbiB1cGRhdGVEcHIoZGF0YVNyYywgcm91bmREcHIpIHtcbiAgcmV0dXJuIGRhdGFTcmMucmVwbGFjZSgvXFxiZHByXygxXFwuMHxhdXRvKVxcYi9nLCAnZHByXycgKyB0aGlzLmRldmljZV9waXhlbF9yYXRpbyhyb3VuZERwcikpO1xufTtcbmNsb3VkaW5hcnlfbWF4V2lkdGggPSBmdW5jdGlvbiBtYXhXaWR0aChyZXF1aXJlZFdpZHRoLCB0YWcpIHtcbiAgdmFyIGltYWdlV2lkdGg7XG4gIGltYWdlV2lkdGggPSBsb2Rhc2hfZ2V0RGF0YSh0YWcsICd3aWR0aCcpIHx8IDA7XG4gIGlmIChyZXF1aXJlZFdpZHRoID4gaW1hZ2VXaWR0aCkge1xuICAgIGltYWdlV2lkdGggPSByZXF1aXJlZFdpZHRoO1xuICAgIGxvZGFzaF9zZXREYXRhKHRhZywgJ3dpZHRoJywgcmVxdWlyZWRXaWR0aCk7XG4gIH1cbiAgcmV0dXJuIGltYWdlV2lkdGg7XG59O1xudmFyIGNsb3VkaW5hcnlfQ2xvdWRpbmFyeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IENsb3VkaW5hcnkgaW5zdGFuY2UuXG4gICAqIEBjbGFzcyBDbG91ZGluYXJ5XG4gICAqIEBjbGFzc2Rlc2MgTWFpbiBjbGFzcyBmb3IgYWNjZXNzaW5nIENsb3VkaW5hcnkgZnVuY3Rpb25hbGl0eS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBBIHtAbGluayBDb25maWd1cmF0aW9ufSBvYmplY3QgZm9yIGdsb2JhbGx5IGNvbmZpZ3VyaW5nIENsb3VkaW5hcnkgYWNjb3VudCBzZXR0aW5ncy5cbiAgICogQGV4YW1wbGU8YnIvPlxuICAgKiAgdmFyIGNsID0gbmV3IGNsb3VkaW5hcnkuQ2xvdWRpbmFyeSggeyBjbG91ZF9uYW1lOiBcIm15Y2xvdWRcIn0pOzxici8+XG4gICAqICB2YXIgaW1nVGFnID0gY2wuaW1hZ2UoXCJteVBpY0lEXCIpO1xuICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc29sdXRpb25fb3ZlcnZpZXcjY29uZmlndXJhdGlvbl9wYXJhbWV0ZXJzXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAqICBBdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgKi9cbiAgZnVuY3Rpb24gQ2xvdWRpbmFyeShvcHRpb25zKSB7XG4gICAgY2xvdWRpbmFyeV9jbGFzc0NhbGxDaGVjayh0aGlzLCBDbG91ZGluYXJ5KTtcbiAgICB2YXIgY29uZmlndXJhdGlvbjtcbiAgICB0aGlzLmRldmljZVBpeGVsUmF0aW9DYWNoZSA9IHt9O1xuICAgIHRoaXMucmVzcG9uc2l2ZUNvbmZpZyA9IHt9O1xuICAgIHRoaXMucmVzcG9uc2l2ZVJlc2l6ZUluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgY29uZmlndXJhdGlvbiA9IG5ldyBzcmNfY29uZmlndXJhdGlvbihvcHRpb25zKTtcbiAgICAvLyBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgIHRoaXMuY29uZmlnID0gZnVuY3Rpb24gKG5ld0NvbmZpZywgbmV3VmFsdWUpIHtcbiAgICAgIHJldHVybiBjb25maWd1cmF0aW9uLmNvbmZpZyhuZXdDb25maWcsIG5ld1ZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVzZSBcXDxtZXRhXFw+IHRhZ3MgaW4gdGhlIGRvY3VtZW50IHRvIGNvbmZpZ3VyZSB0aGlzIGBjbG91ZGluYXJ5YCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJuIFRoaXMge0Nsb3VkaW5hcnl9IGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICB0aGlzLmZyb21Eb2N1bWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbmZpZ3VyYXRpb24uZnJvbURvY3VtZW50KCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVzZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdG8gY29uZmlndXJlIHRoaXMgYGNsb3VkaW5hcnlgIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm4gVGhpcyB7Q2xvdWRpbmFyeX0gaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHRoaXMuZnJvbUVudmlyb25tZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgY29uZmlndXJhdGlvbi5mcm9tRW52aXJvbm1lbnQoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhpcyBgY2xvdWRpbmFyeWAgaW5zdGFuY2UuXG4gICAgICogIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBtZXRob2QgdGhhdCBpbnZva2VzIGJvdGgge0BsaW5rIENvbmZpZ3VyYXRpb24jZnJvbUVudmlyb25tZW50fGZyb21FbnZpcm9ubWVudCgpfVxuICAgICAqICAoTm9kZS5qcyBlbnZpcm9ubWVudCBvbmx5KSBhbmQge0BsaW5rIENvbmZpZ3VyYXRpb24jZnJvbURvY3VtZW50fGZyb21Eb2N1bWVudCgpfS5cbiAgICAgKiAgSXQgZmlyc3QgdHJpZXMgdG8gcmV0cmlldmUgdGhlIGNvbmZpZ3VyYXRpb24gZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUuXG4gICAgICogIElmIG5vdCBhdmFpbGFibGUsIGl0IHRyaWVzIGZyb20gdGhlIGRvY3VtZW50IG1ldGEgdGFncy5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNpbml0XG4gICAgICogQHNlZSBDb25maWd1cmF0aW9uI2luaXRcbiAgICAgKiBAcmV0dXJuIFRoaXMge0Nsb3VkaW5hcnl9IGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICB0aGlzLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25maWd1cmF0aW9uLmluaXQoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ29udmVuaWVuY2UgY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7Q2xvdWRpbmFyeX1cbiAgICogQGV4YW1wbGUgY2wgPSBjbG91ZGluYXJ5LkNsb3VkaW5hcnkubmV3KCB7IGNsb3VkX25hbWU6IFwibXljbG91ZFwifSlcbiAgICovXG4gIHJldHVybiBjbG91ZGluYXJ5X2NyZWF0ZUNsYXNzKENsb3VkaW5hcnksIFt7XG4gICAga2V5OiBcInVybFwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIFVSTCBmb3IgYW55IGFzc2V0IGluIHlvdXIgTWVkaWEgbGlicmFyeS5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSN1cmxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgcHVibGljIElEIG9mIHRoZSBtZWRpYSBhc3NldC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycyB0byBpbmNsdWRlIGluIHRoZSBVUkwuXG4gICAgICogQHBhcmFtIHt0eXBlfSBbb3B0aW9ucy50eXBlPSd1cGxvYWQnXSAtIFRoZSBhc3NldCdzIHN0b3JhZ2UgdHlwZS5cbiAgICAgKiAgRm9yIGRldGFpbHMgb24gYWxsIGZldGNoIHR5cGVzLCBzZWVcbiAgICAgKiA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9ucyNmZXRjaGluZ19pbWFnZXNfZnJvbV9yZW1vdGVfbG9jYXRpb25zXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+RmV0Y2ggdHlwZXM8L2E+LlxuICAgICAqIEBwYXJhbSB7cmVzb3VyY2VUeXBlfSBbb3B0aW9ucy5yZXNvdXJjZV90eXBlPSdpbWFnZSddIC0gVGhlIHR5cGUgb2YgYXNzZXQuIFBvc3NpYmxlIHZhbHVlczo8YnIvPlxuICAgICAqICAtIGBpbWFnZWA8YnIvPlxuICAgICAqICAtIGB2aWRlb2A8YnIvPlxuICAgICAqICAtIGByYXdgXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgbWVkaWEgYXNzZXQgVVJMLlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vdmlkZW9fdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSB2aWRlbyB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICovXG4gICAgZnVuY3Rpb24gdXJsKHB1YmxpY0lkKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICByZXR1cm4gdXJsX3VybChwdWJsaWNJZCwgb3B0aW9ucywgdGhpcy5jb25maWcoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdmlkZW8gYXNzZXQgVVJMLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3ZpZGVvX3VybFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBwdWJsaWMgSUQgb2YgdGhlIHZpZGVvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzIHRvIGluY2x1ZGUgaW4gdGhlIFVSTC5cbiAgICAgKiBAcGFyYW0ge3R5cGV9IFtvcHRpb25zLnR5cGU9J3VwbG9hZCddIC0gVGhlIGFzc2V0J3Mgc3RvcmFnZSB0eXBlLlxuICAgICAqICBGb3IgZGV0YWlscyBvbiBhbGwgZmV0Y2ggdHlwZXMsIHNlZVxuICAgICAqICA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9ucyNmZXRjaGluZ19pbWFnZXNfZnJvbV9yZW1vdGVfbG9jYXRpb25zXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+RmV0Y2ggdHlwZXM8L2E+LlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHZpZGVvIFVSTC5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vdmlkZW9fdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIHZpZGVvIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ2aWRlb191cmxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmlkZW9fdXJsKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh7XG4gICAgICAgIHJlc291cmNlX3R5cGU6ICd2aWRlbydcbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMudXJsKHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBVUkwgZm9yIGFuIGltYWdlIGludGVuZGVkIHRvIGJlIHVzZWQgYXMgYSB0aHVtYm5haWwgZm9yIHRoZSBzcGVjaWZpZWQgdmlkZW8uXG4gICAgICogIElkZW50aWNhbCB0byB7QGxpbmsgQ2xvdWRpbmFyeSN1cmx8dXJsfSwgZXhjZXB0IHRoYXQgdGhlIGByZXNvdXJjZV90eXBlYCBpcyBgdmlkZW9gXG4gICAgICogIGFuZCB0aGUgZGVmYXVsdCBgZm9ybWF0YCBpcyBganBnYC5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSN2aWRlb190aHVtYm5haWxfdXJsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdmlkZW8gZnJvbSB3aGljaCB5b3Ugd2FudCB0byBnZW5lcmF0ZSBhIHRodW1ibmFpbCBpbWFnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIGltYWdlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycyB0byBhcHBseSB0byB0aGUgdGh1bWJuYWlsLlxuICAgICAqIEluIGFkZGl0aW9uIHRvIHN0YW5kYXJkIGltYWdlIHRyYW5zZm9ybWF0aW9ucywgeW91IGNhbiBhbHNvIHVzZSB0aGUgYHN0YXJ0X29mZnNldGAgdHJhbnNmb3JtYXRpb24gcGFyYW1ldGVyXG4gICAgICogdG8gaW5zdHJ1Y3QgQ2xvdWRpbmFyeSB0byBnZW5lcmF0ZSB0aGUgdGh1bWJuYWlsIGZyb20gYSBmcmFtZSBvdGhlciB0aGFuIHRoZSBtaWRkbGUgZnJhbWUgb2YgdGhlIHZpZGVvLlxuICAgICAqIEZvciBkZXRhaWxzLCBzZWVcbiAgICAgKiA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX21hbmlwdWxhdGlvbl9hbmRfZGVsaXZlcnkjZ2VuZXJhdGluZ192aWRlb190aHVtYm5haWxzXCJcbiAgICAgKiB0YXJnZXQ9XCJfYmxhbmtcIj5HZW5lcmF0aW5nIHZpZGVvIHRodW1ibmFpbHM8L2E+IGluIHRoZSBDbG91ZGluYXJ5IGRvY3VtZW50YXRpb24uXG4gICAgICogQHBhcmFtIHt0eXBlfSBbb3B0aW9ucy50eXBlPSd1cGxvYWQnXSAtIFRoZSBhc3NldCdzIHN0b3JhZ2UgdHlwZS5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVUkwgb2YgdGhlIHZpZGVvIHRodW1ibmFpbCBpbWFnZS5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidmlkZW9fdGh1bWJuYWlsX3VybFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2aWRlb190aHVtYm5haWxfdXJsKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh7fSwgREVGQVVMVF9QT1NURVJfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy51cmwocHVibGljSWQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3BlY2lmaWVkIHRyYW5zZm9ybWF0aW9uIG9wdGlvbnMuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjdHJhbnNmb3JtYXRpb25fc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBvcHRpb25zLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB0cmFuc2Zvcm1hdGlvbiBzdHJpbmcuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi92aWRlb190cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIHZpZGVvIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ0cmFuc2Zvcm1hdGlvbl9zdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fc3RyaW5nKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgc3JjX3RyYW5zZm9ybWF0aW9uKG9wdGlvbnMpLnNlcmlhbGl6ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhbiBpbWFnZSB0YWcuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjaW1hZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgcHVibGljIElEIG9mIHRoZSBpbWFnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMsIHtAbGluayBDb25maWd1cmF0aW9ufSBwYXJhbWV0ZXJzLFxuICAgICAqICBhbmQgc3RhbmRhcmQgSFRNTCAmbHQ7aW1nJmd0OyB0YWcgYXR0cmlidXRlcyB0byBhcHBseSB0byB0aGUgaW1hZ2UgdGFnLlxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEFuIGltYWdlIHRhZyBET00gZWxlbWVudC5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW1hZ2UocHVibGljSWQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciBjbGllbnRfaGludHMsIGltZywgcmVmO1xuICAgICAgaW1nID0gdGhpcy5pbWFnZVRhZyhwdWJsaWNJZCwgb3B0aW9ucyk7XG4gICAgICBjbGllbnRfaGludHMgPSAocmVmID0gb3B0aW9ucy5jbGllbnRfaGludHMgIT0gbnVsbCA/IG9wdGlvbnMuY2xpZW50X2hpbnRzIDogdGhpcy5jb25maWcoJ2NsaWVudF9oaW50cycpKSAhPSBudWxsID8gcmVmIDogZmFsc2U7XG4gICAgICBpZiAob3B0aW9ucy5zcmMgPT0gbnVsbCAmJiAhY2xpZW50X2hpbnRzKSB7XG4gICAgICAgIC8vIHNyYyBtdXN0IGJlIHJlbW92ZWQgYmVmb3JlIGNyZWF0aW5nIHRoZSBET00gZWxlbWVudCB0byBhdm9pZCBsb2FkaW5nIHRoZSBpbWFnZVxuICAgICAgICBpbWcuc2V0QXR0cihcInNyY1wiLCAnJyk7XG4gICAgICB9XG4gICAgICBpbWcgPSBpbWcudG9ET00oKTtcbiAgICAgIGlmICghY2xpZW50X2hpbnRzKSB7XG4gICAgICAgIC8vIGNhY2hlIHRoZSBpbWFnZSBzcmNcbiAgICAgICAgbG9kYXNoX3NldERhdGEoaW1nLCAnc3JjLWNhY2hlJywgdGhpcy51cmwocHVibGljSWQsIG9wdGlvbnMpKTtcbiAgICAgICAgLy8gc2V0IGltYWdlIHNyYyB0YWtpbmcgcmVzcG9uc2l2ZW5lc3MgaW4gYWNjb3VudFxuICAgICAgICB0aGlzLmNsb3VkaW5hcnlfdXBkYXRlKGltZywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW1nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgSW1hZ2VUYWcgaW5zdGFuY2UgdXNpbmcgdGhlIGNvbmZpZ3VyYXRpb24gZGVmaW5lZCBmb3IgdGhpcyBgY2xvdWRpbmFyeWAgaW5zdGFuY2UuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjaW1hZ2VUYWdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgcHVibGljIElEIG9mIHRoZSBpbWFnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycywge0BsaW5rIENvbmZpZ3VyYXRpb259IHBhcmFtZXRlcnMsXG4gICAgICogIGFuZCBzdGFuZGFyZCBIVE1MICZsdDtpbWcmZ3Q7IHRhZyBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBpbWFnZSB0YWcuXG4gICAgICogQHJldHVybiB7SW1hZ2VUYWd9IEFuIEltYWdlVGFnIGluc3RhbmNlIHRoYXQgaXMgYXR0YWNoZWQgKGNoYWluZWQpIHRvIHRoaXMgQ2xvdWRpbmFyeSBpbnN0YW5jZS5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaW1hZ2VUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW1hZ2VUYWcocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciB0YWc7XG4gICAgICB0YWcgPSBuZXcgaW1hZ2V0YWcocHVibGljSWQsIHRoaXMuY29uZmlnKCkpO1xuICAgICAgdGFnLnRyYW5zZm9ybWF0aW9uKCkuZnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgUGljdHVyZVRhZyBpbnN0YW5jZSwgY29uZmlndXJlZCB1c2luZyB0aGlzIGBjbG91ZGluYXJ5YCBpbnN0YW5jZS5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNQaWN0dXJlVGFnXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gdGhlIHB1YmxpYyBJRCBvZiB0aGUgcmVzb3VyY2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGFkZGl0aW9uYWwgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBuZXcgSW1hZ2VUYWcgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHNvdXJjZXMgLSB0aGUgc291cmNlcyBkZWZpbml0aW9uc1xuICAgICAqIEByZXR1cm4ge1BpY3R1cmVUYWd9IEEgUGljdHVyZVRhZyB0aGF0IGlzIGF0dGFjaGVkIChjaGFpbmVkKSB0byB0aGlzIENsb3VkaW5hcnkgaW5zdGFuY2VcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwaWN0dXJlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBpY3R1cmVUYWcocHVibGljSWQsIG9wdGlvbnMsIHNvdXJjZXMpIHtcbiAgICAgIHZhciB0YWc7XG4gICAgICB0YWcgPSBuZXcgcGljdHVyZXRhZyhwdWJsaWNJZCwgdGhpcy5jb25maWcoKSwgc291cmNlcyk7XG4gICAgICB0YWcudHJhbnNmb3JtYXRpb24oKS5mcm9tT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTb3VyY2VUYWcgaW5zdGFuY2UsIGNvbmZpZ3VyZWQgdXNpbmcgdGhpcyBgY2xvdWRpbmFyeWAgaW5zdGFuY2UuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjU291cmNlVGFnXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gdGhlIHB1YmxpYyBJRCBvZiB0aGUgcmVzb3VyY2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBhZGRpdGlvbmFsIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgbmV3IGluc3RhbmNlLlxuICAgICAqIEByZXR1cm4ge1NvdXJjZVRhZ30gQSBTb3VyY2VUYWcgdGhhdCBpcyBhdHRhY2hlZCAoY2hhaW5lZCkgdG8gdGhpcyBDbG91ZGluYXJ5IGluc3RhbmNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic291cmNlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvdXJjZVRhZyhwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgdmFyIHRhZztcbiAgICAgIHRhZyA9IG5ldyBzb3VyY2V0YWcocHVibGljSWQsIHRoaXMuY29uZmlnKCkpO1xuICAgICAgdGFnLnRyYW5zZm9ybWF0aW9uKCkuZnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHZpZGVvIHRodW1ibmFpbCBVUkwgZnJvbSB0aGUgc3BlY2lmaWVkIHJlbW90ZSB2aWRlbyBhbmQgaW5jbHVkZXMgaXQgaW4gYW4gaW1hZ2UgdGFnLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3ZpZGVvX3RodW1ibmFpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdmlkZW8gZnJvbSB0aGUgcmVsZXZhbnQgdmlkZW8gc2l0ZS5cbiAgICAgKiAgQWRkaXRpb25hbGx5LCBlaXRoZXIgYXBwZW5kIHRoZSBpbWFnZSBleHRlbnNpb24gdHlwZSB0byB0aGUgaWRlbnRpZmllciB2YWx1ZSBvciBzZXRcbiAgICAgKiAgdGhlIGltYWdlIGRlbGl2ZXJ5IGZvcm1hdCBpbiB0aGUgJ29wdGlvbnMnIHBhcmFtZXRlciB1c2luZyB0aGUgJ2Zvcm1hdCcgdHJhbnNmb3JtYXRpb24gb3B0aW9uLlxuICAgICAqICBGb3IgZXhhbXBsZSwgYSBZb3VUdWJlIHZpZGVvIG1pZ2h0IGhhdmUgdGhlIGlkZW50aWZpZXI6ICdvLXVybmxhSnBPQS5qcGcnLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzIHRvIGFwcGx5LlxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEFuIEhUTUwgaW1hZ2UgdGFnIGVsZW1lbnRcbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vdmlkZW9fdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSB2aWRlbyB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidmlkZW9fdGh1bWJuYWlsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpZGVvX3RodW1ibmFpbChwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuaW1hZ2UocHVibGljSWQsIG1lcmdlX3Jvb3RfbWVyZ2VfZGVmYXVsdCgpKHt9LCBERUZBVUxUX1BPU1RFUl9PUFRJT05TLCBvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIGZhY2Vib29rIHByb2ZpbGUgaW1hZ2UgYW5kIGRlbGl2ZXJzIGl0IGluIGFuIGltYWdlIHRhZyBlbGVtZW50LlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2ZhY2Vib29rX3Byb2ZpbGVfaW1hZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgRmFjZWJvb2sgbnVtZXJpYyBJRC4gQWRkaXRpb25hbGx5LCBlaXRoZXIgYXBwZW5kIHRoZSBpbWFnZSBleHRlbnNpb24gdHlwZVxuICAgICAqICB0byB0aGUgSUQgb3Igc2V0IHRoZSBpbWFnZSBkZWxpdmVyeSBmb3JtYXQgaW4gdGhlICdvcHRpb25zJyBwYXJhbWV0ZXIgdXNpbmcgdGhlICdmb3JtYXQnIHRyYW5zZm9ybWF0aW9uIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycywge0BsaW5rIENvbmZpZ3VyYXRpb259IHBhcmFtZXRlcnMsXG4gICAgICogIGFuZCBzdGFuZGFyZCBIVE1MICZsdDtpbWcmZ3Q7IHRhZyBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBpbWFnZSB0YWcuXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gQW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImZhY2Vib29rX3Byb2ZpbGVfaW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFjZWJvb2tfcHJvZmlsZV9pbWFnZShwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuaW1hZ2UocHVibGljSWQsIGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0KCkoe1xuICAgICAgICB0eXBlOiAnZmFjZWJvb2snXG4gICAgICB9LCBvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIFR3aXR0ZXIgcHJvZmlsZSBpbWFnZSBieSBJRCBhbmQgZGVsaXZlcnMgaXQgaW4gYW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjdHdpdHRlcl9wcm9maWxlX2ltYWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIFR3aXR0ZXIgbnVtZXJpYyBJRC4gQWRkaXRpb25hbGx5LCBlaXRoZXIgYXBwZW5kIHRoZSBpbWFnZSBleHRlbnNpb24gdHlwZVxuICAgICAqICB0byB0aGUgSUQgb3Igc2V0IHRoZSBpbWFnZSBkZWxpdmVyeSBmb3JtYXQgaW4gdGhlICdvcHRpb25zJyBwYXJhbWV0ZXIgdXNpbmcgdGhlICdmb3JtYXQnIHRyYW5zZm9ybWF0aW9uIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycywge0BsaW5rIENvbmZpZ3VyYXRpb259IHBhcmFtZXRlcnMsXG4gICAgICogIGFuZCBzdGFuZGFyZCBIVE1MICZsdDtpbWcmZ3Q7IHRhZyBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBpbWFnZSB0YWcuXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gQW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInR3aXR0ZXJfcHJvZmlsZV9pbWFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0d2l0dGVyX3Byb2ZpbGVfaW1hZ2UocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmltYWdlKHB1YmxpY0lkLCBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHtcbiAgICAgICAgdHlwZTogJ3R3aXR0ZXInXG4gICAgICB9LCBvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIFR3aXR0ZXIgcHJvZmlsZSBpbWFnZSBieSBuYW1lIGFuZCBkZWxpdmVycyBpdCBpbiBhbiBpbWFnZSB0YWcgZWxlbWVudC5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSN0d2l0dGVyX25hbWVfcHJvZmlsZV9pbWFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBUd2l0dGVyIHNjcmVlbiBuYW1lLiBBZGRpdGlvbmFsbHksIGVpdGhlciBhcHBlbmQgdGhlIGltYWdlIGV4dGVuc2lvbiB0eXBlXG4gICAgICogIHRvIHRoZSBzY3JlZW4gbmFtZSBvciBzZXQgdGhlIGltYWdlIGRlbGl2ZXJ5IGZvcm1hdCBpbiB0aGUgJ29wdGlvbnMnIHBhcmFtZXRlciB1c2luZyB0aGUgJ2Zvcm1hdCcgdHJhbnNmb3JtYXRpb24gb3B0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzLCB7QGxpbmsgQ29uZmlndXJhdGlvbn0gcGFyYW1ldGVycyxcbiAgICAgKiAgYW5kIHN0YW5kYXJkIEhUTUwgJmx0O2ltZyZndDsgdGFnIGF0dHJpYnV0ZXMgdG8gYXBwbHkgdG8gdGhlIGltYWdlIHRhZy5cbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBBbiBpbWFnZSB0YWcgZWxlbWVudC5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidHdpdHRlcl9uYW1lX3Byb2ZpbGVfaW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHdpdHRlcl9uYW1lX3Byb2ZpbGVfaW1hZ2UocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmltYWdlKHB1YmxpY0lkLCBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHtcbiAgICAgICAgdHlwZTogJ3R3aXR0ZXJfbmFtZSdcbiAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGEgR3JhdmF0YXIgcHJvZmlsZSBpbWFnZSBhbmQgZGVsaXZlcnMgaXQgaW4gYW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjZ3JhdmF0YXJfaW1hZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgY2FsY3VsYXRlZCBoYXNoIGZvciB0aGUgR3JhdmF0YXIgZW1haWwgYWRkcmVzcy5cbiAgICAgKiAgQWRkaXRpb25hbGx5LCBlaXRoZXIgYXBwZW5kIHRoZSBpbWFnZSBleHRlbnNpb24gdHlwZSB0byB0aGUgc2NyZWVuIG5hbWUgb3Igc2V0IHRoZSBpbWFnZSBkZWxpdmVyeSBmb3JtYXRcbiAgICAgKiAgaW4gdGhlICdvcHRpb25zJyBwYXJhbWV0ZXIgdXNpbmcgdGhlICdmb3JtYXQnIHRyYW5zZm9ybWF0aW9uIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycywge0BsaW5rIENvbmZpZ3VyYXRpb259IHBhcmFtZXRlcnMsXG4gICAgICogIGFuZCBzdGFuZGFyZCBIVE1MICZsdDtpbWcmZ3Q7IHRhZyBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBpbWFnZSB0YWcuXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gQW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdyYXZhdGFyX2ltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdyYXZhdGFyX2ltYWdlKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbWFnZShwdWJsaWNJZCwgYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh7XG4gICAgICAgIHR5cGU6ICdncmF2YXRhcidcbiAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGFuIGltYWdlIGZyb20gYSByZW1vdGUgVVJMIGFuZCBkZWxpdmVycyBpdCBpbiBhbiBpbWFnZSB0YWcgZWxlbWVudC5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNmZXRjaF9pbWFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBmdWxsIFVSTCBvZiB0aGUgaW1hZ2UgdG8gZmV0Y2gsIGluY2x1ZGluZyB0aGUgZXh0ZW5zaW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzLCB7QGxpbmsgQ29uZmlndXJhdGlvbn0gcGFyYW1ldGVycyxcbiAgICAgKiAgYW5kIHN0YW5kYXJkIEhUTUwgJmx0O2ltZyZndDsgdGFnIGF0dHJpYnV0ZXMgdG8gYXBwbHkgdG8gdGhlIGltYWdlIHRhZy5cbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBBbiBpbWFnZSB0YWcgZWxlbWVudC5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZmV0Y2hfaW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmV0Y2hfaW1hZ2UocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmltYWdlKHB1YmxpY0lkLCBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHtcbiAgICAgICAgdHlwZTogJ2ZldGNoJ1xuICAgICAgfSwgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHZpZGVvIHRhZy5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSN2aWRlb1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBwdWJsaWMgSUQgb2YgdGhlIHZpZGVvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzLCB7QGxpbmsgQ29uZmlndXJhdGlvbn0gcGFyYW1ldGVycyxcbiAgICAgKiAgYW5kIHN0YW5kYXJkIEhUTUwgJmx0O2ltZyZndDsgdGFnIGF0dHJpYnV0ZXMgdG8gYXBwbHkgdG8gdGhlIGltYWdlIHRhZy5cbiAgICAgKiBAcmV0dXJuIHtIVE1MVmlkZW9FbGVtZW50fSBBIHZpZGVvIHRhZyBET00gZWxlbWVudC5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vdmlkZW9fdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSB2aWRlbyB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidmlkZW9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmlkZW8ocHVibGljSWQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHJldHVybiB0aGlzLnZpZGVvVGFnKHB1YmxpY0lkLCBvcHRpb25zKS50b0h0bWwoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFZpZGVvVGFnIGluc3RhbmNlIHVzaW5nIHRoZSBjb25maWd1cmF0aW9uIGRlZmluZWQgZm9yIHRoaXMgYGNsb3VkaW5hcnlgIGluc3RhbmNlLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3ZpZGVvVGFnXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIHB1YmxpYyBJRCBvZiB0aGUgdmlkZW8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzLCB7QGxpbmsgQ29uZmlndXJhdGlvbn0gcGFyYW1ldGVycyxcbiAgICAgKiAgYW5kIHN0YW5kYXJkIEhUTUwgJmx0O2ltZyZndDsgdGFnIGF0dHJpYnV0ZXMgdG8gYXBwbHkgdG8gdGhlIGltYWdlIHRhZy5cbiAgICAgKiBAcmV0dXJuIHtWaWRlb1RhZ30gQSBWaWRlb1RhZyB0aGF0IGlzIGF0dGFjaGVkIChjaGFpbmVkKSB0byB0aGlzIGBjbG91ZGluYXJ5YCBpbnN0YW5jZS5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vdmlkZW9fdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSB2aWRlbyB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidmlkZW9UYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmlkZW9UYWcocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0cyh7fSwgb3B0aW9ucywgdGhpcy5jb25maWcoKSk7XG4gICAgICByZXR1cm4gbmV3IHZpZGVvdGFnKHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBzcHJpdGUgUE5HIGltYWdlIHRoYXQgY29udGFpbnMgYWxsIGltYWdlcyB3aXRoIHRoZSBzcGVjaWZpZWQgdGFnIGFuZCB0aGUgY29ycmVzcG9uZGluZyBjc3MgZmlsZS5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNzcHJpdGVfY3NzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIHRhZyBvbiB3aGljaCB0byBiYXNlIHRoZSBzcHJpdGUgaW1hZ2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMgdG8gaW5jbHVkZSBpbiB0aGUgVVJMLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVSTCBvZiB0aGUgZ2VuZXJhdGVkIENTUyBmaWxlLiBUaGUgc3ByaXRlIGltYWdlIGhhcyB0aGUgc2FtZSBVUkwsIGJ1dCB3aXRoIGEgUE5HIGV4dGVuc2lvbi5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc3ByaXRlX2dlbmVyYXRpb25cIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgU3ByaXRlIGdlbmVyYXRpb248L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNwcml0ZV9jc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3ByaXRlX2NzcyhwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0KCkoe1xuICAgICAgICB0eXBlOiAnc3ByaXRlJ1xuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICBpZiAoIXB1YmxpY0lkLm1hdGNoKC8uY3NzJC8pKSB7XG4gICAgICAgIG9wdGlvbnMuZm9ybWF0ID0gJ2Nzcyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy51cmwocHVibGljSWQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHJlc3BvbnNpdmUgaW1hZ2UgYmVoYXZpb3IgZm9yIGFsbCBpbWFnZSB0YWdzIHdpdGggdGhlICdjbGQtcmVzcG9uc2l2ZSdcbiAgICAgKiAgKG9yIG90aGVyIGRlZmluZWQge0BsaW5rIENsb3VkaW5hcnkjcmVzcG9uc2l2ZXxyZXNwb25zaXZlfSBjbGFzcykuPGJyLz5cbiAgICAgKiAgVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGludm9rZWQgYWZ0ZXIgdGhlIHBhZ2UgaGFzIGxvYWRlZC48YnIvPlxuICAgICAqICA8Yj5Ob3RlPC9iPjogQ2FsbHMge0BsaW5rIENsb3VkaW5hcnkjY2xvdWRpbmFyeV91cGRhdGV8Y2xvdWRpbmFyeV91cGRhdGV9IHRvIG1vZGlmeSBpbWFnZSB0YWdzLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3Jlc3BvbnNpdmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yZXNwb25zaXZlX2NsYXNzPSdjbGQtcmVzcG9uc2l2ZSddIC0gQW4gYWx0ZXJuYXRpdmUgY2xhc3NcbiAgICAgKiAgdG8gbG9jYXRlIHRoZSByZWxldmFudCAmbHQ7aW1nJmd0OyB0YWdzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yZXNwb25zaXZlX2RlYm91bmNlPTEwMF0gLSBUaGUgZGVib3VuY2UgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Jvb3RzdHJhcD10cnVlXSBJZiB0cnVlLCBwcm9jZXNzZXMgdGhlICZsdDtpbWcmZ3Q7IHRhZ3MgYnkgY2FsbGluZ1xuICAgICAqICB7QGxpbmsgQ2xvdWRpbmFyeSNjbG91ZGluYXJ5X3VwZGF0ZXxjbG91ZGluYXJ5X3VwZGF0ZX0uIFdoZW4gZmFsc2UsIHRoZSB0YWdzIGFyZSBwcm9jZXNzZWRcbiAgICAgKiAgb25seSBhZnRlciBhIHJlc2l6ZSBldmVudC5cbiAgICAgKiBAc2VlIHtAbGluayBDbG91ZGluYXJ5I2Nsb3VkaW5hcnlfdXBkYXRlfGNsb3VkaW5hcnlfdXBkYXRlfSBmb3IgYWRkaXRpb25hbCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnNcbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vcmVzcG9uc2l2ZV9pbWFnZXMjYXV0b21hdGluZ19yZXNwb25zaXZlX2ltYWdlc193aXRoX2phdmFzY3JpcHRcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdXRvbWF0aW5nIHJlc3BvbnNpdmUgaW1hZ2VzIHdpdGggSmF2YVNjcmlwdDwvYT5cbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gdGhhdCB3aGVuIGNhbGxlZCwgcmVtb3ZlcyB0aGUgcmVzaXplIEV2ZW50TGlzdGVuZXIgYWRkZWQgYnkgdGhpcyBmdW5jdGlvblxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlc3BvbnNpdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzcG9uc2l2ZShvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGJvb3RzdHJhcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHZhciByZWYsIHJlZjEsIHJlZjIsIHJlc3BvbnNpdmVDbGFzcywgcmVzcG9uc2l2ZVJlc2l6ZSwgdGltZW91dDtcbiAgICAgIHRoaXMucmVzcG9uc2l2ZUNvbmZpZyA9IG1lcmdlX3Jvb3RfbWVyZ2VfZGVmYXVsdCgpKHRoaXMucmVzcG9uc2l2ZUNvbmZpZyB8fCB7fSwgb3B0aW9ucyk7XG4gICAgICByZXNwb25zaXZlQ2xhc3MgPSAocmVmID0gdGhpcy5yZXNwb25zaXZlQ29uZmlnLnJlc3BvbnNpdmVfY2xhc3MpICE9IG51bGwgPyByZWYgOiB0aGlzLmNvbmZpZygncmVzcG9uc2l2ZV9jbGFzcycpO1xuICAgICAgaWYgKGJvb3RzdHJhcCkge1xuICAgICAgICB0aGlzLmNsb3VkaW5hcnlfdXBkYXRlKFwiaW1nLlwiLmNvbmNhdChyZXNwb25zaXZlQ2xhc3MsIFwiLCBpbWcuY2xkLWhpZHBpXCIpLCB0aGlzLnJlc3BvbnNpdmVDb25maWcpO1xuICAgICAgfVxuICAgICAgcmVzcG9uc2l2ZVJlc2l6ZSA9IChyZWYxID0gKHJlZjIgPSB0aGlzLnJlc3BvbnNpdmVDb25maWcucmVzcG9uc2l2ZV9yZXNpemUpICE9IG51bGwgPyByZWYyIDogdGhpcy5jb25maWcoJ3Jlc3BvbnNpdmVfcmVzaXplJykpICE9IG51bGwgPyByZWYxIDogdHJ1ZTtcbiAgICAgIGlmIChyZXNwb25zaXZlUmVzaXplICYmICF0aGlzLnJlc3BvbnNpdmVSZXNpemVJbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLnJlc3BvbnNpdmVDb25maWcucmVzaXppbmcgPSB0aGlzLnJlc3BvbnNpdmVSZXNpemVJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB2YXIgbWFrZVJlc3BvbnNpdmUgPSBmdW5jdGlvbiBtYWtlUmVzcG9uc2l2ZSgpIHtcbiAgICAgICAgICB2YXIgZGVib3VuY2UsIHJlZjMsIHJlZjQsIHJlc2V0LCBydW4sIHdhaXQsIHdhaXRGdW5jO1xuICAgICAgICAgIGRlYm91bmNlID0gKHJlZjMgPSAocmVmNCA9IF90aGlzLnJlc3BvbnNpdmVDb25maWcucmVzcG9uc2l2ZV9kZWJvdW5jZSkgIT0gbnVsbCA/IHJlZjQgOiBfdGhpcy5jb25maWcoJ3Jlc3BvbnNpdmVfZGVib3VuY2UnKSkgIT0gbnVsbCA/IHJlZjMgOiAxMDA7XG4gICAgICAgICAgcmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBydW4gPSBmdW5jdGlvbiBydW4oKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuY2xvdWRpbmFyeV91cGRhdGUoXCJpbWcuXCIuY29uY2F0KHJlc3BvbnNpdmVDbGFzcyksIF90aGlzLnJlc3BvbnNpdmVDb25maWcpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgd2FpdEZ1bmMgPSBmdW5jdGlvbiB3YWl0RnVuYygpIHtcbiAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gcnVuKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3YWl0ID0gZnVuY3Rpb24gd2FpdCgpIHtcbiAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCh3YWl0RnVuYywgZGVib3VuY2UpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGRlYm91bmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2FpdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcnVuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgbWFrZVJlc3BvbnNpdmUpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgbWFrZVJlc3BvbnNpdmUpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2NhbGNfYnJlYWtwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNhbGNfYnJlYWtwb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjX2JyZWFrcG9pbnQoZWxlbWVudCwgd2lkdGgsIHN0ZXBzKSB7XG4gICAgICB2YXIgYnJlYWtwb2ludHMgPSBsb2Rhc2hfZ2V0RGF0YShlbGVtZW50LCAnYnJlYWtwb2ludHMnKSB8fCBsb2Rhc2hfZ2V0RGF0YShlbGVtZW50LCAnc3RvcHBvaW50cycpIHx8IHRoaXMuY29uZmlnKCdicmVha3BvaW50cycpIHx8IHRoaXMuY29uZmlnKCdzdG9wcG9pbnRzJykgfHwgZGVmYXVsdEJyZWFrcG9pbnRzO1xuICAgICAgaWYgKGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShicmVha3BvaW50cykpIHtcbiAgICAgICAgcmV0dXJuIGJyZWFrcG9pbnRzKHdpZHRoLCBzdGVwcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkoYnJlYWtwb2ludHMpKSB7XG4gICAgICAgICAgYnJlYWtwb2ludHMgPSBicmVha3BvaW50cy5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChwb2ludCk7XG4gICAgICAgICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9zZXN0QWJvdmUoYnJlYWtwb2ludHMsIHdpZHRoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNjYWxjX3N0b3Bwb2ludFxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgY2FsY19icmVha3BvaW50fSBpbnN0ZWFkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNhbGNfc3RvcHBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGNfc3RvcHBvaW50KGVsZW1lbnQsIHdpZHRoLCBzdGVwcykge1xuICAgICAgcmV0dXJuIHRoaXMuY2FsY19icmVha3BvaW50KGVsZW1lbnQsIHdpZHRoLCBzdGVwcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjZGV2aWNlX3BpeGVsX3JhdGlvXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkZXZpY2VfcGl4ZWxfcmF0aW9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV2aWNlX3BpeGVsX3JhdGlvKHJvdW5kRHByKSB7XG4gICAgICByb3VuZERwciA9IHJvdW5kRHByID09IG51bGwgPyB0cnVlIDogcm91bmREcHI7XG4gICAgICB2YXIgZHByID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93ICE9PSBudWxsID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gOiB2b2lkIDApIHx8IDE7XG4gICAgICBpZiAocm91bmREcHIpIHtcbiAgICAgICAgZHByID0gTWF0aC5jZWlsKGRwcik7XG4gICAgICB9XG4gICAgICBpZiAoZHByIDw9IDAgfHwgZHByID09PSAwIC8gMCkge1xuICAgICAgICBkcHIgPSAxO1xuICAgICAgfVxuICAgICAgdmFyIGRwclN0cmluZyA9IGRwci50b1N0cmluZygpO1xuICAgICAgaWYgKGRwclN0cmluZy5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgICAgZHByU3RyaW5nICs9ICcuMCc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZHByU3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQXBwbGllcyByZXNwb25zaXZlbmVzcyB0byBhbGwgPGNvZGU+Jmx0O2ltZyZndDs8L2NvZGU+IHRhZ3MgdW5kZXIgZWFjaCByZWxldmFudCBub2RlXG4gICAgKiAgKHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdGFnIGNvbnRhaW5zIHRoZSB7QGxpbmsgQ2xvdWRpbmFyeSNyZXNwb25zaXZlfHJlc3BvbnNpdmV9IGNsYXNzKS5cbiAgICAqIEBwYXJhbSB7RWxlbWVudFtdfSBub2RlcyBUaGUgcGFyZW50IG5vZGVzIHdoZXJlIHlvdSB3YW50IHRvIHNlYXJjaCBmb3IgJmx0O2ltZyZndDsgdGFncy5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIHtAbGluayBDbG91ZGluYXJ5I2Nsb3VkaW5hcnlfdXBkYXRlfGNsb3VkaW5hcnlfdXBkYXRlfSBvcHRpb25zIHRvIGFwcGx5LlxuICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiXG4gICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3Byb2Nlc3NJbWFnZVRhZ3NcbiAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInByb2Nlc3NJbWFnZVRhZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc0ltYWdlVGFncyhub2Rlcywgb3B0aW9ucykge1xuICAgICAgaWYgKGlzRW1wdHkobm9kZXMpKSB7XG4gICAgICAgIC8vIHNpbWlsYXIgdG8gYCQuZm4uY2xvdWRpbmFyeWBcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gZGVmYXVsdHMoe30sIG9wdGlvbnMgfHwge30sIHRoaXMuY29uZmlnKCkpO1xuICAgICAgdmFyIGltYWdlcyA9IG5vZGVzLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gL15pbWckL2kudGVzdChub2RlLnRhZ05hbWUpO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBpbWdPcHRpb25zID0gYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh7XG4gICAgICAgICAgd2lkdGg6IG5vZGUuZ2V0QXR0cmlidXRlKCd3aWR0aCcpLFxuICAgICAgICAgIGhlaWdodDogbm9kZS5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpLFxuICAgICAgICAgIHNyYzogbm9kZS5nZXRBdHRyaWJ1dGUoJ3NyYycpXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB2YXIgcHVibGljSWQgPSBpbWdPcHRpb25zWydzb3VyY2UnXSB8fCBpbWdPcHRpb25zWydzcmMnXTtcbiAgICAgICAgZGVsZXRlIGltZ09wdGlvbnNbJ3NvdXJjZSddO1xuICAgICAgICBkZWxldGUgaW1nT3B0aW9uc1snc3JjJ107XG4gICAgICAgIHZhciBhdHRyID0gbmV3IHNyY190cmFuc2Zvcm1hdGlvbihpbWdPcHRpb25zKS50b0h0bWxBdHRyaWJ1dGVzKCk7XG4gICAgICAgIGxvZGFzaF9zZXREYXRhKG5vZGUsICdzcmMtY2FjaGUnLCB1cmxfdXJsKHB1YmxpY0lkLCBpbWdPcHRpb25zKSk7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGF0dHIud2lkdGgpO1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgYXR0ci5oZWlnaHQpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jbG91ZGluYXJ5X3VwZGF0ZShpbWFnZXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBVcGRhdGVzIHRoZSBkcHIgKGZvciBgZHByX2F1dG9gKSBhbmQgcmVzcG9uc2l2ZSAoZm9yIGB3X2F1dG9gKSBmaWVsZHMgYWNjb3JkaW5nIHRvXG4gICAgKiAgdGhlIGN1cnJlbnQgY29udGFpbmVyIHNpemUgYW5kIHRoZSBkZXZpY2UgcGl4ZWwgcmF0aW8uPGJyLz5cbiAgICAqICA8Yj5Ob3RlPC9iPjpgd19hdXRvYCBpcyB1cGRhdGVkIG9ubHkgZm9yIGltYWdlcyBtYXJrZWQgd2l0aCB0aGUgYGNsZC1yZXNwb25zaXZlYFxuICAgICogIChvciBvdGhlciBkZWZpbmVkIHtAbGluayBDbG91ZGluYXJ5I3Jlc3BvbnNpdmV8cmVzcG9uc2l2ZX0pIGNsYXNzLlxuICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjY2xvdWRpbmFyeV91cGRhdGVcbiAgICAqIEBwYXJhbSB7KEFycmF5fHN0cmluZ3xOb2RlTGlzdCl9IGVsZW1lbnRzIC0gVGhlIEhUTUwgaW1hZ2UgZWxlbWVudHMgdG8gbW9kaWZ5LlxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbnxzdHJpbmd9IFtvcHRpb25zLnJlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzPXRydWVdXG4gICAgKiBQb3NzaWJsZSB2YWx1ZXM6PGJyLz5cbiAgICAqICAtIGB0cnVlYDogQWx3YXlzIHVzZSBicmVha3BvaW50cyBmb3Igd2lkdGguPGJyLz5cbiAgICAqICAtIGByZXNpemVgOiBVc2UgZXhhY3Qgd2lkdGggb24gZmlyc3QgcmVuZGVyIGFuZCBicmVha3BvaW50cyBvbiByZXNpemUuPGJyLz5cbiAgICAqICAtIGBmYWxzZWA6IEFsd2F5cyB1c2UgZXhhY3Qgd2lkdGguXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlc3BvbnNpdmVdIC0gSWYgYHRydWVgLCBlbmFibGUgcmVzcG9uc2l2ZSBvbiBhbGwgc3BlY2lmaWVkIGVsZW1lbnRzLlxuICAgICogIEFsdGVybmF0aXZlbHksIHlvdSBjYW4gZGVmaW5lIHNwZWNpZmljIEhUTUwgZWxlbWVudHMgdG8gbW9kaWZ5IGJ5IGFkZGluZyB0aGUgYGNsZC1yZXNwb25zaXZlYFxuICAgICogIChvciBvdGhlciBjdXN0b20tZGVmaW5lZCB7QGxpbmsgQ2xvdWRpbmFyeSNyZXNwb25zaXZlfHJlc3BvbnNpdmVfY2xhc3N9KSBjbGFzcyB0byB0aG9zZSBlbGVtZW50cy5cbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVzcG9uc2l2ZV9wcmVzZXJ2ZV9oZWlnaHRdIC0gSWYgYHRydWVgLCBvcmlnaW5hbCBjc3MgaGVpZ2h0IGlzIHByZXNlcnZlZC5cbiAgICAqICBTaG91bGQgYmUgdXNlZCBvbmx5IGlmIHRoZSB0cmFuc2Zvcm1hdGlvbiBzdXBwb3J0cyBkaWZmZXJlbnQgYXNwZWN0IHJhdGlvcy5cbiAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNsb3VkaW5hcnlfdXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3VkaW5hcnlfdXBkYXRlKGVsZW1lbnRzLCBvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBjb250YWluZXJXaWR0aCwgZGF0YVNyYywgbWF0Y2gsIHJlZjQsIHJlcXVpcmVkV2lkdGg7XG4gICAgICBpZiAoZWxlbWVudHMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cbiAgICAgIHZhciByZXNwb25zaXZlID0gb3B0aW9ucy5yZXNwb25zaXZlICE9IG51bGwgPyBvcHRpb25zLnJlc3BvbnNpdmUgOiB0aGlzLmNvbmZpZygncmVzcG9uc2l2ZScpO1xuICAgICAgZWxlbWVudHMgPSBub3JtYWxpemVUb0FycmF5KGVsZW1lbnRzKTtcbiAgICAgIHZhciByZXNwb25zaXZlQ2xhc3M7XG4gICAgICBpZiAodGhpcy5yZXNwb25zaXZlQ29uZmlnICYmIHRoaXMucmVzcG9uc2l2ZUNvbmZpZy5yZXNwb25zaXZlX2NsYXNzICE9IG51bGwpIHtcbiAgICAgICAgcmVzcG9uc2l2ZUNsYXNzID0gdGhpcy5yZXNwb25zaXZlQ29uZmlnLnJlc3BvbnNpdmVfY2xhc3M7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMucmVzcG9uc2l2ZV9jbGFzcyAhPSBudWxsKSB7XG4gICAgICAgIHJlc3BvbnNpdmVDbGFzcyA9IG9wdGlvbnMucmVzcG9uc2l2ZV9jbGFzcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3BvbnNpdmVDbGFzcyA9IHRoaXMuY29uZmlnKCdyZXNwb25zaXZlX2NsYXNzJyk7XG4gICAgICB9XG4gICAgICB2YXIgcm91bmREcHIgPSBvcHRpb25zLnJvdW5kX2RwciAhPSBudWxsID8gb3B0aW9ucy5yb3VuZF9kcHIgOiB0aGlzLmNvbmZpZygncm91bmRfZHByJyk7XG4gICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgaWYgKC9pbWcvaS50ZXN0KHRhZy50YWdOYW1lKSkge1xuICAgICAgICAgIHZhciBzZXRVcmwgPSB0cnVlO1xuICAgICAgICAgIGlmIChyZXNwb25zaXZlKSB7XG4gICAgICAgICAgICBsb2Rhc2hfYWRkQ2xhc3ModGFnLCByZXNwb25zaXZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhU3JjID0gbG9kYXNoX2dldERhdGEodGFnLCAnc3JjLWNhY2hlJykgfHwgbG9kYXNoX2dldERhdGEodGFnLCAnc3JjJyk7XG4gICAgICAgICAgaWYgKCFpc0VtcHR5KGRhdGFTcmMpKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgZHByIGFjY29yZGluZyB0byB0aGUgZGV2aWNlJ3MgZGV2aWNlUGl4ZWxSYXRpb1xuICAgICAgICAgICAgZGF0YVNyYyA9IHVwZGF0ZURwci5jYWxsKF90aGlzMiwgZGF0YVNyYywgcm91bmREcHIpO1xuICAgICAgICAgICAgaWYgKGh0bWx0YWcuaXNSZXNwb25zaXZlKHRhZywgcmVzcG9uc2l2ZUNsYXNzKSkge1xuICAgICAgICAgICAgICBjb250YWluZXJXaWR0aCA9IGNsb3VkaW5hcnlfZmluZENvbnRhaW5lcldpZHRoKHRhZyk7XG4gICAgICAgICAgICAgIGlmIChjb250YWluZXJXaWR0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICgvd19hdXRvOmJyZWFrcG9pbnRzLy50ZXN0KGRhdGFTcmMpKSB7XG4gICAgICAgICAgICAgICAgICByZXF1aXJlZFdpZHRoID0gY2xvdWRpbmFyeV9tYXhXaWR0aChjb250YWluZXJXaWR0aCwgdGFnKTtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXF1aXJlZFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFTcmMgPSBkYXRhU3JjLnJlcGxhY2UoL3dfYXV0bzpicmVha3BvaW50cyhbXzAtOV0qKSg6WzAtOV0rKT8vLCBcIndfYXV0bzpicmVha3BvaW50cyQxOlwiLmNvbmNhdChyZXF1aXJlZFdpZHRoKSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRVcmwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbWF0Y2ggPSAvd19hdXRvKDooXFxkKykpPy8uZXhlYyhkYXRhU3JjKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZFdpZHRoID0gYXBwbHlCcmVha3BvaW50cy5jYWxsKF90aGlzMiwgdGFnLCBjb250YWluZXJXaWR0aCwgbWF0Y2hbMl0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZFdpZHRoID0gY2xvdWRpbmFyeV9tYXhXaWR0aChyZXF1aXJlZFdpZHRoLCB0YWcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWlyZWRXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgIGRhdGFTcmMgPSBkYXRhU3JjLnJlcGxhY2UoL3dfYXV0b1teLFxcL10qL2csIFwid19cIi5jb25jYXQocmVxdWlyZWRXaWR0aCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHNldFVybCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvZGFzaF9yZW1vdmVBdHRyaWJ1dGUodGFnLCAnd2lkdGgnKTtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMucmVzcG9uc2l2ZV9wcmVzZXJ2ZV9oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgIGxvZGFzaF9yZW1vdmVBdHRyaWJ1dGUodGFnLCAnaGVpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENvbnRhaW5lciBkb2Vzbid0IGtub3cgdGhlIHNpemUgeWV0IC0gdXN1YWxseSBiZWNhdXNlIHRoZSBpbWFnZSBpcyBoaWRkZW4gb3Igb3V0c2lkZSB0aGUgRE9NLlxuICAgICAgICAgICAgICAgIHNldFVybCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaXNMYXp5TG9hZGluZyA9IG9wdGlvbnMubG9hZGluZyA9PT0gJ2xhenknICYmICFfdGhpczIuaXNOYXRpdmVMYXp5TG9hZFN1cHBvcnRlZCgpICYmIF90aGlzMi5pc0xhenlMb2FkU3VwcG9ydGVkKCkgJiYgIWVsZW1lbnRzWzBdLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgICAgICBpZiAoc2V0VXJsIHx8IGlzTGF6eUxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgLy8gSWYgZGF0YS13aWR0aCBleGlzdHMsIHNldCB3aWR0aCB0byBiZSBkYXRhLXdpZHRoXG4gICAgICAgICAgICAgIF90aGlzMi5zZXRBdHRyaWJ1dGVJZkV4aXN0cyhlbGVtZW50c1swXSwgJ3dpZHRoJywgJ2RhdGEtd2lkdGgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXRVcmwgJiYgIWlzTGF6eUxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgbG9kYXNoX3NldEF0dHJpYnV0ZSh0YWcsICdzcmMnLCBkYXRhU3JjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBlbGVtZW50W3RvQXR0cmlidXRlXSA9IGVsZW1lbnRbZnJvbUF0dHJpYnV0ZV0gaWYgZWxlbWVudFtmcm9tQXR0cmlidXRlXSBpcyBzZXRcbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB0b0F0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSBmcm9tQXR0cmlidXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0QXR0cmlidXRlSWZFeGlzdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QXR0cmlidXRlSWZFeGlzdHMoZWxlbWVudCwgdG9BdHRyaWJ1dGUsIGZyb21BdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVWYWx1ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGZyb21BdHRyaWJ1dGUpO1xuICAgICAgaWYgKGF0dHJpYnV0ZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgbG9kYXNoX3NldEF0dHJpYnV0ZShlbGVtZW50LCB0b0F0dHJpYnV0ZSwgYXR0cmlidXRlVmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBJbnRlcnNlY3Rpb24gT2JzZXJ2ZXIgQVBJIGlzIHN1cHBvcnRlZFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImlzTGF6eUxvYWRTdXBwb3J0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNMYXp5TG9hZFN1cHBvcnRlZCgpIHtcbiAgICAgIHJldHVybiB3aW5kb3cgJiYgJ0ludGVyc2VjdGlvbk9ic2VydmVyJyBpbiB3aW5kb3c7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHVzaW5nIENocm9tZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImlzTmF0aXZlTGF6eUxvYWRTdXBwb3J0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNOYXRpdmVMYXp5TG9hZFN1cHBvcnRlZCgpIHtcbiAgICAgIHJldHVybiAnbG9hZGluZycgaW4gSFRNTEltYWdlRWxlbWVudC5wcm90b3R5cGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gb2JqZWN0LCBpbml0aWFsaXplZCB3aXRoIHRoZSBzcGVjaWZpZWQgb3B0aW9ucywgZm9yIGNoYWluaW5nIHB1cnBvc2VzLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3RyYW5zZm9ybWF0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gb3B0aW9ucyB0byBhcHBseS5cbiAgICAgKiBAcmV0dXJuIHtUcmFuc2Zvcm1hdGlvbn1cbiAgICAgKiBAc2VlIFRyYW5zZm9ybWF0aW9uXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi92aWRlb190cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIHZpZGVvIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gc3JjX3RyYW5zZm9ybWF0aW9uW1wibmV3XCJdKHRoaXMuY29uZmlnKCkpLmZyb21PcHRpb25zKG9wdGlvbnMpLnNldFBhcmVudCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiB3aWxsIGFwcGVuZCBhIFRyYW5zcGFyZW50VmlkZW8gZWxlbWVudCB0byB0aGUgaHRtbEVsQ29udGFpbmVyIHBhc3NlZCB0byBpdC5cbiAgICAgKiAgICAgICAgICAgICAgVHJhbnNwYXJlbnRWaWRlbyBjYW4gZWl0aGVyIGJlIGFuIEhUTUwgVmlkZW8gdGFnLCBvciBhbiBIVE1MIENhbnZhcyBUYWcuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaHRtbEVsQ29udGFpbmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgVGhlIHtAbGluayBUcmFuc3BhcmVudFZpZGVvT3B0aW9uc30gb3B0aW9ucyB0byBhcHBseSAtIEV4dGVuZHMgVHJhbnNmb3JtYXRpb25PcHRpb25zXG4gICAgICogICAgICAgICAgICAgICAgIG9wdGlvbnMucGxheXNpbmxpbmUgICAgLSBIVE1MIFZpZGVvIFRhZydzIG5hdGl2ZSBwbGF5c2lubGluZSAtIHBhc3NlZCB0byB2aWRlbyBlbGVtZW50LlxuICAgICAqICAgICAgICAgICAgICAgICBvcHRpb25zLnBvc3RlciAgICAgICAgIC0gSFRNTCBWaWRlbyBUYWcncyBuYXRpdmUgcG9zdGVyIC0gcGFzc2VkIHRvIHZpZGVvIGVsZW1lbnQuXG4gICAgICogICAgICAgICAgICAgICAgIG9wdGlvbnMubG9vcCAgICAgICAgICAgLSBIVE1MIFZpZGVvIFRhZydzIG5hdGl2ZSBsb29wIC0gcGFzc2VkIHRvIHZpZGVvIGVsZW1lbnQuXG4gICAgICogICAgICAgICAgICAgICAgIG9wdGlvbnM/LmV4dGVybmFsTGlicmFyaWVzID0geyBba2V5OiBzdHJpbmddOiBzdHJpbmd9IC0gbWFwIG9mIGV4dGVybmFsIGxpYnJhcmllcyB0byBiZSBsb2FkZWRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPEhUTUxFbGVtZW50IHwge3N0YXR1czpzdHJpbmcsIG1lc3NhZ2U6c3RyaW5nfT59XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5qZWN0VHJhbnNwYXJlbnRWaWRlb0VsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5qZWN0VHJhbnNwYXJlbnRWaWRlb0VsZW1lbnQoaHRtbEVsQ29udGFpbmVyLCBwdWJsaWNJZCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBpZiAoIWh0bWxFbENvbnRhaW5lcikge1xuICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgICBtZXNzYWdlOiAnRXhwZWN0aW5nIGh0bWxFbENvbnRhaW5lciB0byBiZSBIVE1MRWxlbWVudCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc3BhcmVudFZpZGVvX2VuZm9yY2VPcHRpb25zRm9yVHJhbnNwYXJlbnRWaWRlbyhvcHRpb25zKTtcbiAgICAgICAgdmFyIHZpZGVvVVJMID0gX3RoaXMzLnZpZGVvX3VybChwdWJsaWNJZCwgb3B0aW9ucyk7XG4gICAgICAgIHRyYW5zcGFyZW50VmlkZW9fY2hlY2tTdXBwb3J0Rm9yVHJhbnNwYXJlbmN5KCkudGhlbihmdW5jdGlvbiAoaXNOYXRpdmVseVRyYW5zcGFyZW50KSB7XG4gICAgICAgICAgdmFyIG1vdW50UHJvbWlzZTtcbiAgICAgICAgICBpZiAoaXNOYXRpdmVseVRyYW5zcGFyZW50KSB7XG4gICAgICAgICAgICBtb3VudFByb21pc2UgPSB0cmFuc3BhcmVudFZpZGVvX21vdW50Q2xvdWRpbmFyeVZpZGVvVGFnKGh0bWxFbENvbnRhaW5lciwgX3RoaXMzLCBwdWJsaWNJZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICByZXNvbHZlKGh0bWxFbENvbnRhaW5lcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vdW50UHJvbWlzZSA9IHRyYW5zcGFyZW50VmlkZW9fbW91bnRTZWVUaHJ1Q2FudmFzVGFnKGh0bWxFbENvbnRhaW5lciwgdmlkZW9VUkwsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb3VudFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXNvbHZlKGh0bWxFbENvbnRhaW5lcik7XG4gICAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgICAgdmFyIHN0YXR1cyA9IF9yZWYuc3RhdHVzLFxuICAgICAgICAgICAgICBtZXNzYWdlID0gX3JlZi5tZXNzYWdlO1xuICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gY2F0Y2ggZm9yIGNoZWNrU3VwcG9ydEZvclRyYW5zcGFyZW5jeSgpXG4gICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgICAgdmFyIHN0YXR1cyA9IF9yZWYyLnN0YXR1cyxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBfcmVmMi5tZXNzYWdlO1xuICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJuZXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX25ldyhvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMob3B0aW9ucyk7XG4gICAgfVxuICB9XSk7XG59KCk7XG5hc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKGNsb3VkaW5hcnlfQ2xvdWRpbmFyeSwgY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjbG91ZGluYXJ5ID0gKGNsb3VkaW5hcnlfQ2xvdWRpbmFyeSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9uYW1lc3BhY2UvY2xvdWRpbmFyeS1jb3JlLmpzXG4vKipcbiAqIENyZWF0ZXMgdGhlIG5hbWVzcGFjZSBmb3IgQ2xvdWRpbmFyeVxuICovXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY2xvdWRpbmFyeV9jb3JlID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICBDbGllbnRIaW50c01ldGFUYWc6IGNsaWVudGhpbnRzbWV0YXRhZyxcbiAgQ2xvdWRpbmFyeTogY2xvdWRpbmFyeSxcbiAgQ29uZGl0aW9uOiBjb25kaXRpb24sXG4gIENvbmZpZ3VyYXRpb246IHNyY19jb25maWd1cmF0aW9uLFxuICBjcmMzMjogc3JjX2NyYzMyLFxuICBFeHByZXNzaW9uOiBleHByZXNzaW9uLFxuICBGZXRjaExheWVyOiBmZXRjaGxheWVyLFxuICBIdG1sVGFnOiBodG1sdGFnLFxuICBJbWFnZVRhZzogaW1hZ2V0YWcsXG4gIExheWVyOiBsYXllcl9sYXllcixcbiAgUGljdHVyZVRhZzogcGljdHVyZXRhZyxcbiAgU3VidGl0bGVzTGF5ZXI6IHN1YnRpdGxlc2xheWVyLFxuICBUZXh0TGF5ZXI6IHRleHRsYXllcixcbiAgVHJhbnNmb3JtYXRpb246IHNyY190cmFuc2Zvcm1hdGlvbixcbiAgdXRmOF9lbmNvZGU6IHNyY191dGY4X2VuY29kZSxcbiAgVXRpbDogbG9kYXNoX25hbWVzcGFjZU9iamVjdCxcbiAgVmlkZW9UYWc6IHZpZGVvdGFnXG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvYXNzaWduXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfYXNzaWduX187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9jbG9uZURlZXBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9jbG9uZURlZXBfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL2NvbXBhY3RcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9jb21wYWN0X187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9kaWZmZXJlbmNlXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfZGlmZmVyZW5jZV9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvZnVuY3Rpb25zXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfZnVuY3Rpb25zX187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9pZGVudGl0eVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lkZW50aXR5X187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9pbmNsdWRlc1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2luY2x1ZGVzX187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9pc0FycmF5XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNBcnJheV9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvaXNFbGVtZW50XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNFbGVtZW50X187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9pc0Z1bmN0aW9uXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNGdW5jdGlvbl9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzUGxhaW5PYmplY3RfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL2lzU3RyaW5nXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNTdHJpbmdfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL21lcmdlXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfbWVyZ2VfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL3RyaW1cIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF90cmltX187XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIH0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbG91ZGluYXJ5LWNvcmUuanMubWFwIl0sIm5hbWVzIjpbIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2Fzc2lnbl9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfY2xvbmVEZWVwX18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9jb21wYWN0X18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9kaWZmZXJlbmNlX18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9mdW5jdGlvbnNfXyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lkZW50aXR5X18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pbmNsdWRlc19fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNBcnJheV9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNFbGVtZW50X18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc0Z1bmN0aW9uX18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc1BsYWluT2JqZWN0X18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc1N0cmluZ19fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfbWVyZ2VfXyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX3RyaW1fXyIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiaSIsImwiLCJjYWxsIiwibSIsImMiLCJkIiwibmFtZSIsImdldHRlciIsIm8iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJyIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsInQiLCJtb2RlIiwiX19lc01vZHVsZSIsIm5zIiwiY3JlYXRlIiwia2V5IiwiYmluZCIsIm4iLCJnZXREZWZhdWx0IiwiZ2V0TW9kdWxlRXhwb3J0cyIsIm9iamVjdCIsInByb3BlcnR5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJwIiwicyIsIl9fd2VicGFja19leHBvcnRzX18iLCJjbGllbnRoaW50c21ldGF0YWciLCJjbG91ZGluYXJ5IiwiY29uZGl0aW9uIiwic3JjX2NvbmZpZ3VyYXRpb24iLCJzcmNfY3JjMzIiLCJleHByZXNzaW9uIiwiZmV0Y2hsYXllciIsImh0bWx0YWciLCJpbWFnZXRhZyIsImxheWVyX2xheWVyIiwicGljdHVyZXRhZyIsInN1YnRpdGxlc2xheWVyIiwidGV4dGxheWVyIiwic3JjX3RyYW5zZm9ybWF0aW9uIiwic3JjX3V0ZjhfZW5jb2RlIiwibG9kYXNoX25hbWVzcGFjZU9iamVjdCIsInZpZGVvdGFnIiwiY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCIsIlZFUlNJT04iLCJDRl9TSEFSRURfQ0ROIiwiT0xEX0FLQU1BSV9TSEFSRURfQ0ROIiwiQUtBTUFJX1NIQVJFRF9DRE4iLCJTSEFSRURfQ0ROIiwiREVGQVVMVF9USU1FT1VUX01TIiwiREVGQVVMVF9QT1NURVJfT1BUSU9OUyIsIkRFRkFVTFRfVklERU9fU09VUkNFX1RZUEVTIiwiU0VPX1RZUEVTIiwiREVGQVVMVF9JTUFHRV9QQVJBTVMiLCJERUZBVUxUX1ZJREVPX1BBUkFNUyIsIkRFRkFVTFRfVklERU9fU09VUkNFUyIsIkRFRkFVTFRfRVhURVJOQUxfTElCUkFSSUVTIiwiUExBQ0VIT0xERVJfSU1BR0VfTU9ERVMiLCJBQ0NFU1NJQklMSVRZX01PREVTIiwiVVJMX0tFWVMiLCJnZXRTREtBbmFseXRpY3NTaWduYXR1cmUiLCJnZXRBbmFseXRpY3NPcHRpb25zIiwiYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQiLCJhIiwiY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwX2RlZmF1bHQiLCJjb21wYWN0X3Jvb3RfY29tcGFjdF9kZWZhdWx0IiwiZGlmZmVyZW5jZV9yb290X2RpZmZlcmVuY2VfZGVmYXVsdCIsImZ1bmN0aW9uc19yb290X2Z1bmN0aW9uc19kZWZhdWx0IiwiaWRlbnRpdHlfcm9vdF9pZGVudGl0eV9kZWZhdWx0IiwiaW5jbHVkZXNfcm9vdF9pbmNsdWRlc19kZWZhdWx0IiwiaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCIsImlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQiLCJpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQiLCJtZXJnZV9yb290X21lcmdlX2RlZmF1bHQiLCJpc0ludGVyc2VjdGlvbk9ic2VydmVyU3VwcG9ydGVkIiwiaXNOYXRpdmVMYXp5TG9hZFN1cHBvcnRlZCIsImRldGVjdEludGVyc2VjdGlvbiIsIm9taXQiLCJiYXNldXRpbF9hbGxTdHJpbmdzIiwid2l0aG91dCIsImlzTnVtYmVyTGlrZSIsInNtYXJ0RXNjYXBlIiwiZGVmYXVsdHMiLCJvYmplY3RQcm90byIsIm9ialRvU3RyaW5nIiwiaXNPYmplY3QiLCJmdW5jVGFnIiwicmVXb3JkcyIsImNhbWVsQ2FzZSIsInNuYWtlQ2FzZSIsImNvbnZlcnRLZXlzIiwid2l0aENhbWVsQ2FzZUtleXMiLCJ3aXRoU25ha2VDYXNlS2V5cyIsImJhc2U2NEVuY29kZSIsImJhc2U2NEVuY29kZVVSTCIsImV4dHJhY3RVcmxQYXJhbXMiLCJwYXRjaEZldGNoRm9ybWF0Iiwib3B0aW9uQ29uc3VtZSIsImlzRW1wdHkiLCJpc0FuZHJvaWQiLCJpc0VkZ2UiLCJpc0Nocm9tZSIsImlzU2FmYXJpIiwiaXNFbGVtZW50X3Jvb3RfaXNFbGVtZW50X2RlZmF1bHQiLCJpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0IiwidHJpbV9yb290X3RyaW1fZGVmYXVsdCIsImxvZGFzaF9nZXREYXRhIiwibG9kYXNoX3NldERhdGEiLCJsb2Rhc2hfZ2V0QXR0cmlidXRlIiwibG9kYXNoX3NldEF0dHJpYnV0ZSIsImxvZGFzaF9yZW1vdmVBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGVzIiwibG9kYXNoX2hhc0NsYXNzIiwibG9kYXNoX2FkZENsYXNzIiwiZ2V0U3R5bGVzIiwiY3NzRXhwYW5kIiwiZG9tU3R5bGUiLCJjdXJDU1MiLCJjc3NWYWx1ZSIsImF1Z21lbnRXaWR0aE9ySGVpZ2h0IiwiZ2V0V2lkdGhPckhlaWdodCIsImxvZGFzaF93aWR0aCIsInV0ZjhfZW5jb2RlIiwiYXJnU3RyaW5nIiwiYzEiLCJlbmMiLCJlbmQiLCJzdGFydCIsInN0cmluZyIsInN0cmluZ2wiLCJ1dGZ0ZXh0IiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInNsaWNlIiwiY3JjMzIiLCJzdHIiLCJjcmMiLCJpVG9wIiwidGFibGUiLCJ4IiwieSIsInN1YnN0ciIsInN0cmluZ1BhZCIsInRhcmdldExlbmd0aCIsInBhZFN0cmluZyIsInJlcGVhdFN0cmluZ051bVRpbWVzIiwidGltZXMiLCJyZXBlYXRlZFN0cmluZyIsIl90b0NvbnN1bWFibGVBcnJheSIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXkiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJUeXBlRXJyb3IiLCJfYXJyYXlMaWtlVG9BcnJheSIsInRvU3RyaW5nIiwiY29uc3RydWN0b3IiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwiaXRlcmF0b3IiLCJpc0FycmF5IiwiZSIsImNoYXJzIiwiYmFzZTY0TWFwX251bSIsIm1hcCIsImZvckVhY2giLCJfY2hhciIsImJhc2U2NE1hcCIsInJldmVyc2VWZXJzaW9uIiwic2VtVmVyIiwic3BsaXQiLCJFcnJvciIsInJldmVyc2UiLCJzZWdtZW50Iiwiam9pbiIsImVuY29kZVZlcnNpb24iLCJzdHJSZXN1bHQiLCJwYXJ0cyIsInBhZGRlZFN0cmluZ0xlbmd0aCIsInBhZGRlZFJldmVyc2VkU2VtdmVyIiwibnVtIiwicGFyc2VJbnQiLCJwYWRkZWRCaW5hcnkiLCJtYXRjaCIsImJpdFN0cmluZyIsImFuYWx5dGljc09wdGlvbnMiLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJ0d29QYXJ0VmVyc2lvbiIsInJlbW92ZVBhdGNoRnJvbVNlbXZlciIsInRlY2hWZXJzaW9uIiwiZW5jb2RlZFNES1ZlcnNpb24iLCJzZGtTZW12ZXIiLCJlbmNvZGVkVGVjaFZlcnNpb24iLCJmZWF0dXJlQ29kZSIsImZlYXR1cmUiLCJTREtDb2RlIiwic2RrQ29kZSIsImFsZ29WZXJzaW9uIiwiY29uY2F0Iiwic2VtVmVyU3RyIiwib3B0aW9ucyIsInVybEFuYWx5dGljcyIsImFjY2Vzc2liaWxpdHkiLCJsb2FkaW5nIiwicmVzcG9uc2l2ZSIsInBsYWNlaG9sZGVyIiwiYXNzaWduX3Jvb3RfYXNzaWduXyIsImNsb25lRGVlcF9yb290X2Nsb25lRGVlcF8iLCJjb21wYWN0X3Jvb3RfY29tcGFjdF8iLCJkaWZmZXJlbmNlX3Jvb3RfZGlmZmVyZW5jZV8iLCJmdW5jdGlvbnNfcm9vdF9mdW5jdGlvbnNfIiwiaWRlbnRpdHlfcm9vdF9pZGVudGl0eV8iLCJpbmNsdWRlc19yb290X2luY2x1ZGVzXyIsImlzQXJyYXlfcm9vdF9pc0FycmF5XyIsImlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0XyIsImlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfIiwibWVyZ2Vfcm9vdF9tZXJnZV8iLCJpc0VsZW1lbnRfcm9vdF9pc0VsZW1lbnRfIiwiaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fIiwidHJpbV9yb290X3RyaW1fIiwiX3R5cGVvZiIsIndpbmRvdyIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwiSFRNTEltYWdlRWxlbWVudCIsImVsIiwib25JbnRlcnNlY3QiLCJvYnNlcnZlciIsImVudHJpZXMiLCJlbnRyeSIsImlzSW50ZXJzZWN0aW5nIiwidW5vYnNlcnZlIiwidGFyZ2V0IiwidGhyZXNob2xkIiwib2JzZXJ2ZSIsImZvcm1hdCIsInJlc291cmNlX3R5cGUiLCJ0cmFuc2Zvcm1hdGlvbiIsInR5cGUiLCJmYWxsYmFja19jb250ZW50Iiwic291cmNlX3RyYW5zZm9ybWF0aW9uIiwic291cmNlX3R5cGVzIiwiY29kZWNzIiwidHJhbnNmb3JtYXRpb25zIiwidmlkZW9fY29kZWMiLCJzZWVUaHJ1IiwiZWZmZWN0IiwicXVhbGl0eSIsImZldGNoX2Zvcm1hdCIsIndpZHRoIiwiYXNwZWN0X3JhdGlvIiwiY3JvcCIsImJhY2tncm91bmQiLCJoZWlnaHQiLCJncmF2aXR5IiwidmFyaWFibGVzIiwiZGFya21vZGUiLCJicmlnaHRtb2RlIiwibW9ub2Nocm9tZSIsImNvbG9yYmxpbmQiLCJiYXNldXRpbF90eXBlb2YiLCJvYmoiLCJrZXlzIiwic3JjS2V5cyIsImZpbHRlciIsImZpbHRlcmVkIiwiYWxsU3RyaW5ncyIsImxpc3QiLCJldmVyeSIsImFycmF5IiwiaXRlbSIsInYiLCJpc05hTiIsInBhcnNlRmxvYXQiLCJ1bnNhZmUiLCJyZXBsYWNlIiwidG9VcHBlckNhc2UiLCJkZXN0aW5hdGlvbiIsIl9sZW4iLCJzb3VyY2VzIiwiX2tleSIsInJlZHVjZSIsImRlc3QiLCJzb3VyY2UiLCJpc0Z1bmN0aW9uIiwibG93ZXIiLCJ1cHBlciIsIlJlZ0V4cCIsIndvcmRzIiwid29yZCIsImNoYXJBdCIsInRvTG9jYWxlVXBwZXJDYXNlIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJjb252ZXJ0ZXIiLCJyZXN1bHQiLCJidG9hIiwiQnVmZmVyIiwiaW5wdXQiLCJ1cmwiLCJkZWNvZGVVUkkiLCJlbmNvZGVVUkkiLCJvcHRpb25fbmFtZSIsImRlZmF1bHRfdmFsdWUiLCJzaXplIiwiZ2V0VXNlckFnZW50IiwibmF2aWdhdG9yIiwidXNlckFnZW50Iiwibm9kZUNvbnRhaW5zIiwiZ2V0RGF0YSIsImVsZW1lbnQiLCJnZXRBdHRyaWJ1dGUiLCJnZXRBdHRyIiwiZGF0YSIsImpRdWVyeSIsImZuIiwic2V0RGF0YSIsInNldEF0dHJpYnV0ZSIsInNldEF0dHIiLCJhdHRyIiwicmVtb3ZlQXR0cmlidXRlIiwiYXR0cmlidXRlcyIsInJlc3VsdHMiLCJwdXNoIiwiaGFzQ2xhc3MiLCJjbGFzc05hbWUiLCJhZGRDbGFzcyIsImVsZW0iLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJvcGVuZXIiLCJnZXRDb21wdXRlZFN0eWxlIiwiYiIsImFkb3duIiwiYnVwIiwibm9kZVR5cGUiLCJkb2N1bWVudEVsZW1lbnQiLCJwYXJlbnROb2RlIiwiY29udGFpbnMiLCJzdHlsZSIsImNvbXB1dGVkIiwibWF4V2lkdGgiLCJtaW5XaWR0aCIsInJldCIsInJtYXJnaW4iLCJnZXRQcm9wZXJ0eVZhbHVlIiwicm51bW5vbnB4IiwiY29udmVydCIsInN0eWxlcyIsInZhbCIsImV4dHJhIiwiaXNCb3JkZXJCb3giLCJsZW4iLCJzaWRlIiwic2lkZXMiLCJwbnVtIiwidmFsdWVJc0JvcmRlckJveCIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwiZXhwcmVzc2lvbl90eXBlb2YiLCJfY2xhc3NDYWxsQ2hlY2siLCJfZGVmaW5lUHJvcGVydGllcyIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJvcGVydHlLZXkiLCJfY3JlYXRlQ2xhc3MiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIk51bWJlciIsIkV4cHJlc3Npb24iLCJleHByZXNzaW9uU3RyIiwiZXhwcmVzc2lvbnMiLCJub3JtYWxpemUiLCJzZXJpYWxpemUiLCJnZXRQYXJlbnQiLCJwYXJlbnQiLCJzZXRQYXJlbnQiLCJwcmVkaWNhdGUiLCJvcGVyYXRvciIsIk9QRVJBVE9SUyIsImFuZCIsIm9yIiwidGhlbiIsImFzcGVjdFJhdGlvIiwicGFnZUNvdW50IiwiZmFjZUNvdW50IiwiX3ZhbHVlIiwiX25ldyIsIm9wZXJhdG9ycyIsIm9wZXJhdG9yc1BhdHRlcm4iLCJvcGVyYXRvcnNSZXBsYWNlUkUiLCJwcmVkZWZpbmVkVmFyc1BhdHRlcm4iLCJQUkVERUZJTkVEX1ZBUlMiLCJ1c2VyVmFyaWFibGVQYXR0ZXJuIiwidmFyaWFibGVzUmVwbGFjZVJFIiwidmFyaWFibGUiLCJpbml0aWFsV2lkdGgiLCJpbml0aWFsSGVpZ2h0IiwiaW5pdGlhbEFzcGVjdFJhdGlvIiwiY3VycmVudFBhZ2UiLCJ0YWdzIiwicGFnZVgiLCJwYWdlWSIsIkJPVU5EUlkiLCJjb25kaXRpb25fdHlwZW9mIiwiY29uZGl0aW9uX2NsYXNzQ2FsbENoZWNrIiwiY29uZGl0aW9uX2RlZmluZVByb3BlcnRpZXMiLCJjb25kaXRpb25fdG9Qcm9wZXJ0eUtleSIsImNvbmRpdGlvbl9jcmVhdGVDbGFzcyIsImNvbmRpdGlvbl90b1ByaW1pdGl2ZSIsIl9jYWxsU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0IiwiYXBwbHkiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJCb29sZWFuIiwidmFsdWVPZiIsInNldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJfaW5oZXJpdHMiLCJfc2V0UHJvdG90eXBlT2YiLCJDb25kaXRpb24iLCJfRXhwcmVzc2lvbiIsImNvbmRpdGlvblN0ciIsImR1cmF0aW9uIiwiaW5pdGlhbER1cmF0aW9uIiwiY29uZmlndXJhdGlvbl90eXBlb2YiLCJfc2xpY2VkVG9BcnJheSIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsImNvbmZpZ3VyYXRpb25fdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiY29uZmlndXJhdGlvbl9hcnJheUxpa2VUb0FycmF5IiwidSIsImYiLCJuZXh0IiwiZG9uZSIsImNvbmZpZ3VyYXRpb25fY2xhc3NDYWxsQ2hlY2siLCJjb25maWd1cmF0aW9uX2RlZmluZVByb3BlcnRpZXMiLCJjb25maWd1cmF0aW9uX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmF0aW9uX2NyZWF0ZUNsYXNzIiwiY29uZmlndXJhdGlvbl90b1ByaW1pdGl2ZSIsImNvbmZpZ3VyYXRpb25fQ29uZmlndXJhdGlvbiIsIkNvbmZpZ3VyYXRpb24iLCJjb25maWd1cmF0aW9uIiwiREVGQVVMVF9DT05GSUdVUkFUSU9OX1BBUkFNUyIsImluaXQiLCJmcm9tRW52aXJvbm1lbnQiLCJmcm9tRG9jdW1lbnQiLCJzZXQiLCJtZXJnZSIsImNvbmZpZyIsIm1ldGFfZWxlbWVudHMiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJfdGhpcyIsImNsb3VkaW5hcnlfdXJsIiwicXVlcnkiLCJ1cmkiLCJ1cmlSZWdleCIsInByb2Nlc3MiLCJlbnYiLCJDTE9VRElOQVJZX1VSTCIsImV4ZWMiLCJfdmFsdWUkc3BsaXQiLCJfdmFsdWUkc3BsaXQyIiwiayIsIm5ld19jb25maWciLCJuZXdfdmFsdWUiLCJ0b09wdGlvbnMiLCJyZXNwb25zaXZlX2NsYXNzIiwicmVzcG9uc2l2ZV91c2VfYnJlYWtwb2ludHMiLCJyb3VuZF9kcHIiLCJzZWN1cmUiLCJsb2NhdGlvbiIsInByb3RvY29sIiwiQ09ORklHX1BBUkFNUyIsImxheWVyX3R5cGVvZiIsImxheWVyX2NsYXNzQ2FsbENoZWNrIiwibGF5ZXJfZGVmaW5lUHJvcGVydGllcyIsImxheWVyX3RvUHJvcGVydHlLZXkiLCJsYXllcl9jcmVhdGVDbGFzcyIsImxheWVyX3RvUHJpbWl0aXZlIiwibGF5ZXJfTGF5ZXIiLCJMYXllciIsInJlZiIsInJlc291cmNlVHlwZSIsInB1YmxpY0lkIiwiZ2V0UHVibGljSWQiLCJnZXRGdWxsUHVibGljSWQiLCJjb21wb25lbnRzIiwiY2xvbmUiLCJ0ZXh0bGF5ZXJfdHlwZW9mIiwidGV4dGxheWVyX2NsYXNzQ2FsbENoZWNrIiwidGV4dGxheWVyX2RlZmluZVByb3BlcnRpZXMiLCJ0ZXh0bGF5ZXJfdG9Qcm9wZXJ0eUtleSIsInRleHRsYXllcl9jcmVhdGVDbGFzcyIsInRleHRsYXllcl90b1ByaW1pdGl2ZSIsInRleHRsYXllcl9jYWxsU3VwZXIiLCJ0ZXh0bGF5ZXJfZ2V0UHJvdG90eXBlT2YiLCJ0ZXh0bGF5ZXJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInRleHRsYXllcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJ0ZXh0bGF5ZXJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwidGV4dGxheWVyX2luaGVyaXRzIiwidGV4dGxheWVyX3NldFByb3RvdHlwZU9mIiwidGV4dGxheWVyX1RleHRMYXllciIsIl9MYXllciIsIlRleHRMYXllciIsIl9yZXNvdXJjZVR5cGUiLCJfdHlwZSIsIl9mb3JtYXQiLCJmb250RmFtaWx5IiwiX2ZvbnRGYW1pbHkiLCJmb250U2l6ZSIsIl9mb250U2l6ZSIsImZvbnRXZWlnaHQiLCJfZm9udFdlaWdodCIsImZvbnRTdHlsZSIsIl9mb250U3R5bGUiLCJ0ZXh0RGVjb3JhdGlvbiIsIl90ZXh0RGVjb3JhdGlvbiIsInRleHRBbGlnbiIsIl90ZXh0QWxpZ24iLCJzdHJva2UiLCJfc3Ryb2tlIiwibGV0dGVyU3BhY2luZyIsIl9sZXR0ZXJTcGFjaW5nIiwibGluZVNwYWNpbmciLCJfbGluZVNwYWNpbmciLCJmb250SGludGluZyIsIl9mb250SGludGluZyIsImZvbnRBbnRpYWxpYXNpbmciLCJfZm9udEFudGlhbGlhc2luZyIsInRleHQiLCJfdGV4dCIsInRleHRTdHlsZSIsIl90ZXh0U3R5bGUiLCJoYXNQdWJsaWNJZCIsImhhc1N0eWxlIiwicmUiLCJyZXMiLCJ0ZXh0U291cmNlIiwidGV4dFN0eWxlSWRlbnRpZmllciIsImluZGV4IiwidW5zaGlmdCIsInN1YnRpdGxlc2xheWVyX3R5cGVvZiIsInN1YnRpdGxlc2xheWVyX2RlZmluZVByb3BlcnRpZXMiLCJzdWJ0aXRsZXNsYXllcl90b1Byb3BlcnR5S2V5Iiwic3VidGl0bGVzbGF5ZXJfY3JlYXRlQ2xhc3MiLCJzdWJ0aXRsZXNsYXllcl90b1ByaW1pdGl2ZSIsInN1YnRpdGxlc2xheWVyX2NsYXNzQ2FsbENoZWNrIiwic3VidGl0bGVzbGF5ZXJfY2FsbFN1cGVyIiwic3VidGl0bGVzbGF5ZXJfZ2V0UHJvdG90eXBlT2YiLCJzdWJ0aXRsZXNsYXllcl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwic3VidGl0bGVzbGF5ZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0Iiwic3VidGl0bGVzbGF5ZXJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwic3VidGl0bGVzbGF5ZXJfaW5oZXJpdHMiLCJzdWJ0aXRsZXNsYXllcl9zZXRQcm90b3R5cGVPZiIsIlN1YnRpdGxlc0xheWVyIiwiX1RleHRMYXllciIsImZldGNobGF5ZXJfdHlwZW9mIiwiZmV0Y2hsYXllcl9jbGFzc0NhbGxDaGVjayIsImZldGNobGF5ZXJfZGVmaW5lUHJvcGVydGllcyIsImZldGNobGF5ZXJfdG9Qcm9wZXJ0eUtleSIsImZldGNobGF5ZXJfY3JlYXRlQ2xhc3MiLCJmZXRjaGxheWVyX3RvUHJpbWl0aXZlIiwiZmV0Y2hsYXllcl9jYWxsU3VwZXIiLCJmZXRjaGxheWVyX2dldFByb3RvdHlwZU9mIiwiZmV0Y2hsYXllcl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiZmV0Y2hsYXllcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJmZXRjaGxheWVyX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsImZldGNobGF5ZXJfaW5oZXJpdHMiLCJmZXRjaGxheWVyX3NldFByb3RvdHlwZU9mIiwiZmV0Y2hsYXllcl9GZXRjaExheWVyIiwiRmV0Y2hMYXllciIsIl91cmwiLCJwYXJhbWV0ZXJzX2NhbGxTdXBlciIsInBhcmFtZXRlcnNfZ2V0UHJvdG90eXBlT2YiLCJwYXJhbWV0ZXJzX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJwYXJhbWV0ZXJzX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsInBhcmFtZXRlcnNfdHlwZW9mIiwicGFyYW1ldGVyc19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJfc3VwZXJQcm9wR2V0IiwiX2dldCIsIl9zdXBlclByb3BCYXNlIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwicGFyYW1ldGVyc19pbmhlcml0cyIsInBhcmFtZXRlcnNfc2V0UHJvdG90eXBlT2YiLCJwYXJhbWV0ZXJzX2NsYXNzQ2FsbENoZWNrIiwicGFyYW1ldGVyc19kZWZpbmVQcm9wZXJ0aWVzIiwicGFyYW1ldGVyc190b1Byb3BlcnR5S2V5IiwicGFyYW1ldGVyc19jcmVhdGVDbGFzcyIsInBhcmFtZXRlcnNfdG9QcmltaXRpdmUiLCJwYXJhbWV0ZXJzX1BhcmFtIiwiUGFyYW0iLCJzaG9ydE5hbWUiLCJvcmlnVmFsdWUiLCJ2YWxpZCIsIm5vcm1fY29sb3IiLCJidWlsZF9hcnJheSIsImFyZyIsInByb2Nlc3NfdmlkZW9fcGFyYW1zIiwicGFyYW0iLCJ2aWRlbyIsImNvZGVjIiwicHJvZmlsZSIsImxldmVsIiwiYl9mcmFtZXMiLCJwYXJhbWV0ZXJzX0FycmF5UGFyYW0iLCJfUGFyYW0iLCJBcnJheVBhcmFtIiwic2VwIiwiYXJyYXlWYWx1ZSIsImZsYXQiLCJfdGhpczIiLCJwYXJhbWV0ZXJzX1RyYW5zZm9ybWF0aW9uUGFyYW0iLCJfUGFyYW0yIiwiVHJhbnNmb3JtYXRpb25QYXJhbSIsIl90aGlzMyIsIl90aGlzNCIsImpvaW5lZCIsIm9yaWdWYWx1ZTEiLCJudW1iZXJfcGF0dGVybiIsIm9mZnNldF9hbnlfcGF0dGVybiIsInBhcmFtZXRlcnNfUmFuZ2VQYXJhbSIsIl9QYXJhbTMiLCJSYW5nZVBhcmFtIiwibm9ybV9yYW5nZV92YWx1ZSIsIm9mZnNldCIsIm1vZGlmaWVyIiwicGFyYW1ldGVyc19SYXdQYXJhbSIsIl9QYXJhbTQiLCJSYXdQYXJhbSIsInBhcmFtZXRlcnNfTGF5ZXJQYXJhbSIsIl9QYXJhbTUiLCJMYXllclBhcmFtIiwibGF5ZXJPcHRpb25zIiwibGF5ZXIiLCJwYXJhbWV0ZXJzX0V4cHJlc3Npb25QYXJhbSIsIl9QYXJhbTYiLCJFeHByZXNzaW9uUGFyYW0iLCJ0cmFuc2Zvcm1hdGlvbl9jYWxsU3VwZXIiLCJ0cmFuc2Zvcm1hdGlvbl9nZXRQcm90b3R5cGVPZiIsInRyYW5zZm9ybWF0aW9uX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJ0cmFuc2Zvcm1hdGlvbl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJ0cmFuc2Zvcm1hdGlvbl90eXBlb2YiLCJ0cmFuc2Zvcm1hdGlvbl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJ0cmFuc2Zvcm1hdGlvbl9pbmhlcml0cyIsInRyYW5zZm9ybWF0aW9uX3NldFByb3RvdHlwZU9mIiwidHJhbnNmb3JtYXRpb25fc2xpY2VkVG9BcnJheSIsInRyYW5zZm9ybWF0aW9uX2FycmF5V2l0aEhvbGVzIiwidHJhbnNmb3JtYXRpb25faXRlcmFibGVUb0FycmF5TGltaXQiLCJ0cmFuc2Zvcm1hdGlvbl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsInRyYW5zZm9ybWF0aW9uX25vbkl0ZXJhYmxlUmVzdCIsInRyYW5zZm9ybWF0aW9uX2FycmF5TGlrZVRvQXJyYXkiLCJ0cmFuc2Zvcm1hdGlvbl9jbGFzc0NhbGxDaGVjayIsInRyYW5zZm9ybWF0aW9uX2RlZmluZVByb3BlcnRpZXMiLCJ0cmFuc2Zvcm1hdGlvbl90b1Byb3BlcnR5S2V5IiwidHJhbnNmb3JtYXRpb25fY3JlYXRlQ2xhc3MiLCJ0cmFuc2Zvcm1hdGlvbl90b1ByaW1pdGl2ZSIsImFzc2lnbk5vdE51bGwiLCJ0cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbkJhc2UiLCJUcmFuc2Zvcm1hdGlvbkJhc2UiLCJ0cmFucyIsIndpdGhDaGFpbiIsIm9wdCIsIm90aGVyT3B0aW9ucyIsImNoYWluZWQiLCJ0ciIsImZyb21PcHRpb25zIiwiYWJiciIsImRlZmF1bHRWYWx1ZSIsInJhd1BhcmFtIiwibGFzdEFyZ0NhbGxiYWNrIiwicmFuZ2VQYXJhbSIsImFycmF5UGFyYW0iLCJ0cmFuc2Zvcm1hdGlvblBhcmFtIiwibGF5ZXJQYXJhbSIsImdldFZhbHVlIiwicmVtb3ZlIiwidGVtcCIsIlZBUl9OQU1FX1JFIiwic29ydCIsInRvUGxhaW5PYmplY3QiLCJoYXNoIiwiY2hhaW4iLCJuYW1lcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJyZXNldFRyYW5zZm9ybWF0aW9ucyIsImZyb21UcmFuc2Zvcm1hdGlvbiIsIm90aGVyIiwiY2FtZWxLZXkiLCJfbGVuMiIsInZhbHVlcyIsIl9rZXkyIiwidHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb24iLCJtZXRob2RzIiwiaGFzTGF5ZXIiLCJpZlBhcmFtIiwiaiIsInBhcmFtTGlzdCIsInJlZjEiLCJyZWYyIiwicmVmMyIsInJlZjQiLCJyZXN1bHRBcnJheSIsInRyYW5zZm9ybWF0aW9uTGlzdCIsInRyYW5zZm9ybWF0aW9uU3RyaW5nIiwidmFycyIsInByb2Nlc3NWYXIiLCJsZW4xIiwicGFyYW1fc2VwYXJhdG9yIiwidHJhbnNfc2VwYXJhdG9yIiwidG9IdG1sQXR0cmlidXRlcyIsImF0dHJOYW1lIiwic25ha2VDYXNlS2V5IiwiUEFSQU1fTkFNRVMiLCJ0b0h0bWwiLCJsaXN0TmFtZXMiLCJpc1ZhbGlkUGFyYW1OYW1lIiwiaW5kZXhPZiIsImFyZ3MiLCJjYWxsYmFjayIsInZhckFycmF5IiwiX3ZhckFycmF5JGoiLCJwcm9jZXNzQ3VzdG9tRnVuY3Rpb24iLCJfcmVmIiwiZnVuY3Rpb25fdHlwZSIsIl9UcmFuc2Zvcm1hdGlvbkJhc2UiLCJUcmFuc2Zvcm1hdGlvbiIsImFuZ2xlIiwiYXVkaW9Db2RlYyIsImF1ZGlvRnJlcXVlbmN5IiwiYml0UmF0ZSIsImJvcmRlciIsImNvbG9yIiwiY29sb3JTcGFjZSIsImN1c3RvbUZ1bmN0aW9uIiwiY3VzdG9tUHJlRnVuY3Rpb24iLCJkZWZhdWx0SW1hZ2UiLCJkZWxheSIsImRlbnNpdHkiLCJkcHIiLCJfZWxzZSIsImVuZElmIiwiZW5kT2Zmc2V0IiwiZmFsbGJhY2tDb250ZW50IiwiZmV0Y2hGb3JtYXQiLCJmbGFncyIsImZwcyIsImh0bWxIZWlnaHQiLCJodG1sV2lkdGgiLCJfaWYiLCJpZlZhbCIsInRySWYiLCJ0clJlc3QiLCJrZXlmcmFtZUludGVydmFsIiwib2NyIiwiZW5kX28iLCJzdGFydF9vIiwiX3JlZjIiLCJfcmVmMyIsInN0YXJ0T2Zmc2V0Iiwib3BhY2l0eSIsIm92ZXJsYXkiLCJwYWdlIiwicG9zdGVyIiwicHJlZml4IiwicmFkaXVzIiwicmF3VHJhbnNmb3JtYXRpb24iLCJzb3VyY2VUeXBlcyIsInNvdXJjZVRyYW5zZm9ybWF0aW9uIiwic3RyZWFtaW5nUHJvZmlsZSIsInVuZGVybGF5IiwidmlkZW9Db2RlYyIsInZpZGVvU2FtcGxpbmciLCJ6b29tIiwiaHRtbHRhZ190eXBlb2YiLCJodG1sdGFnX2NsYXNzQ2FsbENoZWNrIiwiaHRtbHRhZ19kZWZpbmVQcm9wZXJ0aWVzIiwiaHRtbHRhZ190b1Byb3BlcnR5S2V5IiwiaHRtbHRhZ19jcmVhdGVDbGFzcyIsImh0bWx0YWdfdG9QcmltaXRpdmUiLCJodG1sdGFnX0h0bWxUYWciLCJIdG1sVGFnIiwiaHRtbEF0dHJzIiwiYXR0cnMiLCJwYWlycyIsImVzY2FwZVF1b3RlcyIsImh0bWx0YWdfdG9BdHRyaWJ1dGUiLCJnZXRPcHRpb25zIiwiZ2V0T3B0aW9uIiwiaHRtbEF0dHJpYnV0ZXMiLCJyZW1vdmVBdHRyIiwiY29udGVudCIsIm9wZW5UYWciLCJ0YWciLCJjbG9zZVRhZyIsInRvRE9NIiwiY3JlYXRlRWxlbWVudCIsImlzUmVzcG9uc2l2ZSIsInJlc3BvbnNpdmVDbGFzcyIsImRhdGFTcmMiLCJfZXhjbHVkZWQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImdldE93blByb3BlcnR5U3ltYm9scyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwibWFrZVVybCIsImhvc3QiLCJwYXRobmFtZSIsImlzVXJsIiwiY2RuU3ViZG9tYWluTnVtYmVyIiwiaGFuZGxlU2lnbmF0dXJlIiwic2lnbmF0dXJlIiwiaXNGb3JtYXR0ZWQiLCJoYW5kbGVQcmVmaXgiLCJjbG91ZF9uYW1lIiwiY2RuUGFydCIsInN1YmRvbWFpbiIsInBhdGgiLCJwcml2YXRlX2NkbiIsImNkbl9zdWJkb21haW4iLCJzZWN1cmVfY2RuX3N1YmRvbWFpbiIsInNlY3VyZV9kaXN0cmlidXRpb24iLCJjbmFtZSIsImhhbmRsZVJlc291cmNlVHlwZSIsIl9yZWYkcmVzb3VyY2VfdHlwZSIsIl9yZWYkdHlwZSIsInVybF9zdWZmaXgiLCJ1c2Vfcm9vdF9wYXRoIiwic2hvcnRlbiIsImVuY29kZVB1YmxpY0lkIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZm9ybWF0UHVibGljSWQiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlcnJvciIsInRydXN0X3B1YmxpY19pZCIsInZhbGlkYXRlIiwiaGFuZGxlVmVyc2lvbiIsImlzRm9yY2VWZXJzaW9uIiwiZm9yY2VfdmVyc2lvbiIsImlzVmVyc2lvbkV4aXN0IiwidmVyc2lvbiIsImhhbmRsZVRyYW5zZm9ybWF0aW9uIiwicGxhY2Vob2xkZXJUcmFuc2Zvcm1hdGlvbnMiLCJibHVyIiwicHJlcGFyZVB1YmxpY0lkIiwidXJsU3RyaW5nIiwicHJlcGFyZU9wdGlvbnMiLCJ1cmxfdXJsIiwicmVzdWx0VXJsIiwic2RrQW5hbHl0aWNzU2lnbmF0dXJlIiwiYXBwZW5kZXIiLCJhdXRoX3Rva2VuIiwiX2FwcGVuZGVyIiwiZ2VuZXJhdGVCcmVha3BvaW50c19zbGljZWRUb0FycmF5IiwiZ2VuZXJhdGVCcmVha3BvaW50c19hcnJheVdpdGhIb2xlcyIsImdlbmVyYXRlQnJlYWtwb2ludHNfaXRlcmFibGVUb0FycmF5TGltaXQiLCJnZW5lcmF0ZUJyZWFrcG9pbnRzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiZ2VuZXJhdGVCcmVha3BvaW50c19ub25JdGVyYWJsZVJlc3QiLCJnZW5lcmF0ZUJyZWFrcG9pbnRzX2FycmF5TGlrZVRvQXJyYXkiLCJnZW5lcmF0ZUJyZWFrcG9pbnRzIiwic3Jjc2V0IiwiYnJlYWtwb2ludHMiLCJfbWFwIiwibWluX3dpZHRoIiwibWF4X3dpZHRoIiwibWF4X2ltYWdlcyIsIl9tYXAyIiwic29tZSIsInN0ZXBTaXplIiwiTWF0aCIsImNlaWwiLCJtYXgiLCJjdXJyZW50Iiwic3Jjc2V0VXRpbHNfaXNFbXB0eSIsInNjYWxlZFVybCIsInB1YmxpY19pZCIsImNvbmZpZ1BhcmFtcyIsInJhd190cmFuc2Zvcm1hdGlvbiIsImdldE9yR2VuZXJhdGVCcmVha3BvaW50cyIsImdlbmVyYXRlU3Jjc2V0QXR0cmlidXRlIiwiZ2VuZXJhdGVTaXplc0F0dHJpYnV0ZSIsImdlbmVyYXRlSW1hZ2VSZXNwb25zaXZlQXR0cmlidXRlcyIsInNyY3NldERhdGEiLCJyZXNwb25zaXZlQXR0cmlidXRlcyIsImdlbmVyYXRlU2l6ZXMiLCJzaXplcyIsImdlbmVyYXRlU3Jjc2V0Iiwic3Jjc2V0QXR0ciIsInNpemVzQXR0ciIsImdlbmVyYXRlTWVkaWFBdHRyIiwibWVkaWFRdWVyeSIsInNyY3NldFVybCIsImltYWdldGFnX3R5cGVvZiIsImltYWdldGFnX2NsYXNzQ2FsbENoZWNrIiwiaW1hZ2V0YWdfZGVmaW5lUHJvcGVydGllcyIsImltYWdldGFnX3RvUHJvcGVydHlLZXkiLCJpbWFnZXRhZ19jcmVhdGVDbGFzcyIsImltYWdldGFnX3RvUHJpbWl0aXZlIiwiaW1hZ2V0YWdfY2FsbFN1cGVyIiwiaW1hZ2V0YWdfZ2V0UHJvdG90eXBlT2YiLCJpbWFnZXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiaW1hZ2V0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiaW1hZ2V0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiaW1hZ2V0YWdfc3VwZXJQcm9wR2V0IiwiaW1hZ2V0YWdfZ2V0IiwiaW1hZ2V0YWdfc3VwZXJQcm9wQmFzZSIsImltYWdldGFnX2luaGVyaXRzIiwiaW1hZ2V0YWdfc2V0UHJvdG90eXBlT2YiLCJpbWFnZXRhZ19JbWFnZVRhZyIsIl9IdG1sVGFnIiwiSW1hZ2VUYWciLCJzcmNBdHRyaWJ1dGUiLCJzcmNzZXRQYXJhbSIsImNsaWVudF9oaW50cyIsInNvdXJjZXRhZ190eXBlb2YiLCJzb3VyY2V0YWdfY2xhc3NDYWxsQ2hlY2siLCJzb3VyY2V0YWdfZGVmaW5lUHJvcGVydGllcyIsInNvdXJjZXRhZ190b1Byb3BlcnR5S2V5Iiwic291cmNldGFnX2NyZWF0ZUNsYXNzIiwic291cmNldGFnX3RvUHJpbWl0aXZlIiwic291cmNldGFnX2NhbGxTdXBlciIsInNvdXJjZXRhZ19nZXRQcm90b3R5cGVPZiIsInNvdXJjZXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwic291cmNldGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsInNvdXJjZXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJzb3VyY2V0YWdfc3VwZXJQcm9wR2V0Iiwic291cmNldGFnX2dldCIsInNvdXJjZXRhZ19zdXBlclByb3BCYXNlIiwic291cmNldGFnX2luaGVyaXRzIiwic291cmNldGFnX3NldFByb3RvdHlwZU9mIiwic291cmNldGFnX1NvdXJjZVRhZyIsIlNvdXJjZVRhZyIsIm1lZGlhIiwic291cmNldGFnIiwicGljdHVyZXRhZ190eXBlb2YiLCJwaWN0dXJldGFnX2NsYXNzQ2FsbENoZWNrIiwicGljdHVyZXRhZ19kZWZpbmVQcm9wZXJ0aWVzIiwicGljdHVyZXRhZ190b1Byb3BlcnR5S2V5IiwicGljdHVyZXRhZ19jcmVhdGVDbGFzcyIsInBpY3R1cmV0YWdfdG9QcmltaXRpdmUiLCJwaWN0dXJldGFnX2NhbGxTdXBlciIsInBpY3R1cmV0YWdfZ2V0UHJvdG90eXBlT2YiLCJwaWN0dXJldGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJwaWN0dXJldGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsInBpY3R1cmV0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwicGljdHVyZXRhZ19zdXBlclByb3BHZXQiLCJwaWN0dXJldGFnX2dldCIsInBpY3R1cmV0YWdfc3VwZXJQcm9wQmFzZSIsInBpY3R1cmV0YWdfaW5oZXJpdHMiLCJwaWN0dXJldGFnX3NldFByb3RvdHlwZU9mIiwicGljdHVyZXRhZ19QaWN0dXJlVGFnIiwiUGljdHVyZVRhZyIsIndpZHRoTGlzdCIsInZpZGVvdGFnX3R5cGVvZiIsInZpZGVvdGFnX2NsYXNzQ2FsbENoZWNrIiwidmlkZW90YWdfZGVmaW5lUHJvcGVydGllcyIsInZpZGVvdGFnX3RvUHJvcGVydHlLZXkiLCJ2aWRlb3RhZ19jcmVhdGVDbGFzcyIsInZpZGVvdGFnX3RvUHJpbWl0aXZlIiwidmlkZW90YWdfY2FsbFN1cGVyIiwidmlkZW90YWdfZ2V0UHJvdG90eXBlT2YiLCJ2aWRlb3RhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwidmlkZW90YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwidmlkZW90YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwidmlkZW90YWdfc3VwZXJQcm9wR2V0IiwidmlkZW90YWdfZ2V0IiwidmlkZW90YWdfc3VwZXJQcm9wQmFzZSIsInZpZGVvdGFnX2luaGVyaXRzIiwidmlkZW90YWdfc2V0UHJvdG90eXBlT2YiLCJWSURFT19UQUdfUEFSQU1TIiwidmlkZW90YWdfREVGQVVMVF9WSURFT19TT1VSQ0VfVFlQRVMiLCJ2aWRlb3RhZ19ERUZBVUxUX1BPU1RFUl9PUFRJT05TIiwidmlkZW90YWdfVmlkZW9UYWciLCJWaWRlb1RhZyIsInNldFNvdXJjZVRyYW5zZm9ybWF0aW9uIiwic2V0U291cmNlVHlwZXMiLCJzZXRQb3N0ZXIiLCJzZXRGYWxsYmFja0NvbnRlbnQiLCJmYWxsYmFjayIsImlubmVyVGFncyIsInNyYyIsImNyZWF0ZVNvdXJjZVRhZyIsInNyY1R5cGUiLCJkZWZhdWx0T3B0aW9ucyIsImhhc1NvdXJjZVRhZ3MiLCJzb3VyY2VUeXBlIiwibWltZVR5cGUiLCJ2aWRlb1R5cGUiLCJjb2RlY3NTdHIiLCJjbGllbnRoaW50c21ldGF0YWdfdHlwZW9mIiwiY2xpZW50aGludHNtZXRhdGFnX2NsYXNzQ2FsbENoZWNrIiwiY2xpZW50aGludHNtZXRhdGFnX2RlZmluZVByb3BlcnRpZXMiLCJjbGllbnRoaW50c21ldGF0YWdfdG9Qcm9wZXJ0eUtleSIsImNsaWVudGhpbnRzbWV0YXRhZ19jcmVhdGVDbGFzcyIsImNsaWVudGhpbnRzbWV0YXRhZ190b1ByaW1pdGl2ZSIsImNsaWVudGhpbnRzbWV0YXRhZ19jYWxsU3VwZXIiLCJjbGllbnRoaW50c21ldGF0YWdfZ2V0UHJvdG90eXBlT2YiLCJjbGllbnRoaW50c21ldGF0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsImNsaWVudGhpbnRzbWV0YXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJjbGllbnRoaW50c21ldGF0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiY2xpZW50aGludHNtZXRhdGFnX2luaGVyaXRzIiwiY2xpZW50aGludHNtZXRhdGFnX3NldFByb3RvdHlwZU9mIiwiY2xpZW50aGludHNtZXRhdGFnX0NsaWVudEhpbnRzTWV0YVRhZyIsIkNsaWVudEhpbnRzTWV0YVRhZyIsIm5vcm1hbGl6ZVRvQXJyYXlfdG9Db25zdW1hYmxlQXJyYXkiLCJub3JtYWxpemVUb0FycmF5X2FycmF5V2l0aG91dEhvbGVzIiwibm9ybWFsaXplVG9BcnJheV9pdGVyYWJsZVRvQXJyYXkiLCJub3JtYWxpemVUb0FycmF5X3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5Iiwibm9ybWFsaXplVG9BcnJheV9ub25JdGVyYWJsZVNwcmVhZCIsIm5vcm1hbGl6ZVRvQXJyYXlfYXJyYXlMaWtlVG9BcnJheSIsIm5vcm1hbGl6ZVRvQXJyYXkiLCJlbGVtZW50cyIsIm1vdW50Q2xvdWRpbmFyeVZpZGVvVGFnIiwiaHRtbEVsQ29udGFpbmVyIiwiY2xJbnN0YW5jZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiaW5uZXJIVE1MIiwidmlkZW9UYWciLCJjbG91ZGluYXJ5VmlkZW9FbGVtZW50IiwicXVlcnlTZWxlY3RvciIsInRyYW5zcGFyZW50VmlkZW9fbW91bnRDbG91ZGluYXJ5VmlkZW9UYWciLCJhZGRGbGFnVG9PcHRpb25zIiwiZmxhZyIsImFkZEZsYWciLCJlbmZvcmNlT3B0aW9uc0ZvclRyYW5zcGFyZW50VmlkZW8iLCJhdXRvcGxheSIsIm11dGVkIiwiY29udHJvbHMiLCJtYXhfdGltZW91dF9tcyIsImV4dGVybmFsTGlicmFyaWVzIiwidHJhbnNwYXJlbnRWaWRlb19lbmZvcmNlT3B0aW9uc0ZvclRyYW5zcGFyZW50VmlkZW8iLCJsb2FkU2NyaXB0Iiwic2NyaXB0VVJMIiwiaXNBbHJlYWR5TG9hZGVkIiwic2NyaXB0VGFnIiwidGltZXJJRCIsInNldFRpbWVvdXQiLCJzdGF0dXMiLCJtZXNzYWdlIiwib25lcnJvciIsImNsZWFyVGltZW91dCIsIm9ubG9hZCIsImhlYWQiLCJhcHBlbmRDaGlsZCIsInhocl9sb2FkU2NyaXB0IiwicmVqZWN0T25UaW1lb3V0IiwibWF4VGltZW91dE1TIiwiZ2V0QmxvYkZyb21VUkwiLCJ1cmxUb0xvYWQiLCJmZXRjaEJsb2IiLCJmZXRjaCIsImxvYWRVcmxVc2luZ0ZldGNoIiwibG9hZFVybFVzaW5nWGhyIiwiYmxvYiIsInBheWxvYWQiLCJibG9iVVJMIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwicmVzcG9uc2UiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsInJlc3BvbnNlVHlwZSIsIm9wZW4iLCJzZW5kIiwieGhyX2dldEJsb2JGcm9tVVJMIiwiY3JlYXRlSGlkZGVuVmlkZW9UYWciLCJ2aWRlb09wdGlvbnMiLCJwbGF5c2lubGluZSIsImxvb3AiLCJ2aWRlb1VSTCIsInZpc2liaWxpdHkiLCJwb3NpdGlvbiIsInJldm9rZU9iamVjdFVSTCIsInRyYW5zcGFyZW50VmlkZW9fY3JlYXRlSGlkZGVuVmlkZW9UYWciLCJpbnN0YW50aWF0ZVNlZVRocnUiLCJ2aWRlb0VsZW1lbnQiLCJjdXN0b21DbGFzcyIsImF1dG9QbGF5IiwiX3dpbmRvdyIsInNlZVRocnVJbnN0YW5jZSIsInJlYWR5IiwiY2FudmFzRWxlbWVudCIsImdldENhbnZhcyIsInBsYXkiLCJ0cmFuc3BhcmVudFZpZGVvX2luc3RhbnRpYXRlU2VlVGhydSIsIm1vdW50U2VlVGhydUNhbnZhc1RhZyIsImVyciIsInRyYW5zcGFyZW50VmlkZW9fbW91bnRTZWVUaHJ1Q2FudmFzVGFnIiwiY2hlY2tTdXBwb3J0Rm9yVHJhbnNwYXJlbmN5IiwiY2FuUGxheSIsImNhblBsYXlUeXBlIiwidHJhbnNwYXJlbnRWaWRlb19jaGVja1N1cHBvcnRGb3JUcmFuc3BhcmVuY3kiLCJjbG91ZGluYXJ5X3R5cGVvZiIsImNsb3VkaW5hcnlfY2xhc3NDYWxsQ2hlY2siLCJjbG91ZGluYXJ5X2RlZmluZVByb3BlcnRpZXMiLCJjbG91ZGluYXJ5X3RvUHJvcGVydHlLZXkiLCJjbG91ZGluYXJ5X2NyZWF0ZUNsYXNzIiwiY2xvdWRpbmFyeV90b1ByaW1pdGl2ZSIsImFwcGx5QnJlYWtwb2ludHMiLCJjbG9zZXN0QWJvdmUiLCJkZWZhdWx0QnJlYWtwb2ludHMiLCJjbG91ZGluYXJ5X2ZpbmRDb250YWluZXJXaWR0aCIsImNsb3VkaW5hcnlfbWF4V2lkdGgiLCJ1cGRhdGVEcHIiLCJzdGVwcyIsInJlc2l6aW5nIiwiY2FsY19icmVha3BvaW50IiwiZmluZENvbnRhaW5lcldpZHRoIiwiY29udGFpbmVyV2lkdGgiLCJFbGVtZW50IiwiZGlzcGxheSIsInJvdW5kRHByIiwiZGV2aWNlX3BpeGVsX3JhdGlvIiwicmVxdWlyZWRXaWR0aCIsImltYWdlV2lkdGgiLCJjbG91ZGluYXJ5X0Nsb3VkaW5hcnkiLCJDbG91ZGluYXJ5IiwiZGV2aWNlUGl4ZWxSYXRpb0NhY2hlIiwicmVzcG9uc2l2ZUNvbmZpZyIsInJlc3BvbnNpdmVSZXNpemVJbml0aWFsaXplZCIsIm5ld0NvbmZpZyIsIm5ld1ZhbHVlIiwidmlkZW9fdXJsIiwidmlkZW9fdGh1bWJuYWlsX3VybCIsInRyYW5zZm9ybWF0aW9uX3N0cmluZyIsImltYWdlIiwiaW1nIiwiaW1hZ2VUYWciLCJjbG91ZGluYXJ5X3VwZGF0ZSIsInBpY3R1cmVUYWciLCJzb3VyY2VUYWciLCJ2aWRlb190aHVtYm5haWwiLCJmYWNlYm9va19wcm9maWxlX2ltYWdlIiwidHdpdHRlcl9wcm9maWxlX2ltYWdlIiwidHdpdHRlcl9uYW1lX3Byb2ZpbGVfaW1hZ2UiLCJncmF2YXRhcl9pbWFnZSIsImZldGNoX2ltYWdlIiwic3ByaXRlX2NzcyIsImJvb3RzdHJhcCIsInJlc3BvbnNpdmVSZXNpemUiLCJ0aW1lb3V0IiwicmVzcG9uc2l2ZV9yZXNpemUiLCJtYWtlUmVzcG9uc2l2ZSIsImRlYm91bmNlIiwicmVzZXQiLCJydW4iLCJ3YWl0Iiwid2FpdEZ1bmMiLCJyZXNwb25zaXZlX2RlYm91bmNlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwb2ludCIsImNhbGNfc3RvcHBvaW50IiwiZGV2aWNlUGl4ZWxSYXRpbyIsImRwclN0cmluZyIsInByb2Nlc3NJbWFnZVRhZ3MiLCJub2RlcyIsImltYWdlcyIsIm5vZGUiLCJ0YWdOYW1lIiwiaW1nT3B0aW9ucyIsInNldFVybCIsInJlc3BvbnNpdmVfcHJlc2VydmVfaGVpZ2h0IiwiaXNMYXp5TG9hZGluZyIsImlzTGF6eUxvYWRTdXBwb3J0ZWQiLCJzZXRBdHRyaWJ1dGVJZkV4aXN0cyIsInRvQXR0cmlidXRlIiwiZnJvbUF0dHJpYnV0ZSIsImF0dHJpYnV0ZVZhbHVlIiwiaW5qZWN0VHJhbnNwYXJlbnRWaWRlb0VsZW1lbnQiLCJpc05hdGl2ZWx5VHJhbnNwYXJlbnQiLCJtb3VudFByb21pc2UiLCJjbG91ZGluYXJ5X2NvcmUiLCJVdGlsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/cloudinary-core/cloudinary-core.js\n");

/***/ })

};
;